<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Havenvoy</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Light Theme (Default - Warm Parchment) */
            --parchment: #f0e6d3; --parchment-dark: #d4c4a8; --ink: #2c1810; --ink-light: #5c4830;
            --gold: #c9a227; --gold-dark: #a07f1c; --gold-light: #ddb84a;
            --sea-dark: #1a3a4a; --sea-medium: #2d5a6a; --sea-light: #4a8a9a;
            --blood-red: #b82525; --wood: #6b4423; --wood-dark: #3d2512;
            --sail-white: #f5f0e1; --english: #c41e3a; --eitc: #1e5a3a; --pirates: #2c2c2c;
            --neutral: #5a5a5a;
            --modal-bg: rgba(20, 15, 10, 0.92);
            --card-bg: rgba(240, 230, 211, 0.95);
            --hud-bg: rgba(240, 230, 211, 0.92);
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            --shadow-light: 0 2px 10px rgba(0, 0, 0, 0.25);
            --shadow-glow: 0 0 15px rgba(201, 162, 39, 0.4);
            --font-display: 'Cinzel', serif;
            --font-body: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --space-xs: 4px; --space-sm: 8px; --space-md: 16px; --space-lg: 24px; --space-xl: 32px;
            --touch-min: 48px;
            --radius-sm: 8px; --radius-md: 12px; --radius-lg: 16px; --radius-full: 9999px;
            --action-stack-h: 175px; --action-stack-bottom: 15px;
            /* Animation Timing */
            --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
            --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
            --ease-bounce: cubic-bezier(0.34, 1.56, 0.64, 1);
            --duration-fast: 0.15s;
            --duration-normal: 0.2s;
            --duration-slow: 0.3s;
            /* Visual Effects */
            --glow-gold: 0 0 15px rgba(201, 162, 39, 0.5);
            --glow-sea: 0 0 15px rgba(74, 138, 154, 0.4);
            --glow-danger: 0 0 15px rgba(184, 37, 37, 0.5);
            --particle-speed: 8s;
            --theme-transition: 0.3s ease;
        }

        /* Dark Theme (Night Mode) */
        [data-theme="dark"] {
            --parchment: #1e1a15; --parchment-dark: #2a2520; --ink: #e8dcc8; --ink-light: #a89880;
            --gold: #e6b800; --gold-dark: #c49a00; --gold-light: #ffd54f;
            --sea-dark: #0d1a22; --sea-medium: #162a35; --sea-light: #1e3a4a;
            --blood-red: #e64545; --wood: #3d2a1a; --wood-dark: #261a0f;
            --sail-white: #252018; --modal-bg: rgba(15, 12, 10, 0.95);
            --card-bg: rgba(30, 26, 21, 0.95);
            --hud-bg: rgba(30, 26, 21, 0.92);
            --shadow: 0 4px 25px rgba(0, 0, 0, 0.6);
            --shadow-light: 0 2px 12px rgba(0, 0, 0, 0.4);
            --shadow-glow: 0 0 20px rgba(230, 184, 0, 0.3);
            --glow-gold: 0 0 20px rgba(230, 184, 0, 0.4);
            --glow-sea: 0 0 18px rgba(30, 58, 74, 0.5);
            --glow-danger: 0 0 20px rgba(230, 69, 69, 0.4);
        }

        /* Smooth theme transitions */
        body, .modal-content, .hud-item, .faction-card, #cargo-summary,
        #wind-indicator, #heat-indicator, #bounty-indicator, #ship-condition,
        #compass, .compass-ring, #destination-info, #speed-indicator,
        #island-indicator, .good-item, .contract-card, .upgrade-card {
            transition: background var(--theme-transition),
                        color var(--theme-transition),
                        border-color var(--theme-transition),
                        box-shadow var(--theme-transition);
        }
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; overflow: hidden; touch-action: manipulation; -webkit-tap-highlight-color: transparent; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
        body { font-family: var(--font-body); font-size: 16px; line-height: 1.5; color: var(--ink); background: var(--sea-dark); }
        .hidden { display: none !important; }
    #loading-screen { position: fixed; inset: 0; background: linear-gradient(135deg, var(--sea-dark) 0%, #0d1f29 100%); display: flex; align-items: center; justify-content: center; z-index: 1000; }
    .loading-content { text-align: center; color: var(--parchment); }
    .loading-content h1 { font-family: var(--font-display); font-size: 2rem; font-weight: 700; letter-spacing: 0.1em; margin-bottom: var(--space-lg); text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); }
    .loading-ship { font-size: 3rem; animation: bob 2s ease-in-out infinite; margin-bottom: var(--space-lg); }
    @keyframes bob { 0%, 100% { transform: translateY(0) rotate(-5deg); } 50% { transform: translateY(-10px) rotate(5deg); } }
    .loading-bar { width: 200px; height: 6px; background: rgba(255, 255, 255, 0.2); border-radius: 3px; margin: 0 auto; overflow: hidden; }
    .loading-progress { height: 100%; width: 0%; background: linear-gradient(90deg, var(--gold), var(--gold-dark)); border-radius: 3px; transition: width 0.3s var(--ease-out); }

    .screen { position: fixed; inset: 0; background: linear-gradient(180deg, var(--sea-dark) 0%, #0d1f29 100%); overflow-y: auto; z-index: 900; }
    .screen-content { min-height: 100%; padding: var(--space-xl) var(--space-md); display: flex; flex-direction: column; align-items: center; }
    .screen-content h1 { font-family: var(--font-display); font-size: 1.5rem; color: var(--parchment); text-align: center; margin-bottom: var(--space-sm); }
    .subtitle { color: var(--parchment-dark); text-align: center; max-width: 300px; margin-bottom: var(--space-xl); font-style: italic; }
    .faction-cards { display: flex; flex-direction: column; gap: var(--space-md); width: 100%; max-width: 400px; }
    .faction-card { background: var(--card-bg); border: 3px solid transparent; border-radius: 12px; padding: var(--space-md); text-align: center; cursor: pointer; transition: all 0.3s var(--ease-out); }
    .faction-card:hover, .faction-card:active { transform: translateY(-2px); box-shadow: var(--shadow); }
    .faction-card.selected { border-color: var(--gold); box-shadow: 0 0 20px rgba(201, 162, 39, 0.4); }
    .faction-icon { font-size: 2.5rem; margin-bottom: var(--space-xs); }
    .faction-card h2 { font-family: var(--font-display); font-size: 1.1rem; color: var(--ink); margin-bottom: var(--space-xs); }
    .faction-desc { color: var(--ink-light); font-style: italic; margin-bottom: var(--space-sm); font-size: 0.85rem; }
    .faction-perks { list-style: none; text-align: left; font-size: 0.8rem; }
    .faction-perks li { padding: 2px 0; color: var(--ink-light); }
    .difficulty-tag { display: inline-block; font-size: 0.65rem; padding: 2px 6px; border-radius: 4px; margin-top: 4px; }
    .difficulty-easy { background: #1e7d34; color: white; }
    .difficulty-medium { background: var(--gold-dark); color: white; }
    .difficulty-hard { background: var(--blood-red); color: white; }

    .btn-primary, .btn-secondary, .btn-danger { font-family: var(--font-body); font-weight: 600; font-size: 0.95rem; padding: var(--space-md) var(--space-xl); border: none; border-radius: var(--radius-md); cursor: pointer; transition: all var(--duration-fast) var(--ease-out); min-height: var(--touch-min); display: inline-flex; align-items: center; justify-content: center; gap: var(--space-sm); }
    .btn-primary { background: linear-gradient(135deg, var(--gold-light) 0%, var(--gold) 50%, var(--gold-dark) 100%); color: var(--ink); box-shadow: 0 4px 12px rgba(230, 168, 23, 0.3); }
    .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(230, 168, 23, 0.4); }
    .btn-primary:active { transform: translateY(1px); box-shadow: 0 2px 8px rgba(230, 168, 23, 0.3); }
    .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    .btn-secondary { background: var(--parchment); color: var(--ink); border: 2px solid var(--parchment-dark); }
    .btn-secondary:hover { border-color: var(--ink-light); background: var(--parchment-dark); }
    .btn-danger { background: linear-gradient(135deg, #ff6b6b 0%, var(--blood-red) 100%); color: white; box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3); }
    .btn-danger:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(220, 53, 69, 0.4); }
    .btn-small { font-size: 0.8rem; padding: var(--space-sm) var(--space-md); min-height: 36px; }

    #game-container { position: fixed; inset: 0; overflow: hidden; }
    #game-canvas { position: absolute; inset: 0; width: 100%; height: 100%; touch-action: none; }

    #hud-top { position: fixed; top: 0; left: 0; right: 0; display: flex; justify-content: center; gap: 4px; padding: 4px var(--space-sm); background: linear-gradient(180deg, rgba(0, 0, 0, 0.4) 0%, transparent 100%); pointer-events: none; z-index: 10; flex-wrap: wrap; }
    .hud-item { display: flex; align-items: center; gap: 4px; background: var(--hud-bg); padding: 5px 10px; border-radius: var(--radius-full); font-family: var(--font-body); font-size: 0.75rem; font-weight: 500; box-shadow: var(--shadow-light); border: 1px solid var(--parchment-dark); }
    .hud-icon { font-size: 0.9rem; }
    .hud-value { font-weight: 600; color: var(--ink); }

    /* Left HUD Panel - Compact grouped indicators */
    #hud-left { position: fixed; top: 42px; left: 4px; display: flex; flex-direction: column; gap: 3px; z-index: 10; max-width: 120px; }
    .hud-group { background: var(--hud-bg); border-radius: var(--radius-sm); padding: 5px 8px; box-shadow: var(--shadow-light); border: 1px solid var(--parchment-dark); }

    #faction-badge { display: flex; align-items: center; gap: 4px; font-family: var(--font-body); font-size: 0.7rem; font-weight: 500; }
    #faction-badge.english { border-left: 2px solid var(--english); padding-left: 6px; margin-left: -8px; }
    #faction-badge.eitc { border-left: 2px solid var(--eitc); padding-left: 6px; margin-left: -8px; }
    #faction-badge.pirates { border-left: 2px solid var(--pirates); padding-left: 6px; margin-left: -8px; }

    #cargo-summary { background: var(--hud-bg); padding: 5px 8px; border-radius: var(--radius-sm); font-size: 0.7rem; box-shadow: var(--shadow-light); border: 1px solid var(--parchment-dark); }
    .cargo-header { display: flex; justify-content: space-between; font-family: var(--font-body); font-size: 0.65rem; font-weight: 500; margin-bottom: 2px; color: var(--ink-light); }
    #cargo-preview { display: flex; flex-wrap: wrap; gap: 2px; }
    .cargo-dot { width: 6px; height: 6px; border-radius: 2px; background: var(--gold); transition: transform var(--duration-fast) ease; }
    .cargo-dot:hover { transform: scale(1.3); }
    .cargo-dot.high-margin { animation: glow-dot 1.5s ease-in-out infinite; background: var(--eitc); }
    .cargo-dot.contraband { background: var(--blood-red); }
    @keyframes glow-dot { 0%, 100% { box-shadow: 0 0 2px var(--eitc); } 50% { box-shadow: 0 0 5px var(--eitc); } }

    #wind-indicator { background: var(--hud-bg); padding: 4px 8px; border-radius: var(--radius-sm); font-size: 0.7rem; font-weight: 500; box-shadow: var(--shadow-light); border: 1px solid var(--parchment-dark); display: flex; align-items: center; gap: 4px; }
    #wind-arrow { display: inline-block; transition: transform 0.3s var(--ease-smooth); font-size: 0.85rem; }

    /* Status indicators - minimal style */
    .status-indicator { background: var(--hud-bg); padding: 4px 8px; border-radius: var(--radius-sm); font-size: 0.7rem; font-weight: 500; box-shadow: var(--shadow-light); border: 1px solid var(--parchment-dark); display: flex; align-items: center; gap: 4px; }
    .status-bar { width: 40px; height: 4px; background: rgba(255,255,255,0.15); border-radius: var(--radius-full); overflow: hidden; }
    .status-fill { height: 100%; border-radius: var(--radius-full); transition: width var(--duration-normal) var(--ease-smooth); }

    /* Heat indicator */
    #heat-indicator { background: var(--hud-bg); padding: 4px 8px; border-radius: var(--radius-sm); font-size: 0.7rem; font-weight: 500; box-shadow: var(--shadow-light); border: 1px solid var(--parchment-dark); display: flex; align-items: center; gap: 4px; }
    #heat-indicator .heat-bar { width: 40px; height: 4px; background: rgba(255,255,255,0.15); border-radius: var(--radius-full); overflow: hidden; }
    #heat-indicator .heat-fill { height: 100%; background: var(--blood-red); border-radius: var(--radius-full); transition: width var(--duration-normal) var(--ease-smooth); }
    #heat-indicator.low .heat-fill { background: var(--eitc); }
    #heat-indicator.med .heat-fill { background: var(--gold); }
    #heat-indicator.high .heat-fill { background: var(--blood-red); }

    /* Bounty indicator */
    #bounty-indicator { background: var(--hud-bg); padding: 4px 8px; border-radius: var(--radius-sm); font-size: 0.7rem; font-weight: 500; box-shadow: var(--shadow-light); border: 1px solid var(--parchment-dark); display: flex; align-items: center; gap: 4px; }
    #bounty-indicator.clean { opacity: 0.6; }
    #bounty-indicator.wanted { border-left: 2px solid var(--gold); }
    #bounty-indicator.hunted { border-left: 2px solid #ff8c42; animation: bounty-pulse 1.5s ease-in-out infinite; }
    #bounty-indicator.infamous { border-left: 2px solid var(--blood-red); animation: bounty-pulse 0.8s ease-in-out infinite; box-shadow: var(--glow-danger); }
    @keyframes bounty-pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.75; } }

    /* Notoriety indicator - hidden by default, only shows when relevant */
    #notoriety-indicator { background: var(--hud-bg); padding: 4px 8px; border-radius: var(--radius-sm); font-size: 0.7rem; font-weight: 500; box-shadow: var(--shadow-light); border: 1px solid var(--parchment-dark); display: none; align-items: center; gap: 4px; }
    #notoriety-indicator.visible { display: flex; }
    #notoriety-indicator.low { border-left: 2px solid var(--eitc); }
    #notoriety-indicator.rising { border-left: 2px solid var(--gold); }
    #notoriety-indicator.high { border-left: 2px solid #ff8c42; }
    #notoriety-indicator.notorious { border-left: 2px solid var(--blood-red); animation: notoriety-pulse 2s ease-in-out infinite; }
    @keyframes notoriety-pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.85; } }
    #notoriety-indicator .notoriety-bar { width: 40px; height: 4px; background: rgba(255,255,255,0.15); border-radius: var(--radius-full); overflow: hidden; }
    #notoriety-indicator .notoriety-fill { height: 100%; background: var(--eitc); border-radius: var(--radius-full); transition: width 0.3s, background 0.3s; }
    #notoriety-indicator.rising .notoriety-fill { background: var(--gold); }
    #notoriety-indicator.high .notoriety-fill { background: #ff8c42; }
    #notoriety-indicator.notorious .notoriety-fill { background: var(--blood-red); }

    /* Contract tracker chip */
    #contract-tracker { background: var(--hud-bg); padding: 4px 8px; border-radius: var(--radius-sm); font-size: 0.7rem; box-shadow: var(--shadow-light); border: 1px solid var(--parchment-dark); display: flex; align-items: center; gap: 4px; cursor: pointer; pointer-events: auto; max-width: 115px; border-left: 2px solid var(--gold); transition: transform var(--duration-fast) ease, box-shadow var(--duration-fast) ease; }
    #contract-tracker:hover { transform: translateX(2px); box-shadow: var(--shadow-glow); }
    #contract-tracker.hidden { display: none; }
    #contract-tracker .contract-title { font-family: var(--font-body); font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 70px; }
    #contract-tracker .contract-meta { color: var(--ink-light); font-size: 0.6rem; }

    /* Season/World indicator */
    #world-indicator { background: var(--hud-bg); padding: 4px 8px; border-radius: var(--radius-sm); font-size: 0.65rem; font-weight: 500; box-shadow: var(--shadow-light); border: 1px solid var(--parchment-dark); display: flex; align-items: center; gap: 4px; }
    #world-indicator.storm-season { border-left: 2px solid var(--sea-light); }
    #world-indicator.crackdown { border-left: 2px solid var(--blood-red); }

    /* Ship condition HUD - compact */
    #ship-condition { background: var(--hud-bg); padding: 6px 8px; border-radius: var(--radius-sm); font-size: 0.65rem; box-shadow: var(--shadow-light); border: 1px solid var(--parchment-dark); }
    #ship-condition .ship-class-name { font-family: var(--font-body); font-weight: 600; font-size: 0.7rem; margin-bottom: 4px; display: flex; align-items: center; gap: 4px; }
    #ship-condition .condition-row { display: flex; align-items: center; gap: 4px; margin: 2px 0; }
    #ship-condition .condition-icon { width: 14px; text-align: center; font-size: 0.7rem; }
    #ship-condition .condition-bar { flex: 1; height: 4px; background: rgba(255,255,255,0.15); border-radius: var(--radius-full); overflow: hidden; min-width: 45px; }
    #ship-condition .condition-fill { height: 100%; border-radius: var(--radius-full); transition: width var(--duration-normal) var(--ease-smooth), background var(--duration-normal); }
    #ship-condition .condition-fill.hull { background: linear-gradient(90deg, #8B4513, #a0522d); }
    #ship-condition .condition-fill.rigging { background: linear-gradient(90deg, #c4a35a, #d4b36a); }
    #ship-condition .condition-fill.morale { background: linear-gradient(90deg, #4682B4, #5a9fd4); }
    #ship-condition .condition-fill.critical { background: linear-gradient(90deg, var(--blood-red), #ff6b6b) !important; animation: pulse-critical 0.8s infinite; }
    #ship-condition .condition-value { width: 22px; text-align: right; font-family: var(--font-body); font-weight: 600; font-size: 0.65rem; }
    #ship-condition.critical { border: 2px solid var(--blood-red); box-shadow: var(--glow-danger); }
    @keyframes pulse-critical { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }

    #compass { position: fixed; top: 42px; right: 4px; display: flex; flex-direction: column; align-items: center; gap: 4px; z-index: 10; }
    .compass-ring { width: 55px; height: 55px; border-radius: 50%; background: var(--hud-bg); border: 2px solid var(--parchment-dark); position: relative; box-shadow: var(--shadow-light); }
    .compass-needle { position: absolute; top: 50%; left: 50%; width: 3px; height: 22px; background: linear-gradient(180deg, var(--blood-red) 50%, var(--ink) 50%); transform-origin: center bottom; transform: translate(-50%, -100%); border-radius: 2px; transition: transform 0.2s var(--ease-smooth); }
    .compass-dest-marker { position: absolute; width: 8px; height: 8px; background: var(--gold); border-radius: 50%; top: 4px; left: 50%; transform: translateX(-50%); box-shadow: var(--glow-gold); }
    .compass-n, .compass-e, .compass-s, .compass-w { position: absolute; font-family: var(--font-body); font-size: 0.6rem; font-weight: 700; color: var(--ink-light); }
    .compass-n { top: 2px; left: 50%; transform: translateX(-50%); color: var(--blood-red); }
    .compass-s { bottom: 2px; left: 50%; transform: translateX(-50%); }
    .compass-e { right: 4px; top: 50%; transform: translateY(-50%); }
    .compass-w { left: 4px; top: 50%; transform: translateY(-50%); }
    #destination-info { background: var(--hud-bg); padding: 4px 8px; border-radius: var(--radius-sm); text-align: center; font-size: 0.7rem; box-shadow: var(--shadow-light); border: 1px solid var(--parchment-dark); }
    #dest-name { display: block; font-family: var(--font-body); font-weight: 600; font-size: 0.7rem; }
    #dest-distance { color: var(--ink-light); font-size: 0.6rem; }

    #mobile-controls { position: fixed; bottom: 0; left: 0; right: 0; height: 160px; pointer-events: none; z-index: 20; }
    #joystick-zone { position: absolute; bottom: 15px; left: 15px; width: 100px; height: 100px; pointer-events: auto; }
    #joystick-base { position: absolute; width: 100px; height: 100px; border-radius: 50%; background: radial-gradient(circle, rgba(244,228,193,0.25) 0%, rgba(244,228,193,0.08) 70%, transparent 100%); border: 2px solid rgba(244,228,193,0.4); }
    #joystick-stick { position: absolute; width: 42px; height: 42px; border-radius: 50%; background: radial-gradient(circle at 30% 30%, var(--parchment) 0%, var(--gold-dark) 100%); border: 2px solid var(--wood); box-shadow: 0 3px 6px rgba(0,0,0,0.4); left: 50%; top: 50%; transform: translate(-50%, -50%); }
    #joystick-stick.active { box-shadow: 0 2px 4px rgba(0,0,0,0.4), 0 0 12px rgba(201,162,39,0.5); }

    #action-buttons { position: absolute; bottom: var(--action-stack-bottom); right: 12px; display: flex; flex-direction: column; gap: 8px; pointer-events: auto; }
    .action-btn { width: 52px; height: 52px; border-radius: 50%; border: none; font-size: 1.3rem; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all var(--duration-fast) var(--ease-bounce); box-shadow: var(--shadow-light); }
    .action-btn:hover { transform: scale(1.08); }
    .action-btn:active { transform: scale(0.95); }
    #btn-dock { background: linear-gradient(135deg, var(--sea-light) 0%, var(--sea-medium) 100%); color: white; }
    #btn-dock.available { animation: pulse-dock 1.2s ease-in-out infinite; box-shadow: var(--glow-sea); }
    @keyframes pulse-dock { 0%, 100% { box-shadow: var(--glow-sea); } 50% { box-shadow: 0 0 0 6px rgba(44, 83, 100, 0.3), var(--glow-sea); } }
    #btn-map { background: linear-gradient(135deg, var(--parchment) 0%, var(--parchment-dark) 100%); color: var(--ink); }
    #btn-menu { background: linear-gradient(135deg, var(--gold-light) 0%, var(--gold) 100%); color: var(--ink); }

    #speed-indicator { position: absolute; bottom: 125px; left: 20px; background: var(--hud-bg); padding: 5px 10px; border-radius: var(--radius-full); font-family: var(--font-body); font-size: 0.7rem; font-weight: 500; box-shadow: var(--shadow-light); border: 1px solid var(--parchment-dark); display: flex; align-items: center; gap: 6px; pointer-events: none; }
    #speed-indicator .bar { width: 40px; height: 4px; background: rgba(255,255,255,0.15); border-radius: var(--radius-full); overflow: hidden; }
    #speed-indicator .bar-fill { height: 100%; background: linear-gradient(90deg, var(--gold), var(--gold-light)); border-radius: var(--radius-full); width: 0%; transition: width var(--duration-fast) var(--ease-smooth); }
    .wind-boost { color: var(--eitc); font-size: 0.65rem; font-weight: 600; }
    .wind-penalty { color: var(--blood-red); font-size: 0.65rem; font-weight: 600; }

    /* Island indicator */
    #island-indicator { position: absolute; bottom: calc(var(--action-stack-bottom) + var(--action-stack-h) + 10px); right: 12px; background: var(--hud-bg); padding: 5px 10px; border-radius: var(--radius-sm); font-family: var(--font-body); font-size: 0.7rem; font-weight: 500; box-shadow: var(--shadow-light); border: 1px solid var(--parchment-dark); text-align: right; pointer-events: none; opacity: 0; transition: opacity var(--duration-normal) ease, transform var(--duration-normal) ease; transform: translateY(10px); }
    #island-indicator.visible { opacity: 1; transform: translateY(0); }

    #event-toast { position: fixed; top: 45px; left: 50%; transform: translateX(-50%); background: var(--parchment); padding: var(--space-sm) var(--space-md); border-radius: var(--radius-sm); display: flex; align-items: center; gap: var(--space-sm); box-shadow: var(--shadow); border: 1px solid var(--parchment-dark); z-index: 20; animation: toastSlide var(--duration-slow) var(--ease-bounce); max-width: calc(100% - 30px); }
    @keyframes toastSlide { from { transform: translateX(-50%) translateY(-30px); opacity: 0; } to { transform: translateX(-50%) translateY(0); opacity: 1; } }
    .event-icon { font-size: 1.2rem; }
    .event-text { display: flex; flex-direction: column; }
    #event-title { font-family: var(--font-display); font-size: 0.8rem; font-weight: 600; }
    #event-desc { font-size: 0.75rem; color: var(--ink-light); }

    .modal { position: fixed; inset: 0; background: var(--modal-bg); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); display: flex; align-items: center; justify-content: center; padding: var(--space-md); z-index: 100; animation: modalFadeIn var(--duration-normal) var(--ease-out); }
    @keyframes modalFadeIn { from { opacity: 0; } to { opacity: 1; } }
    .modal-content { background: var(--parchment); border-radius: var(--radius-lg); width: 100%; max-width: 420px; max-height: 85vh; overflow-y: auto; position: relative; box-shadow: var(--shadow); border: 1px solid var(--parchment-dark); animation: modalSlideUp var(--duration-slow) var(--ease-bounce); }
    @keyframes modalSlideUp { from { opacity: 0; transform: translateY(20px) scale(0.98); } to { opacity: 1; transform: translateY(0) scale(1); } }

    .modal-header { padding: var(--space-md) var(--space-lg); border-bottom: 1px solid var(--parchment-dark); position: relative; }
    .modal-header h2 { font-family: var(--font-display); font-size: 1.2rem; margin-bottom: 6px; padding-right: 36px; }
    .island-info { display: flex; gap: 6px; flex-wrap: wrap; }
    .faction-tag { font-size: 0.75rem; font-weight: 500; padding: 4px 10px; border-radius: var(--radius-full); background: var(--ink-light); color: white; }
    .faction-tag.english { background: var(--english); }
    .faction-tag.eitc { background: var(--eitc); }
    .faction-tag.pirates { background: var(--pirates); }
    .faction-tag.neutral { background: var(--neutral); }
    .tariff-tag { font-size: 0.75rem; font-weight: 500; padding: 4px 10px; border-radius: var(--radius-full); background: var(--gold-dark); color: white; }
    .port-state-tag { font-size: 0.75rem; font-weight: 500; padding: 4px 10px; border-radius: var(--radius-full); background: var(--sea-medium); color: white; }
    .port-state-tag.prosperous { background: var(--eitc); }
    .port-state-tag.struggling { background: var(--gold-dark); }
    .port-state-tag.blockaded { background: var(--blood-red); }
    .port-state-tag.lawless { background: var(--pirates); }
    .port-state-tag.starving { background: #8b2500; }
    .port-state-tag.flooded { background: var(--sea-dark); }
    .modal-close { position: absolute; top: var(--space-md); right: var(--space-md); width: 36px; height: 36px; border: none; background: var(--parchment-dark); border-radius: var(--radius-sm); font-size: 1.2rem; cursor: pointer; color: var(--ink-light); transition: all var(--duration-fast) ease; display: flex; align-items: center; justify-content: center; }
    .modal-close:hover { background: var(--ink-light); color: var(--parchment); }

    .trade-tabs { display: flex; border-bottom: 1px solid var(--parchment-dark); padding: 0 var(--space-sm); gap: 4px; }
    .trade-tab { flex: 1; padding: var(--space-sm) var(--space-xs); background: transparent; border: none; font-family: var(--font-body); font-size: 0.85rem; font-weight: 500; cursor: pointer; color: var(--ink-light); position: relative; transition: color var(--duration-fast) ease; border-radius: var(--radius-sm) var(--radius-sm) 0 0; }
    .trade-tab:hover { color: var(--ink); background: rgba(0,0,0,0.03); }
    .trade-tab.active { color: var(--ink); }
    .trade-tab.active::after { content: ''; position: absolute; bottom: -1px; left: 0; right: 0; height: 3px; background: var(--gold); border-radius: 2px 2px 0 0; }
    .trade-tab .tab-badge { display: inline-block; background: var(--blood-red); color: white; font-size: 0.65rem; font-weight: 600; padding: 2px 6px; border-radius: var(--radius-full); margin-left: 4px; vertical-align: middle; }

    .trade-panel { padding: var(--space-md); max-height: 45vh; overflow-y: auto; }
    .goods-list { display: flex; flex-direction: column; gap: var(--space-sm); }
    .good-item { display: grid; grid-template-columns: 1fr auto; grid-template-rows: auto auto; gap: 4px var(--space-md); padding: var(--space-md); background: var(--card-bg); border-radius: var(--radius-md); border: 1px solid var(--parchment-dark); transition: transform var(--duration-fast) ease, box-shadow var(--duration-fast) ease; }
    .good-item:hover { transform: translateY(-1px); box-shadow: var(--shadow-light); }
    .good-item.blocked { opacity: 0.5; }
    .good-info { display: flex; align-items: center; gap: var(--space-sm); }
    .good-icon { font-size: 1.4rem; }
    .good-name { font-family: var(--font-body); font-weight: 600; font-size: 0.95rem; }
    .good-price { font-weight: 700; color: var(--gold-dark); font-size: 0.95rem; }
    .price-trend { font-size: 0.85rem; margin-left: 4px; font-weight: 600; }
    .price-trend.up { color: var(--blood-red); }
    .price-trend.down { color: var(--eitc); }
    .good-details { grid-column: 1; font-size: 0.8rem; color: var(--ink-light); }
    .good-actions { grid-column: 2; grid-row: 1 / 3; display: flex; align-items: center; gap: 6px; }
    .qty-btn { width: 40px; height: 40px; border: none; border-radius: var(--radius-sm); background: var(--parchment-dark); font-size: 1.3rem; font-weight: 600; cursor: pointer; transition: all var(--duration-fast) ease; display: flex; align-items: center; justify-content: center; }
    .qty-btn:hover { transform: scale(1.05); }
    .qty-btn:active { transform: scale(0.95); }
    .qty-btn:disabled { opacity: 0.3; cursor: not-allowed; transform: none; }
    .qty-btn.sell { background: linear-gradient(180deg, #ffe5e5 0%, #ffcccc 100%); color: var(--blood-red); }
    .qty-btn.buy { background: linear-gradient(180deg, #e5ffe5 0%, #ccffcc 100%); color: var(--eitc); }
    .block-reason { color: var(--blood-red); font-size: 0.75rem; font-weight: 500; }

    .panel-actions { display: flex; gap: var(--space-xs); margin-bottom: var(--space-sm); }
    .panel-actions button { flex: 1; }

    .trade-footer { padding: var(--space-sm) var(--space-md); border-top: 2px solid var(--parchment-dark); display: flex; justify-content: space-between; align-items: center; }
    .player-stats { display: flex; gap: var(--space-md); font-size: 0.8rem; }

    /* Contract cards */
    .contract-card { background: rgba(255,255,255,0.6); border: 2px solid var(--parchment-dark); border-radius: 8px; padding: var(--space-sm); margin-bottom: var(--space-sm); }
    .contract-card.active { border-color: var(--gold); background: rgba(201,162,39,0.1); }
    .contract-card.tracked { border-color: var(--sea-medium); box-shadow: 0 0 8px rgba(74,138,154,0.4); }
    .contract-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: var(--space-xs); }
    .contract-type { font-size: 0.7rem; padding: 2px 6px; border-radius: 4px; background: var(--ink-light); color: var(--parchment); }
    .contract-type.delivery { background: var(--sea-medium); }
    .contract-type.smuggling { background: var(--blood-red); }
    .contract-type.courier { background: var(--gold-dark); }
    .contract-type.supply { background: #1e7d34; }
    .contract-type.faction { background: var(--pirates); }
    .contract-title { font-family: var(--font-display); font-size: 0.85rem; flex: 1; margin-right: var(--space-xs); }
    .contract-deadline { font-size: 0.7rem; color: var(--ink-light); }
    .contract-deadline.urgent { color: var(--blood-red); font-weight: 600; }
    .contract-details { font-size: 0.75rem; color: var(--ink-light); margin-bottom: var(--space-xs); }
    .contract-rewards { display: flex; gap: var(--space-sm); font-size: 0.75rem; margin-bottom: var(--space-xs); }
    .contract-reward { display: flex; align-items: center; gap: 2px; }
    .contract-reward.gold { color: var(--gold-dark); }
    .contract-reward.rep { color: var(--sea-medium); }
    .contract-cost { font-size: 0.7rem; color: var(--blood-red); margin-bottom: var(--space-xs); font-style: italic; }
    .contract-actions { display: flex; gap: var(--space-xs); }
    .contract-actions button { flex: 1; }
    .contract-empty { text-align: center; color: var(--ink-light); padding: var(--space-lg); font-style: italic; }

    /* Questline Cards - Living Sea Update */
    .questline-card { background: linear-gradient(135deg, rgba(74, 108, 124, 0.15) 0%, rgba(44, 78, 94, 0.1) 100%); border: 2px solid var(--sea-medium); border-radius: 8px; padding: var(--space-sm); margin-bottom: var(--space-sm); }
    .questline-card.active { border-color: var(--gold); background: linear-gradient(135deg, rgba(201, 162, 39, 0.2) 0%, rgba(201, 162, 39, 0.1) 100%); }
    .questline-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-xs); }
    .questline-title { font-family: var(--font-display); font-size: 0.9rem; display: flex; align-items: center; gap: var(--space-xs); }
    .questline-deadline { font-size: 0.7rem; color: var(--blood-red); font-weight: 600; }
    .questline-tier { font-size: 0.6rem; background: var(--sea-medium); color: white; padding: 2px 6px; border-radius: 4px; margin-left: 4px; }
    .questline-desc { font-size: 0.75rem; color: var(--ink-light); margin-bottom: var(--space-sm); }
    .questline-steps { margin-bottom: var(--space-sm); }
    .questline-step { display: flex; align-items: flex-start; gap: var(--space-xs); font-size: 0.75rem; padding: var(--space-xs) 0; }
    .questline-step.completed { color: #1e7d34; text-decoration: line-through; opacity: 0.7; }
    .questline-step.current { font-weight: 600; color: var(--sea-dark); }
    .questline-step.pending { color: var(--ink-light); }
    .step-icon { width: 16px; text-align: center; }
    .questline-rewards { display: flex; flex-wrap: wrap; gap: var(--space-sm); font-size: 0.7rem; margin-bottom: var(--space-sm); background: rgba(201, 162, 39, 0.1); padding: var(--space-xs); border-radius: 4px; }
    .questline-actions { display: flex; gap: var(--space-xs); }
    .questline-empty { text-align: center; color: var(--ink-light); padding: var(--space-md); font-style: italic; }

    .logbook-section { margin-bottom: var(--space-md); }
    .logbook-section h4 { font-family: var(--font-display); font-size: 0.85rem; margin-bottom: var(--space-xs); color: var(--ink-light); }
    .island-select { width: 100%; padding: var(--space-sm); border: 2px solid var(--parchment-dark); border-radius: 6px; font-family: var(--font-body); background: white; margin-bottom: var(--space-sm); }
    .logbook-item { display: flex; justify-content: space-between; align-items: center; padding: var(--space-xs) var(--space-sm); background: rgba(255,255,255,0.5); border-radius: 4px; margin-bottom: 2px; font-size: 0.8rem; }
    .confidence-tag { font-size: 0.6rem; padding: 1px 4px; border-radius: 3px; margin-left: 4px; }
    .confidence-high { background: #1e7d34; color: white; }
    .confidence-med { background: var(--gold-dark); color: white; }
    .confidence-low { background: var(--ink-light); color: white; }

    .spotlight-card { background: linear-gradient(135deg, rgba(201,162,39,0.2) 0%, rgba(201,162,39,0.1) 100%); border: 2px solid var(--gold); border-radius: 8px; padding: var(--space-sm); margin-bottom: var(--space-sm); cursor: pointer; }
    .spotlight-card:hover { transform: translateY(-2px); box-shadow: var(--shadow-light); }
    .spotlight-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-xs); }
    .spotlight-good { font-family: var(--font-display); font-size: 0.9rem; }
    .spotlight-profit { color: #1e7d34; font-weight: 600; }
    .spotlight-route { font-size: 0.75rem; color: var(--ink-light); }
    .spotlight-empty { text-align: center; color: var(--ink-light); padding: var(--space-md); font-style: italic; }

    .upgrade-card { background: rgba(255,255,255,0.5); border: 2px solid var(--parchment-dark); border-radius: 8px; padding: var(--space-sm); margin-bottom: var(--space-sm); }
    .upgrade-card.owned { border-color: var(--gold); background: rgba(201,162,39,0.1); }
    .upgrade-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-xs); }
    .upgrade-name { font-family: var(--font-display); font-size: 0.9rem; }
    .upgrade-cost { color: var(--gold-dark); font-weight: 600; }
    .upgrade-desc { font-size: 0.75rem; color: var(--ink-light); margin-bottom: var(--space-xs); }
    .upgrade-stats { font-size: 0.65rem; display: flex; flex-wrap: wrap; gap: var(--space-xs); margin-bottom: var(--space-xs); }
    .upgrade-stat { padding: 2px 6px; border-radius: 4px; }
    .upgrade-stat.positive { background: rgba(30,125,52,0.2); color: #1e7d34; }
    .upgrade-stat.negative { background: rgba(139,37,0,0.2); color: var(--blood-red); }

    /* Ship Repairs - Living Sea Update */
    .shipyard-section { margin-bottom: var(--space-md); }
    .shipyard-section h4 { font-family: var(--font-display); font-size: 0.85rem; margin-bottom: var(--space-sm); color: var(--ink); border-bottom: 1px solid var(--parchment-dark); padding-bottom: var(--space-xs); }
    .repair-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: var(--space-sm); }
    .repair-card { background: rgba(255,255,255,0.5); border: 2px solid var(--parchment-dark); border-radius: 8px; padding: var(--space-sm); text-align: center; }
    .repair-card.full { border-color: #1e7d34; background: rgba(30,125,52,0.1); }
    .repair-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-xs); font-size: 0.8rem; }
    .repair-bar { height: 8px; background: var(--parchment-dark); border-radius: 4px; overflow: hidden; margin-bottom: var(--space-xs); }
    .repair-fill { height: 100%; transition: width 0.3s; }
    .repair-fill.hull { background: #8B4513; }
    .repair-fill.rigging { background: #D2B48C; }
    .repair-fill.morale { background: #4682B4; }
    .repair-full { font-size: 0.7rem; color: #1e7d34; font-style: italic; }

    /* Pardon Card - Living Sea Update */
    .pardon-card { background: rgba(139, 0, 0, 0.1); border: 2px solid var(--blood-red); border-radius: 8px; padding: var(--space-sm); text-align: center; }
    .pardon-status { display: flex; align-items: center; justify-content: center; gap: var(--space-sm); margin-bottom: var(--space-sm); font-size: 1rem; }
    .bounty-icon { font-size: 1.2rem; }
    .bounty-level { font-weight: bold; font-family: var(--font-display); }
    .bounty-amount { font-size: 0.8rem; color: var(--ink-light); }
    .pardon-desc { font-size: 0.75rem; color: var(--ink-light); margin-bottom: var(--space-sm); }

    /* Officer Cards - Living Sea Update */
    .officer-card { background: rgba(255,255,255,0.6); border: 2px solid var(--parchment-dark); border-radius: 8px; padding: var(--space-sm); margin-bottom: var(--space-sm); }
    .officer-card.hired { border-color: var(--gold); background: rgba(201,162,39,0.15); }
    .officer-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-xs); }
    .officer-name { font-family: var(--font-display); font-size: 0.9rem; display: flex; align-items: center; gap: var(--space-xs); }
    .officer-type { font-size: 0.7rem; color: var(--ink-light); background: var(--parchment-dark); padding: 2px 6px; border-radius: 4px; }
    .officer-wage { color: var(--gold-dark); font-weight: 600; font-size: 0.8rem; }
    .officer-traits { display: flex; flex-wrap: wrap; gap: var(--space-xs); margin: var(--space-xs) 0; }
    .officer-trait { font-size: 0.65rem; padding: 2px 6px; border-radius: 4px; }
    .officer-trait.positive { background: rgba(30,125,52,0.2); color: #1e7d34; }
    .officer-trait.negative { background: rgba(139,37,0,0.2); color: var(--blood-red); }
    .officer-actions { display: flex; gap: var(--space-xs); margin-top: var(--space-xs); }
    .officers-empty { text-align: center; color: var(--ink-light); padding: var(--space-md); font-style: italic; }
    .rumor-card { display: flex; align-items: flex-start; gap: var(--space-xs); background: rgba(255,255,255,0.5); border-radius: 6px; padding: var(--space-xs) var(--space-sm); margin-bottom: var(--space-xs); font-size: 0.75rem; }
    .rumor-card.rumor-true { border-left: 3px solid #1e7d34; }
    .rumor-card.rumor-false { border-left: 3px solid #8b6914; }
    .rumor-icon { font-size: 1rem; }
    .rumor-text { flex: 1; font-style: italic; color: var(--ink); }
    .rumor-age { font-size: 0.65rem; color: var(--ink-light); background: var(--parchment-dark); padding: 2px 6px; border-radius: 4px; }

    /* Ship Cards - Living Sea Update */
    .ship-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: var(--space-sm); margin-bottom: var(--space-md); }
    .ship-card { background: rgba(255,255,255,0.6); border: 2px solid var(--parchment-dark); border-radius: 8px; padding: var(--space-sm); }
    .ship-card.owned { border-color: var(--gold); background: rgba(201,162,39,0.15); }
    .ship-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-xs); }
    .ship-name { font-family: var(--font-display); font-size: 0.9rem; }
    .ship-cost { color: var(--gold-dark); font-weight: 600; font-size: 0.8rem; }
    .ship-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 2px; font-size: 0.7rem; margin-bottom: var(--space-xs); }
    .ship-stat { display: flex; justify-content: space-between; padding: 2px 4px; background: rgba(0,0,0,0.05); border-radius: 3px; }
    .ship-stat span:first-child { color: var(--ink-light); }
    .ship-stat span:last-child { font-weight: 600; }
    .ship-desc { font-size: 0.65rem; color: var(--ink-light); margin: var(--space-xs) 0; font-style: italic; }

    .menu-content { padding: var(--space-md); }
    .menu-content h2 { font-family: var(--font-display); text-align: center; margin-bottom: var(--space-md); }
    .menu-section { margin-bottom: var(--space-md); }
    .menu-section h3 { font-family: var(--font-display); font-size: 0.9rem; margin-bottom: var(--space-sm); color: var(--ink-light); }
    .reputation-bars { display: flex; flex-direction: column; gap: var(--space-sm); }
    .rep-item { display: grid; grid-template-columns: 1fr 1fr auto; align-items: center; gap: var(--space-xs); font-size: 0.75rem; }
    .rep-bar { height: 6px; background: var(--parchment-dark); border-radius: 3px; overflow: hidden; }
    .rep-fill { height: 100%; background: var(--gold); width: 50%; }
    .rep-fill.hostile { background: var(--blood-red); }
    .rep-fill.friendly { background: #1e7d34; }
    .ship-stats { background: rgba(255, 255, 255, 0.5); border-radius: 6px; padding: var(--space-sm); }
    .stat-row { display: flex; justify-content: space-between; padding: 3px 0; border-bottom: 1px solid var(--parchment-dark); font-size: 0.8rem; }
    .stat-row:last-child { border-bottom: none; }
    .risk-low { color: #1e7d34; }
    .risk-med { color: var(--gold-dark); }
    .risk-high { color: var(--blood-red); }
    .menu-buttons { display: flex; flex-direction: column; gap: var(--space-xs); margin-bottom: var(--space-md); }

    /* Titles section */
    .title-item { display: flex; justify-content: space-between; align-items: center; padding: var(--space-xs) var(--space-sm); background: rgba(255,255,255,0.5); border-radius: 4px; margin-bottom: 2px; font-size: 0.8rem; }
    .title-name { font-family: var(--font-display); }
    .title-tier { font-size: 0.65rem; padding: 2px 6px; border-radius: 4px; background: var(--gold); color: var(--ink); }
    .title-tier.tier-0 { background: var(--ink-light); color: var(--parchment); }
    .title-tier.tier-1 { background: #cd7f32; color: white; }
    .title-tier.tier-2 { background: #c0c0c0; color: var(--ink); }
    .title-tier.tier-3 { background: var(--gold); color: var(--ink); }
    .title-tier.tier-4 { background: #b9f2ff; color: var(--ink); }
    .title-tier.tier-5 { background: var(--blood-red); color: white; }
    .title-progress { font-size: 0.65rem; color: var(--ink-light); }

    .pirate-content, .encounter-content, .warning-content { padding: var(--space-lg); text-align: center; }
    .pirate-icon, .encounter-icon, .warning-icon { font-size: 3rem; margin-bottom: var(--space-sm); }
    .pirate-icon { animation: shake 0.5s ease-in-out infinite; }
    @keyframes shake { 0%, 100% { transform: rotate(-5deg); } 50% { transform: rotate(5deg); } }
    .pirate-content h2, .encounter-content h2, .warning-content h2 { font-family: var(--font-display); margin-bottom: var(--space-sm); }
    .pirate-content > p, .encounter-content > p, .warning-content > p { margin-bottom: var(--space-lg); color: var(--ink-light); }
    .pirate-options, .encounter-options { display: flex; flex-direction: column; gap: var(--space-sm); }
    .encounter-reward { background: rgba(30,125,52,0.1); border: 1px solid #1e7d34; border-radius: 6px; padding: var(--space-sm); margin-bottom: var(--space-md); }
    .encounter-penalty { background: rgba(139,37,0,0.1); border: 1px solid var(--blood-red); border-radius: 6px; padding: var(--space-sm); margin-bottom: var(--space-md); }

    /* Chase System - Living Sea Update */
    .chase-content { padding: var(--space-lg); text-align: center; }
    .chase-header { display: flex; align-items: center; justify-content: center; gap: var(--space-sm); margin-bottom: var(--space-sm); }
    .chase-icon { font-size: 2.5rem; animation: chase-bounce 0.8s ease-in-out infinite; }
    @keyframes chase-bounce { 0%, 100% { transform: translateX(-5px); } 50% { transform: translateX(5px); } }
    .chase-content h2 { font-family: var(--font-display); margin: 0; }
    .chase-desc { color: var(--ink-light); margin-bottom: var(--space-md); }
    .chase-progress { margin-bottom: var(--space-md); }
    .chase-bar { position: relative; height: 40px; background: linear-gradient(90deg, rgba(30,125,52,0.3), rgba(139,37,0,0.3)); border-radius: 20px; border: 2px solid var(--parchment-dark); overflow: visible; }
    .chase-player { position: absolute; left: 20%; top: 50%; transform: translate(-50%, -50%); font-size: 1.5rem; transition: left 0.3s ease-out; z-index: 2; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3)); }
    .chase-pirate { position: absolute; right: 10%; top: 50%; transform: translateY(-50%); font-size: 1.5rem; animation: chase-pirate-approach 1s ease-in-out infinite; z-index: 1; }
    @keyframes chase-pirate-approach { 0%, 100% { transform: translateY(-50%) translateX(0); } 50% { transform: translateY(-50%) translateX(-8px); } }
    .chase-labels { display: flex; justify-content: space-between; font-size: 0.7rem; color: var(--ink-light); margin-top: var(--space-xs); }
    .chase-stats { display: flex; justify-content: center; gap: var(--space-lg); margin-bottom: var(--space-md); }
    .chase-stat { font-size: 0.8rem; }
    .chase-stat span:first-child { color: var(--ink-light); margin-right: var(--space-xs); }
    .chase-stat span:last-child { font-weight: 600; font-family: var(--font-display); }
    .chase-actions { display: flex; flex-direction: column; gap: var(--space-sm); }
    .chase-action { padding: var(--space-sm) var(--space-md); font-size: 0.85rem; }
    .chase-action:disabled { opacity: 0.5; cursor: not-allowed; }
    .chase-result { margin-top: var(--space-md); padding: var(--space-md); border-radius: 8px; font-family: var(--font-display); }
    .chase-result.escaped { background: rgba(30,125,52,0.2); border: 2px solid #1e7d34; color: #1e7d34; }
    .chase-result.caught { background: rgba(139,37,0,0.2); border: 2px solid var(--blood-red); color: var(--blood-red); }

    .map-content { padding: var(--space-md); }
    .map-content h2 { font-family: var(--font-display); text-align: center; margin-bottom: var(--space-md); }
    #map-container { width: 100%; height: 250px; background: var(--sea-dark); border-radius: 8px; position: relative; overflow: hidden; }
    .map-island { position: absolute; width: 24px; height: 24px; border-radius: 50%; border: 2px solid var(--parchment); transform: translate(-50%, -50%); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 0.6rem; color: white; font-weight: bold; }
    .map-island:hover { transform: translate(-50%, -50%) scale(1.2); }
    .map-island.selected { box-shadow: 0 0 0 3px var(--gold), 0 0 10px var(--gold); }
    .map-island.english { background: var(--english); }
    .map-island.eitc { background: var(--eitc); }
    .map-island.pirates { background: var(--pirates); }
    .map-island.neutral { background: var(--neutral); }
    .map-player { position: absolute; width: 12px; height: 12px; background: var(--gold); border-radius: 50%; border: 2px solid white; transform: translate(-50%, -50%); box-shadow: 0 0 10px var(--gold); z-index: 5; }
    .map-drift-entity { position: absolute; width: 18px; height: 18px; border-radius: 50%; transform: translate(-50%, -50%); display: flex; align-items: center; justify-content: center; font-size: 0.7rem; z-index: 3; animation: drift-pulse 2s ease-in-out infinite; pointer-events: none; }
    @keyframes drift-pulse { 0%, 100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); } 50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); } }
    .map-course-line { position: absolute; height: 2px; background: var(--gold); transform-origin: left center; opacity: 0.6; z-index: 4; }
    .map-legend { display: flex; justify-content: center; gap: var(--space-md); margin-top: var(--space-sm); font-size: 0.7rem; flex-wrap: wrap; }
    .map-legend span { display: flex; align-items: center; gap: 4px; }
    .legend-dot { width: 10px; height: 10px; border-radius: 50%; }
    .map-buttons { display: flex; gap: var(--space-sm); margin-top: var(--space-md); }
    .map-buttons button { flex: 1; }
    .map-info { text-align: center; margin-top: var(--space-sm); font-size: 0.75rem; color: var(--ink-light); }

    /* Faction Influence Zones - Living Sea Update */
    .map-influence-zone { position: absolute; border-radius: 50%; transform: translate(-50%, -50%); opacity: 0.2; pointer-events: none; z-index: 1; transition: all 0.5s ease; }
    .map-influence-zone.english { background: radial-gradient(circle, var(--english) 0%, transparent 70%); }
    .map-influence-zone.eitc { background: radial-gradient(circle, var(--eitc) 0%, transparent 70%); }
    .map-influence-zone.pirates { background: radial-gradient(circle, var(--pirates) 0%, transparent 70%); }
    .map-influence-zone.contested { background: radial-gradient(circle, #8b4513 0%, transparent 70%); animation: contested-pulse 2s ease-in-out infinite; }
    @keyframes contested-pulse { 0%, 100% { opacity: 0.15; } 50% { opacity: 0.3; } }
    .map-island.blockaded { box-shadow: 0 0 0 4px var(--blood-red), 0 0 12px var(--blood-red); animation: blockade-pulse 1.5s ease-in-out infinite; }
    .map-island.warzone { box-shadow: 0 0 0 4px #ff6600, 0 0 15px #ff6600; animation: warzone-pulse 1s ease-in-out infinite; }
    @keyframes blockade-pulse { 0%, 100% { box-shadow: 0 0 0 4px var(--blood-red), 0 0 8px var(--blood-red); } 50% { box-shadow: 0 0 0 6px var(--blood-red), 0 0 16px var(--blood-red); } }
    @keyframes warzone-pulse { 0%, 100% { box-shadow: 0 0 0 4px #ff6600, 0 0 10px #ff6600; } 50% { box-shadow: 0 0 0 6px #ff8800, 0 0 20px #ff8800; } }
    .map-blockade-line { position: absolute; height: 3px; background: repeating-linear-gradient(90deg, var(--blood-red) 0px, var(--blood-red) 5px, transparent 5px, transparent 10px); transform-origin: left center; opacity: 0.8; z-index: 2; pointer-events: none; }
    .map-legend .legend-contested { background: linear-gradient(90deg, var(--english), var(--pirates)); }
    .map-overlay-toggle { position: absolute; top: 5px; right: 5px; background: var(--card-bg); border: 1px solid var(--parchment-dark); border-radius: 4px; padding: 2px 6px; font-size: 0.6rem; cursor: pointer; z-index: 10; }
    .map-overlay-toggle.active { background: var(--gold); }
    .influence-bar { display: flex; height: 6px; border-radius: 3px; overflow: hidden; margin-top: 2px; }
    .influence-bar .influence-segment { height: 100%; transition: width 0.3s; }
    .influence-bar .english { background: var(--english); }
    .influence-bar .eitc { background: var(--eitc); }
    .influence-bar .pirates { background: var(--pirates); }

    /* Hidden Coves - Living Sea Update */
    .map-cove { position: absolute; width: 20px; height: 20px; border-radius: 4px; border: 2px dashed var(--gold); transform: translate(-50%, -50%); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; background: rgba(201, 162, 39, 0.3); z-index: 4; animation: cove-shimmer 3s ease-in-out infinite; }
    .map-cove:hover { transform: translate(-50%, -50%) scale(1.2); box-shadow: 0 0 10px var(--gold); }
    .map-cove.selected { box-shadow: 0 0 0 3px var(--gold), 0 0 15px var(--gold); }
    @keyframes cove-shimmer { 0%, 100% { opacity: 0.8; } 50% { opacity: 1; border-color: #ffd700; } }
    .cove-modal-content { padding: var(--space-lg); text-align: center; }
    .cove-icon { font-size: 3rem; margin-bottom: var(--space-sm); }
    .cove-modal-content h2 { font-family: var(--font-display); margin-bottom: var(--space-xs); }
    .cove-modal-content .cove-desc { color: var(--ink-light); margin-bottom: var(--space-md); font-style: italic; }
    .cove-services { display: flex; flex-direction: column; gap: var(--space-sm); margin-top: var(--space-md); }
    .cove-service-btn { padding: var(--space-sm) var(--space-md); }
    .chart-fragment-indicator { position: fixed; top: 280px; left: var(--space-sm); background: var(--card-bg); padding: 4px 8px; border-radius: 8px; font-size: 0.65rem; box-shadow: var(--shadow-light); z-index: 10; display: flex; align-items: center; gap: 4px; border-left: 3px solid var(--gold); }
    .chart-fragment-indicator.can-reveal { animation: fragment-glow 1.5s ease-in-out infinite; }
    @keyframes fragment-glow { 0%, 100% { box-shadow: var(--shadow-light); } 50% { box-shadow: 0 0 10px var(--gold); } }

    /* ==================== HELP & SETTINGS ==================== */
    .help-grid { display: grid; gap: var(--space-xs); font-size: 0.75rem; }
    .help-item { display: flex; align-items: flex-start; gap: var(--space-sm); padding: var(--space-xs) 0; border-bottom: 1px solid var(--parchment-dark); }
    .help-item:last-child { border-bottom: none; }
    .help-icon { font-size: 1rem; min-width: 24px; text-align: center; }
    .help-text { flex: 1; }
    .help-text strong { color: var(--ink); }
    .help-text span { color: var(--ink-light); font-size: 0.7rem; display: block; }
    .settings-grid { display: flex; flex-direction: column; gap: var(--space-sm); }
    .setting-row { display: flex; justify-content: space-between; align-items: center; padding: var(--space-xs) 0; }
    .setting-label { font-size: 0.8rem; color: var(--ink); }
    .setting-desc { font-size: 0.65rem; color: var(--ink-light); }
    .toggle-switch { position: relative; width: 44px; height: 24px; background: var(--parchment-dark); border-radius: 12px; cursor: pointer; transition: background 0.2s; }
    .toggle-switch.active { background: var(--gold); }
    .toggle-switch::after { content: ''; position: absolute; top: 2px; left: 2px; width: 20px; height: 20px; background: white; border-radius: 50%; transition: transform 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    .toggle-switch.active::after { transform: translateX(20px); }
    .help-collapse { cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
    .help-collapse::after { content: ''; font-size: 0.7rem; transition: transform 0.2s; }
    .help-collapse.collapsed::after { transform: rotate(-90deg); }
    .help-content { max-height: 300px; overflow: hidden; transition: max-height 0.3s ease; }
    .help-content.collapsed { max-height: 0; }

    /* ==================== ENHANCED ANIMATIONS ==================== */
    /* Theme Toggle Button - positioned top-right but below top HUD */
    #theme-toggle {
        position: fixed; top: 5px; right: 70px;
        width: 38px; height: 38px; border-radius: 50%; border: 2px solid var(--gold);
        background: var(--card-bg); cursor: pointer; z-index: 15;
        display: flex; align-items: center; justify-content: center;
        font-size: 1.1rem; box-shadow: var(--shadow-light);
        transition: all 0.3s var(--ease-elastic);
    }
    #theme-toggle:hover { transform: scale(1.1) rotate(15deg); box-shadow: var(--glow-gold); }
    #theme-toggle:active { transform: scale(0.95); }
    #theme-toggle .sun { display: block; }
    #theme-toggle .moon { display: none; }
    [data-theme="dark"] #theme-toggle .sun { display: none; }
    [data-theme="dark"] #theme-toggle .moon { display: block; }

    /* Enhanced Loading Animation */
    .loading-ship {
        animation: ship-float 3s ease-in-out infinite, ship-rock 2s ease-in-out infinite;
        filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
    }
    @keyframes ship-float {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-15px); }
    }
    @keyframes ship-rock {
        0%, 100% { transform: rotate(-8deg); }
        50% { transform: rotate(8deg); }
    }
    .loading-content h1 {
        animation: title-shimmer 3s ease-in-out infinite;
    }
    @keyframes title-shimmer {
        0%, 100% { text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 20px rgba(201,162,39,0.3); }
        50% { text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 40px rgba(201,162,39,0.6); }
    }
    .loading-progress {
        animation: progress-glow 1.5s ease-in-out infinite;
    }
    @keyframes progress-glow {
        0%, 100% { box-shadow: 0 0 5px rgba(201,162,39,0.3); }
        50% { box-shadow: 0 0 15px rgba(201,162,39,0.6); }
    }

    /* Enhanced Card Interactions */
    .faction-card {
        transition: all 0.4s var(--ease-elastic);
        transform-origin: center center;
    }
    .faction-card:hover {
        transform: translateY(-8px) scale(1.02);
        box-shadow: 0 15px 40px rgba(0,0,0,0.3);
    }
    .faction-card.selected {
        animation: card-selected 0.5s var(--ease-bounce);
    }
    @keyframes card-selected {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }

    /* Enhanced HUD Animations */
    .hud-item {
        animation: hud-slide-in 0.5s var(--ease-out) both;
        transition: all 0.3s var(--ease-smooth);
    }
    .hud-item:hover { transform: scale(1.05); box-shadow: var(--glow-gold); }
    @keyframes hud-slide-in {
        from { opacity: 0; transform: translateY(-20px); }
        to { opacity: 1; transform: translateY(0); }
    }

    /* Gold Value Animation */
    .hud-value { transition: all 0.3s var(--ease-bounce); }
    .hud-value.changed {
        animation: value-pop 0.4s var(--ease-bounce);
        color: var(--gold);
    }
    @keyframes value-pop {
        0% { transform: scale(1); }
        50% { transform: scale(1.3); }
        100% { transform: scale(1); }
    }

    /* Enhanced Button Animations */
    .btn-primary, .btn-secondary, .btn-danger {
        transition: all 0.25s var(--ease-smooth);
        position: relative;
        overflow: hidden;
    }
    .btn-primary::after, .btn-secondary::after, .btn-danger::after {
        content: ''; position: absolute; top: 50%; left: 50%;
        width: 0; height: 0; border-radius: 50%;
        background: rgba(255,255,255,0.3);
        transform: translate(-50%, -50%);
        transition: width 0.4s ease, height 0.4s ease;
    }
    .btn-primary:active::after, .btn-secondary:active::after, .btn-danger:active::after {
        width: 200%; height: 200%;
    }
    .btn-primary:hover { transform: translateY(-2px); box-shadow: var(--glow-gold); }
    .btn-danger:hover { box-shadow: var(--glow-danger); }

    /* Enhanced Action Buttons */
    .action-btn {
        transition: all 0.3s var(--ease-elastic);
        position: relative;
    }
    .action-btn::before {
        content: ''; position: absolute; inset: -4px;
        border-radius: 50%; border: 2px solid transparent;
        transition: all 0.3s ease;
    }
    .action-btn:hover::before { border-color: var(--gold); }
    .action-btn:hover { transform: scale(1.1); }
    #btn-dock.available {
        animation: dock-ready 2s ease-in-out infinite;
    }
    @keyframes dock-ready {
        0%, 100% { box-shadow: 0 4px 8px rgba(0,0,0,0.4); }
        50% { box-shadow: 0 4px 8px rgba(0,0,0,0.4), 0 0 0 12px rgba(74,138,154,0.3), 0 0 25px rgba(74,138,154,0.2); }
    }

    /* Enhanced Compass Animation */
    .compass-needle {
        transition: transform 0.4s var(--ease-elastic);
        filter: drop-shadow(0 2px 3px rgba(0,0,0,0.3));
    }
    .compass-ring {
        animation: compass-subtle 4s ease-in-out infinite;
    }
    @keyframes compass-subtle {
        0%, 100% { box-shadow: var(--shadow-light), inset 0 0 10px rgba(0,0,0,0.1); }
        50% { box-shadow: var(--shadow-light), inset 0 0 15px rgba(201,162,39,0.2); }
    }

    /* Enhanced Joystick */
    #joystick-base {
        transition: all 0.3s ease;
    }
    #joystick-stick {
        transition: transform 0.1s ease-out, box-shadow 0.2s ease;
    }
    #joystick-stick.active {
        box-shadow: 0 2px 4px rgba(0,0,0,0.4), 0 0 20px rgba(201,162,39,0.5);
        animation: stick-active 0.5s var(--ease-elastic);
    }
    @keyframes stick-active {
        0% { transform: translate(-50%, -50%) scale(1); }
        50% { transform: translate(-50%, -50%) scale(1.1); }
        100% { transform: translate(-50%, -50%) scale(1); }
    }

    /* Enhanced Modal Animations */
    .modal {
        animation: modal-fade-in 0.3s var(--ease-out);
    }
    @keyframes modal-fade-in {
        from { opacity: 0; backdrop-filter: blur(0); }
        to { opacity: 1; backdrop-filter: blur(4px); }
    }
    .modal-content {
        animation: modal-slide-up 0.4s var(--ease-elastic);
    }
    @keyframes modal-slide-up {
        from { opacity: 0; transform: translateY(30px) scale(0.95); }
        to { opacity: 1; transform: translateY(0) scale(1); }
    }

    /* Enhanced Toast Notifications */
    #event-toast {
        animation: toast-in 0.4s var(--ease-bounce);
    }
    @keyframes toast-in {
        0% { transform: translateX(-50%) translateY(-40px) scale(0.8); opacity: 0; }
        100% { transform: translateX(-50%) translateY(0) scale(1); opacity: 1; }
    }
    #event-toast.fade-out {
        animation: toast-out 0.3s var(--ease-out) forwards;
    }
    @keyframes toast-out {
        to { transform: translateX(-50%) translateY(-20px); opacity: 0; }
    }

    /* Enhanced Good Items */
    .good-item {
        transition: all 0.25s var(--ease-smooth);
        animation: item-fade-in 0.3s var(--ease-out) both;
    }
    .good-item:hover {
        transform: translateX(4px);
        box-shadow: var(--shadow-light);
        background: rgba(255,255,255,0.7);
    }
    @keyframes item-fade-in {
        from { opacity: 0; transform: translateX(-10px); }
        to { opacity: 1; transform: translateX(0); }
    }

    /* Enhanced Contract Cards */
    .contract-card {
        transition: all 0.3s var(--ease-smooth);
    }
    .contract-card:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(0,0,0,0.2);
    }
    .contract-card.tracked {
        animation: tracked-glow 2s ease-in-out infinite;
    }
    @keyframes tracked-glow {
        0%, 100% { box-shadow: 0 0 5px rgba(74,138,154,0.3); }
        50% { box-shadow: 0 0 15px rgba(74,138,154,0.5); }
    }

    /* Pirate Shake Enhanced */
    .pirate-icon {
        animation: pirate-shake 0.6s ease-in-out infinite, pirate-hover 1.5s ease-in-out infinite;
    }
    @keyframes pirate-shake {
        0%, 100% { transform: rotate(-8deg); }
        50% { transform: rotate(8deg); }
    }
    @keyframes pirate-hover {
        0%, 100% { filter: drop-shadow(0 5px 10px rgba(0,0,0,0.3)); }
        50% { filter: drop-shadow(0 10px 20px rgba(0,0,0,0.4)); }
    }

    /* Warning Pulse */
    .warning-icon {
        animation: warning-pulse 1s ease-in-out infinite;
    }
    @keyframes warning-pulse {
        0%, 100% { transform: scale(1); filter: brightness(1); }
        50% { transform: scale(1.1); filter: brightness(1.2); }
    }

    /* Island Indicator Slide */
    #island-indicator {
        transition: all 0.4s var(--ease-elastic);
    }
    #island-indicator.visible {
        animation: slide-in-right 0.4s var(--ease-bounce);
    }
    @keyframes slide-in-right {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }

    /* Ship Condition Critical Pulse */
    #ship-condition.critical {
        animation: critical-pulse 1.2s ease-in-out infinite;
    }
    @keyframes critical-pulse {
        0%, 100% { border-color: var(--blood-red); box-shadow: 0 0 10px rgba(139,37,0,0.3); }
        50% { border-color: #ff4040; box-shadow: 0 0 20px rgba(139,37,0,0.5); }
    }

    /* Cargo Dot Enhanced */
    .cargo-dot {
        transition: all 0.2s var(--ease-elastic);
        animation: cargo-pop 0.3s var(--ease-bounce) both;
    }
    .cargo-dot:hover { transform: scale(1.5); }
    @keyframes cargo-pop {
        from { transform: scale(0); }
        to { transform: scale(1); }
    }

    /* Weather Overlay Effects */
    #weather-overlay {
        position: fixed; inset: 0; pointer-events: none; z-index: 5;
        opacity: 0; transition: opacity 1s ease;
    }
    #weather-overlay.active { opacity: 1; }
    #weather-overlay.storm {
        background: linear-gradient(180deg,
            rgba(30,50,70,0.3) 0%,
            rgba(20,40,60,0.1) 50%,
            transparent 100%);
        animation: storm-flash 4s ease-in-out infinite;
    }
    @keyframes storm-flash {
        0%, 90%, 100% { opacity: 1; }
        92% { opacity: 0.6; }
        94% { opacity: 1; }
        96% { opacity: 0.7; }
    }
    #weather-overlay.rain::before {
        content: ''; position: absolute; inset: 0;
        background: repeating-linear-gradient(
            transparent 0px,
            transparent 10px,
            rgba(150,180,200,0.1) 10px,
            rgba(150,180,200,0.1) 11px
        );
        animation: rain-fall 0.3s linear infinite;
    }
    @keyframes rain-fall {
        from { transform: translateY(-11px); }
        to { transform: translateY(0); }
    }
    #weather-overlay.fog {
        background: radial-gradient(ellipse at center,
            transparent 0%,
            rgba(200,210,220,0.2) 50%,
            rgba(180,190,200,0.4) 100%);
    }

    /* Particle Effects Container */
    #particle-container {
        position: fixed; inset: 0; pointer-events: none; z-index: 4;
        overflow: hidden;
    }
    .particle {
        position: absolute; border-radius: 50%;
        animation: particle-float var(--particle-speed) linear infinite;
    }
    .particle.sparkle {
        width: 3px; height: 3px; background: var(--gold);
        box-shadow: 0 0 6px var(--gold);
    }
    .particle.bubble {
        width: 8px; height: 8px;
        border: 1px solid rgba(255,255,255,0.4);
        background: radial-gradient(circle at 30% 30%,
            rgba(255,255,255,0.3),
            transparent);
    }
    @keyframes particle-float {
        0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
        10% { opacity: 1; }
        90% { opacity: 1; }
        100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
    }

    /* Vignette Effect */
    #vignette {
        position: fixed; inset: 0; pointer-events: none; z-index: 3;
        background: radial-gradient(ellipse at center,
            transparent 60%,
            rgba(0,0,0,0.4) 100%);
        transition: opacity 0.5s ease;
    }
    [data-theme="dark"] #vignette {
        background: radial-gradient(ellipse at center,
            transparent 50%,
            rgba(0,0,0,0.6) 100%);
    }

    /* Day/Night Tint Overlay */
    #daytime-overlay {
        position: fixed; inset: 0; pointer-events: none; z-index: 2;
        transition: background 2s ease;
    }
    #daytime-overlay.dawn { background: rgba(255,180,120,0.1); }
    #daytime-overlay.day { background: transparent; }
    #daytime-overlay.dusk { background: rgba(255,120,80,0.15); }
    #daytime-overlay.night { background: rgba(20,30,60,0.25); }

    @media (max-height: 500px) and (orientation: landscape) {
        :root { --action-stack-h: 160px; --action-stack-bottom: 10px; }
        #mobile-controls { height: 140px; }
        #joystick-zone { width: 100px; height: 100px; bottom: 10px; left: 10px; }
        #joystick-base { width: 100px; height: 100px; }
        #joystick-stick { width: 40px; height: 40px; }
        .action-btn { width: 50px; height: 50px; font-size: 1.2rem; }
        #action-buttons { bottom: var(--action-stack-bottom); right: 10px; gap: 8px; }
    }

    /* Portrait mode - compact but usable HUD */
    @media (orientation: portrait) {
        #theme-toggle { right: 65px; top: 4px; width: 34px; height: 34px; font-size: 1rem; }

        #hud-top { padding: 4px var(--space-sm); gap: 4px; }
        .hud-item { padding: 5px 10px; font-size: 0.72rem; gap: 4px; }
        .hud-icon { font-size: 0.85rem; }

        #hud-left { top: 38px; left: 4px; gap: 3px; max-width: 105px; }
        .hud-group { padding: 5px 7px; }
        #faction-badge { font-size: 0.68rem; gap: 4px; }
        #cargo-summary { padding: 5px 7px; font-size: 0.68rem; }
        .cargo-header { font-size: 0.62rem; }
        .cargo-dot { width: 6px; height: 6px; }
        #wind-indicator { padding: 4px 7px; font-size: 0.68rem; }
        #wind-arrow { font-size: 0.8rem; }
        #heat-indicator, #bounty-indicator, #notoriety-indicator { padding: 4px 7px; font-size: 0.68rem; }
        #heat-indicator .heat-bar, #notoriety-indicator .notoriety-bar, .status-bar { width: 36px; height: 4px; }
        #world-indicator { padding: 4px 7px; font-size: 0.62rem; }
        #contract-tracker { padding: 4px 7px; font-size: 0.68rem; max-width: 100px; }
        #contract-tracker .contract-title { max-width: 60px; }
        #contract-tracker .contract-meta { font-size: 0.58rem; }

        #ship-condition { padding: 5px 7px; }
        #ship-condition .ship-class-name { font-size: 0.68rem; margin-bottom: 3px; gap: 4px; }
        #ship-condition .condition-row { gap: 4px; margin: 2px 0; }
        #ship-condition .condition-icon { width: 14px; font-size: 0.65rem; }
        #ship-condition .condition-bar { height: 4px; min-width: 38px; }
        #ship-condition .condition-value { width: 20px; font-size: 0.62rem; }

        #compass { top: 38px; right: 4px; gap: 4px; }
        .compass-ring { width: 50px; height: 50px; }
        .compass-needle { width: 3px; height: 20px; }
        .compass-dest-marker { width: 7px; height: 7px; top: 4px; }
        .compass-n, .compass-e, .compass-s, .compass-w { font-size: 0.55rem; }
        .compass-n { top: 2px; }
        .compass-s { bottom: 2px; }
        .compass-e { right: 4px; }
        .compass-w { left: 4px; }
        #destination-info { padding: 4px 7px; font-size: 0.68rem; }
        #dest-name { font-size: 0.68rem; }
        #dest-distance { font-size: 0.58rem; }

        /* Larger touch targets for mobile usability */
        #mobile-controls { height: 160px; }
        #joystick-zone { width: 110px; height: 110px; bottom: 15px; left: 15px; }
        #joystick-base { width: 110px; height: 110px; }
        #joystick-stick { width: 46px; height: 46px; }
        #action-buttons { right: 12px; gap: 10px; }
        .action-btn { width: 54px; height: 54px; font-size: 1.25rem; }
        #speed-indicator { bottom: 135px; left: 18px; padding: 5px 9px; font-size: 0.68rem; }
        #speed-indicator .bar { width: 36px; height: 4px; }
        #island-indicator { padding: 5px 9px; font-size: 0.68rem; right: 12px; }

        #event-toast { top: 40px; padding: 7px 12px; }
        .event-icon { font-size: 1.1rem; }
        #event-title { font-size: 0.78rem; }
        #event-desc { font-size: 0.68rem; }
    }
</style>

</head>
<body>
    <!-- Theme Toggle Button -->
    <button id="theme-toggle" aria-label="Toggle dark/light mode">
        <span class="sun"></span>
        <span class="moon"></span>
    </button>

    <!-- Visual Effects Overlays -->
    <div id="daytime-overlay" class="day"></div>
    <div id="vignette"></div>
    <div id="particle-container"></div>
    <div id="weather-overlay"></div>

    <div id="loading-screen"><div class="loading-content"><h1>Havenvoy</h1><div class="loading-ship"></div><p>Charting the waters...</p><div class="loading-bar"><div class="loading-progress"></div></div></div></div>
<div id="error-overlay" class="hidden" style="position:fixed;inset:0;background:rgba(0,0,0,0.9);color:#fff;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:10000;padding:20px;text-align:center;">
    <div style="font-size:3rem;margin-bottom:1rem;"></div>
    <h2 style="margin:0 0 1rem;color:#f44;">Something went wrong</h2>
    <p id="error-message" style="margin:0 0 1rem;max-width:500px;opacity:0.8;font-size:0.9rem;">An error occurred while loading the game.</p>
    <pre id="error-details" style="background:#1a1a1a;padding:10px;border-radius:4px;max-width:90%;overflow:auto;font-size:0.75rem;text-align:left;margin:0 0 1rem;"></pre>
    <button onclick="location.reload()" style="background:#4a7c59;color:#fff;border:none;padding:12px 24px;border-radius:6px;font-size:1rem;cursor:pointer;"> Reload Game</button>
</div>
<div id="faction-screen" class="screen hidden">
    <div class="screen-content">
        <h1>Choose Your Allegiance</h1>
        <p class="subtitle">Your faction determines advantages and difficulty</p>
        <div class="faction-cards">
            <button class="faction-card" data-faction="english"><div class="faction-icon"></div><h2>Royal Navy</h2><span class="difficulty-tag difficulty-easy">Easy</span><p class="faction-desc">Servants of the Crown</p><ul class="faction-perks"><li> +25 Starting Reputation</li><li> 50% Less Pirate Encounters</li><li> Cheaper Tribute</li></ul></button>
            <button class="faction-card" data-faction="eitc"><div class="faction-icon"></div><h2>Trading Company</h2><span class="difficulty-tag difficulty-medium">Medium</span><p class="faction-desc">Profit Above All</p><ul class="faction-perks"><li> +20% Cargo Capacity</li><li> Better Trade Prices</li><li> Enhanced Logbook Intel</li></ul></button>
            <button class="faction-card" data-faction="pirates"><div class="faction-icon"></div><h2>Brethren Court</h2><span class="difficulty-tag difficulty-hard">Hard</span><p class="faction-desc">Freedom of the Seas</p><ul class="faction-perks"><li> Contraband +50%</li><li> Faster Speed</li><li> More Encounters</li></ul></button>
        </div>
        <button id="continue-btn" class="btn-primary hidden">Set Sail</button>
    </div>
</div>

<div id="game-container" class="hidden">
    <canvas id="game-canvas"></canvas>
    <div id="hud-top">
        <div class="hud-item"><span class="hud-icon"></span><span class="hud-value" id="gold-value">1000</span></div>
        <div class="hud-item"><span class="hud-icon"></span><span class="hud-value">Day <span id="day-value">1</span></span></div>
        <div class="hud-item"><span class="hud-icon"></span><span class="hud-value" id="supplies-value">30</span></div>
    </div>
    <div id="hud-left">
        <div class="hud-group">
            <div id="faction-badge"><span id="faction-icon"></span><span id="faction-name">Royal Navy</span></div>
        </div>
        <div id="cargo-summary"><div class="cargo-header"><span> Cargo</span><span id="cargo-count">0/50</span></div><div id="cargo-preview"></div></div>
        <div id="wind-indicator"><span id="wind-arrow"></span><span id="wind-strength">Calm</span></div>
        <div id="heat-indicator" class="low"><span></span><div class="heat-bar"><div class="heat-fill" id="heat-fill"></div></div><span id="heat-label">0</span></div>
        <div id="bounty-indicator" class="clean"><span></span><span id="bounty-level">Clean</span></div>
        <div id="notoriety-indicator" title="How predictable your trading patterns have become"><span></span><div class="notoriety-bar"><div class="notoriety-fill" id="notoriety-fill"></div></div><span id="notoriety-label">Unseen</span></div>
        <div id="contract-tracker" class="hidden"><span></span><span class="contract-title" id="tracker-title">--</span><span class="contract-meta" id="tracker-meta">--</span></div>
        <div id="world-indicator"><span id="world-icon"></span><span id="world-status">Fair Winds</span></div>
        <div id="ship-condition">
        <div class="ship-class-name"><span id="ship-class-icon"></span><span id="ship-class-label">Brigantine</span></div>
        <div class="condition-row"><span class="condition-icon" title="Hull integrity"></span><div class="condition-bar"><div class="condition-fill hull" id="hull-fill"></div></div><span class="condition-value" id="hull-value">100</span></div>
        <div class="condition-row"><span class="condition-icon" title="Rigging condition"></span><div class="condition-bar"><div class="condition-fill rigging" id="rigging-fill"></div></div><span class="condition-value" id="rigging-value">100</span></div>
        <div class="condition-row"><span class="condition-icon" title="Crew morale"></span><div class="condition-bar"><div class="condition-fill morale" id="morale-fill"></div></div><span class="condition-value" id="morale-value">100</span></div>
        </div>
    </div>
    <div id="chart-fragments" class="chart-fragment-indicator hidden"><span></span><span id="fragments-count">0</span>/3</div>
    <div id="compass">
        <div class="compass-ring">
            <div class="compass-needle" id="compass-needle"></div>
            <div class="compass-dest-marker hidden" id="compass-dest-marker"></div>
            <span class="compass-n">N</span><span class="compass-e">E</span><span class="compass-s">S</span><span class="compass-w">W</span>
        </div>
        <div id="destination-info" class="hidden"><span id="dest-name">--</span><span id="dest-distance">--</span></div>
    </div>
    <div id="event-toast" class="hidden"><div class="event-icon"></div><div class="event-text"><strong id="event-title">Event</strong><span id="event-desc">Description</span></div></div>
    <div id="mobile-controls">
        <div id="joystick-zone"><div id="joystick-base"></div><div id="joystick-stick"></div></div>
        <div id="speed-indicator"><span></span><div class="bar"><div class="bar-fill" id="speed-fill"></div></div><span id="wind-effect"></span></div>
        <div id="island-indicator"><div class="name" id="nearby-island-name">Port Royal</div><div class="faction" id="nearby-island-faction">English</div><div class="distance" id="nearby-island-dist">Nearby</div></div>
        <div id="action-buttons">
            <button class="action-btn" id="btn-dock"></button>
            <button class="action-btn" id="btn-map"></button>
            <button class="action-btn" id="btn-menu"></button>
        </div>
    </div>
</div>

<div id="trade-modal" class="modal hidden">
    <div class="modal-content">
        <div class="modal-header"><h2 id="trade-island-name">Port Royal</h2><div class="island-info"><span id="trade-island-faction" class="faction-tag">English</span><span id="trade-tariff" class="tariff-tag">No Tariff</span><span id="trade-port-state" class="port-state-tag hidden">Prosperous</span></div><button class="modal-close" id="close-trade"></button></div>
        <div class="trade-tabs">
            <button class="trade-tab active" data-tab="buy">Buy</button>
            <button class="trade-tab" data-tab="sell">Sell</button>
            <button class="trade-tab" data-tab="contracts"> Jobs<span class="tab-badge hidden" id="contracts-badge">0</span></button>
            <button class="trade-tab" data-tab="tavern"> Tavern</button>
            <button class="trade-tab" data-tab="logbook"> Log</button>
            <button class="trade-tab" data-tab="shipyard"> Ship</button>
        </div>
        <div class="trade-panel" id="buy-panel"><div class="panel-actions"><button class="btn-secondary btn-small" id="buy-best-btn"> Buy Best</button></div><div class="goods-list" id="buy-goods-list"></div></div>
        <div class="trade-panel hidden" id="sell-panel"><div class="panel-actions"><button class="btn-secondary btn-small" id="sell-best-btn"> Sell Best</button></div><div class="goods-list" id="sell-goods-list"></div></div>
        <div class="trade-panel hidden" id="contracts-panel"><div class="logbook-section" id="questline-section"><h4> Questlines</h4><div id="questline-content"></div></div><div class="logbook-section"><h4> Available Contracts</h4><div id="available-contracts"></div></div><div class="logbook-section"><h4> Active Contracts (<span id="active-count">0</span>/3)</h4><div id="active-contracts"></div></div></div>
        <div class="trade-panel hidden" id="tavern-panel"><div class="logbook-section"><h4> Your Officers (<span id="officer-count">0</span>/3)</h4><div id="current-officers"></div></div><div class="logbook-section"><h4> Available for Hire</h4><div id="available-officers"></div></div><div class="logbook-section"><h4> Port Rumors</h4><div id="tavern-rumors"></div></div></div>
        <div class="trade-panel hidden" id="logbook-panel"><div class="logbook-section"><h4> Deal Spotlight</h4><div id="spotlight-list"></div></div><div class="logbook-section"><h4> Price History</h4><select class="island-select" id="logbook-island-select"></select><div id="logbook-prices"></div></div></div>
        <div class="trade-panel hidden" id="shipyard-panel"><div id="upgrades-list"></div></div>
        <div class="trade-footer"><div class="player-stats"><span> <span id="trade-gold">1000</span></span><span> <span id="trade-cargo">0/50</span></span></div><button class="btn-primary" id="leave-port-btn">Set Sail</button></div>
    </div>
</div>

<div id="map-modal" class="modal hidden">
    <div class="modal-content map-content">
        <h2>Navigation Chart</h2>
        <div id="map-container"></div>
        <div class="map-info" id="map-info">Click island to set course</div>
        <div class="map-legend"><span><div class="legend-dot" style="background:var(--english)"></div>English</span><span><div class="legend-dot" style="background:var(--eitc)"></div>EITC</span><span><div class="legend-dot" style="background:var(--pirates)"></div>Pirates</span><span><div class="legend-dot" style="background:var(--neutral)"></div>Neutral</span></div>
        <div class="map-buttons"><button class="btn-secondary" id="clear-course-btn">Clear Course</button><button class="btn-primary" id="close-map">Close</button></div>
    </div>
</div>

<div id="cove-modal" class="modal hidden">
    <div class="modal-content cove-modal-content">
        <div class="cove-icon" id="cove-icon"></div>
        <h2 id="cove-name">Hidden Cove</h2>
        <p class="cove-desc" id="cove-desc">A hidden location known only to a few...</p>
        <div class="cove-services" id="cove-services"></div>
        <button class="btn-secondary" id="close-cove" style="margin-top: var(--space-md);">Leave</button>
    </div>
</div>

<div id="menu-modal" class="modal hidden">
    <div class="modal-content menu-content">
        <h2>Captain's Log</h2>
        <div class="menu-section"><h3>Reputation</h3><div class="reputation-bars"><div class="rep-item"><span> Navy</span><div class="rep-bar"><div class="rep-fill" id="rep-english"></div></div><span class="rep-value" id="rep-english-val">0</span></div><div class="rep-item"><span> EITC</span><div class="rep-bar"><div class="rep-fill" id="rep-eitc"></div></div><span class="rep-value" id="rep-eitc-val">0</span></div><div class="rep-item"><span> Pirates</span><div class="rep-bar"><div class="rep-fill" id="rep-pirates"></div></div><span class="rep-value" id="rep-pirates-val">0</span></div></div></div>
        <div class="menu-section"><h3>Titles</h3><div id="titles-list"></div></div>
        <div class="menu-section"><h3>World Status</h3><div class="ship-stats"><div class="stat-row"><span>Season</span><span id="menu-season">Fair</span></div><div class="stat-row"><span>Crackdown</span><span id="menu-crackdown">None</span></div><div class="stat-row"><span>Regional Event</span><span id="menu-regional">None</span></div></div></div>
        <div class="menu-section"><h3>Ship</h3><div class="ship-stats"><div class="stat-row"><span>Speed</span><span id="ship-speed">1.0x</span></div><div class="stat-row"><span>Cargo</span><span id="ship-cargo-cap">50</span></div><div class="stat-row"><span>Supply/Day</span><span id="ship-supply-rate">1</span></div><div class="stat-row"><span>Upgrades</span><span id="ship-upgrades">None</span></div></div></div>
        <div class="menu-section"><h3>Wind & Risk</h3><div class="ship-stats"><div class="stat-row"><span>Wind</span><span id="menu-wind-dir">N Calm</span></div><div class="stat-row"><span>Wind Change</span><span id="menu-wind-change">5d</span></div><div class="stat-row"><span>Route Risk</span><span id="menu-route-risk">Low</span></div><div class="stat-row"><span>Heat</span><span id="menu-heat">0</span></div></div></div>
        <div class="menu-section"><h3>Settings</h3><div class="settings-grid"><div class="setting-row"><div><div class="setting-label">Invert Joystick</div><div class="setting-desc">Push forward to go backward</div></div><div class="toggle-switch" id="invert-joystick-toggle"></div></div></div></div>
        <div class="menu-section"><h3 class="help-collapse" id="help-toggle">Help Guide</h3><div class="help-content" id="help-content"><div class="help-grid">
            <div class="help-item"><div class="help-icon"></div><div class="help-text"><strong>Gold</strong><span>Your currency for trading, repairs, and bribes</span></div></div>
            <div class="help-item"><div class="help-icon"></div><div class="help-text"><strong>Day</strong><span>Days passed - contracts have deadlines!</span></div></div>
            <div class="help-item"><div class="help-icon"></div><div class="help-text"><strong>Supplies</strong><span>Consumed daily. Run out and crew morale drops</span></div></div>
            <div class="help-item"><div class="help-icon"></div><div class="help-text"><strong>Cargo</strong><span>Current/max cargo capacity. Trade goods fill this</span></div></div>
            <div class="help-item"><div class="help-icon"></div><div class="help-text"><strong>Compass</strong><span>Red needle points North. Gold dot shows your destination</span></div></div>
            <div class="help-item"><div class="help-icon"></div><div class="help-text"><strong>Wind</strong><span>Arrow shows direction. Sailing with wind = faster</span></div></div>
            <div class="help-item"><div class="help-icon"></div><div class="help-text"><strong>Heat</strong><span>Smuggling attention. High heat = more inspections</span></div></div>
            <div class="help-item"><div class="help-icon"></div><div class="help-text"><strong>Bounty</strong><span>Criminal status. Pirates attack, Navy hunts you</span></div></div>
            <div class="help-item"><div class="help-icon"></div><div class="help-text"><strong>Hull</strong><span>Ship health. Low = risk of sinking. Repair at shipyard</span></div></div>
            <div class="help-item"><div class="help-icon"></div><div class="help-text"><strong>Rigging</strong><span>Sail condition. Affects speed. Repair at shipyard</span></div></div>
            <div class="help-item"><div class="help-icon"></div><div class="help-text"><strong>Morale</strong><span>Crew happiness. Low = mutiny risk. Keep supplies up</span></div></div>
            <div class="help-item"><div class="help-icon"></div><div class="help-text"><strong>Dock Button</strong><span>Pulses blue when near a port. Tap to dock and trade</span></div></div>
            <div class="help-item"><div class="help-icon"></div><div class="help-text"><strong>Map Button</strong><span>View world map. Tap islands to set destination</span></div></div>
            <div class="help-item"><div class="help-icon"></div><div class="help-text"><strong>Menu Button</strong><span>Opens this Captain's Log. Save game here</span></div></div>
        </div></div></div>
        <div class="menu-buttons"><button class="btn-secondary" id="save-btn"> Save</button><button class="btn-secondary" id="new-game-btn"> New Game</button></div>
        <button class="btn-primary" id="close-menu">Continue</button>
    </div>
</div>

<div id="pirate-modal" class="modal hidden"><div class="modal-content pirate-content"><div class="pirate-icon"></div><h2>Pirates!</h2><p>They demand tribute!</p><div class="pirate-options"><button class="btn-danger" id="pay-tribute"> Pay <small id="tribute-cost">100g</small></button><button class="btn-secondary" id="fight-pirates"> Fight</button><button class="btn-primary hidden" id="pirate-pass"> Parley</button></div></div></div>

<div id="chase-modal" class="modal hidden">
    <div class="modal-content chase-content">
        <div class="chase-header">
            <span class="chase-icon"></span>
            <h2>Pirates Spotted!</h2>
        </div>
        <p class="chase-desc" id="chase-desc">A pirate ship is giving chase! Try to escape!</p>
        <div class="chase-progress">
            <div class="chase-bar">
                <div class="chase-player" id="chase-player"></div>
                <div class="chase-pirate" id="chase-pirate"></div>
            </div>
            <div class="chase-labels">
                <span>Escape</span>
                <span>Caught</span>
            </div>
        </div>
        <div class="chase-stats">
            <div class="chase-stat"><span>Escape Chance:</span><span id="chase-chance">50%</span></div>
            <div class="chase-stat"><span>Time Left:</span><span id="chase-timer">15s</span></div>
        </div>
        <div class="chase-actions">
            <button class="btn-primary chase-action" id="chase-trim"> Trim Sails</button>
            <button class="btn-secondary chase-action" id="chase-jettison"> Jettison Cargo</button>
            <button class="btn-danger chase-action" id="chase-risky"> Risky Maneuver</button>
        </div>
        <div class="chase-result hidden" id="chase-result"></div>
    </div>
</div>

<div id="encounter-modal" class="modal hidden"><div class="modal-content encounter-content"><div class="encounter-icon" id="encounter-icon"></div><h2 id="encounter-title">Event</h2><p id="encounter-desc">Description</p><div id="encounter-result"></div><div class="encounter-options" id="encounter-options"></div></div></div>

<div id="warning-modal" class="modal hidden"><div class="modal-content warning-content"><div class="warning-icon" id="warning-icon"></div><h2 id="warning-title">Warning</h2><p id="warning-text">Message</p><button class="btn-primary" id="warning-dismiss">Continue</button></div></div>

<div id="title-modal" class="modal hidden"><div class="modal-content warning-content"><div class="warning-icon" id="title-icon"></div><h2 id="title-earned-name">Title Earned!</h2><p id="title-earned-desc">You have proven yourself worthy.</p><button class="btn-primary" id="title-dismiss">Continue</button></div></div>

<div id="contract-complete-modal" class="modal hidden"><div class="modal-content warning-content"><div class="warning-icon" id="contract-complete-icon"></div><h2 id="contract-complete-title">Contract Complete!</h2><p id="contract-complete-desc">You've fulfilled the contract.</p><div id="contract-complete-rewards"></div><button class="btn-primary" id="contract-complete-dismiss">Collect Rewards</button></div></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
// Error overlay display function
function showErrorOverlay(message, details) {
    var overlay = document.getElementById('error-overlay');
    var msgEl = document.getElementById('error-message');
    var detailsEl = document.getElementById('error-details');
    if (overlay && msgEl && detailsEl) {
        msgEl.textContent = message || 'An error occurred while loading the game.';
        detailsEl.textContent = details || '';
        overlay.classList.remove('hidden');
        document.getElementById('loading-screen')?.classList.add('hidden');
    }
}

// NON-MODULE FALLBACK - runs even if module fails to load
window.onerror = function(msg, url, line, col, error) {
    console.error('Script error:', msg, url, line);
    var details = 'Error: ' + msg + '\nLocation: ' + (url || 'unknown') + ':' + (line || '?');
    if (error && error.stack) details += '\n\nStack:\n' + error.stack;
    showErrorOverlay('A script error occurred. Try refreshing the page.', details);
    return false;
};

// Catch module import errors
window.addEventListener('unhandledrejection', function(event) {
    console.error('Module error:', event.reason);
    var details = event.reason ? (event.reason.message || String(event.reason)) : 'Unknown module error';
    if (event.reason && event.reason.stack) details += '\n\nStack:\n' + event.reason.stack;
    showErrorOverlay('Failed to load a required module. Check your network connection.', details);
});

// Fallback timeout - if loading screen still showing after 5 seconds, something is wrong
window.addEventListener('DOMContentLoaded', function() {
    // Bind fallback faction selection handlers immediately
    var factionCards = document.querySelectorAll('.faction-card');
    var continueBtn = document.getElementById('continue-btn');
    var selectedFaction = null;

    factionCards.forEach(function(card) {
        card.addEventListener('click', function() {
            factionCards.forEach(function(c) { c.classList.remove('selected'); });
            card.classList.add('selected');
            selectedFaction = card.dataset.faction;
            if (continueBtn) continueBtn.classList.remove('hidden');
            console.log('Fallback: Selected faction', selectedFaction);
        });
    });

    // Fallback continue button handler
    if (continueBtn) {
        continueBtn.addEventListener('click', function() {
            console.log('Fallback: Continue clicked, faction:', selectedFaction);
            // Check if game module loaded and has startGame function
            if (window.game && typeof window.game.startGame === 'function') {
                window.game.startGame(selectedFaction);
            } else {
                console.error('Game module not loaded yet');
                alert('Game is still loading. Please wait a moment and try again, or refresh the page.');
            }
        });
    }

    setTimeout(function() {
        var loading = document.getElementById('loading-screen');
        if (loading && !loading.classList.contains('hidden')) {
            console.warn('Loading timeout - module may have failed to load');
            loading.classList.add('hidden');
            var faction = document.getElementById('faction-screen');
            if (faction) faction.classList.remove('hidden');
        }
    }, 15000); // 15 second fallback - only triggers if module truly fails
});
</script>

<script type="module">
// THREE is loaded globally via script tag above
const THREE = window.THREE;

console.log('Module loaded - Three.js ready:', !!THREE);

// ==================== CONFIG ====================
const CONFIG = {
goods: {
rum: { name: 'Rum', basePrice: 25, category: 'commodity', weight: 1, icon: '' },
sugar: { name: 'Sugar', basePrice: 15, category: 'commodity', weight: 2, icon: '' },
tobacco: { name: 'Tobacco', basePrice: 30, category: 'commodity', weight: 1, icon: '' },
spices: { name: 'Spices', basePrice: 60, category: 'luxury', weight: 1, icon: '' },
tea: { name: 'Tea', basePrice: 45, category: 'luxury', weight: 1, icon: '' },
silk: { name: 'Silk', basePrice: 80, category: 'luxury', weight: 1, icon: '' },
gunpowder: { name: 'Gunpowder', basePrice: 50, category: 'contraband', weight: 2, icon: '' },
timber: { name: 'Timber', basePrice: 20, category: 'commodity', weight: 3, icon: '' },
iron: { name: 'Iron', basePrice: 35, category: 'commodity', weight: 3, icon: '' },
gold: { name: 'Gold', basePrice: 150, category: 'luxury', weight: 1, icon: '' }
},
islands: {
portRoyal: { name: 'Port Royal', position: { x: 0, z: 0 }, faction: 'english', color: 0x2d5016, markets: { rum: { preference: 'exports', targetSupply: 80, targetDemand: 30 }, sugar: { preference: 'exports', targetSupply: 100, targetDemand: 20 }, tobacco: { preference: 'neutral', targetSupply: 50, targetDemand: 50 }, spices: { preference: 'imports', targetSupply: 20, targetDemand: 60 }, tea: { preference: 'imports', targetSupply: 30, targetDemand: 70 }, silk: { preference: 'imports', targetSupply: 15, targetDemand: 50 }, gunpowder: { preference: 'neutral', targetSupply: 40, targetDemand: 40 }, timber: { preference: 'exports', targetSupply: 70, targetDemand: 30 }, iron: { preference: 'imports', targetSupply: 25, targetDemand: 55 }, gold: { preference: 'imports', targetSupply: 10, targetDemand: 40 } } },
tortuga: { name: 'Tortuga', position: { x: 150, z: -80 }, faction: 'pirates', color: 0x4a3728, markets: { rum: { preference: 'imports', targetSupply: 30, targetDemand: 90 }, sugar: { preference: 'neutral', targetSupply: 40, targetDemand: 40 }, tobacco: { preference: 'imports', targetSupply: 20, targetDemand: 70 }, spices: { preference: 'neutral', targetSupply: 30, targetDemand: 30 }, tea: { preference: 'neutral', targetSupply: 20, targetDemand: 20 }, silk: { preference: 'imports', targetSupply: 10, targetDemand: 50 }, gunpowder: { preference: 'exports', targetSupply: 90, targetDemand: 20 }, timber: { preference: 'imports', targetSupply: 25, targetDemand: 60 }, iron: { preference: 'imports', targetSupply: 20, targetDemand: 55 }, gold: { preference: 'exports', targetSupply: 60, targetDemand: 30 } } },
nassau: { name: 'Nassau', position: { x: -120, z: -150 }, faction: 'pirates', color: 0x5c4a32, markets: { rum: { preference: 'exports', targetSupply: 70, targetDemand: 30 }, sugar: { preference: 'exports', targetSupply: 60, targetDemand: 25 }, tobacco: { preference: 'exports', targetSupply: 80, targetDemand: 20 }, spices: { preference: 'imports', targetSupply: 15, targetDemand: 55 }, tea: { preference: 'imports', targetSupply: 10, targetDemand: 45 }, silk: { preference: 'imports', targetSupply: 10, targetDemand: 40 }, gunpowder: { preference: 'exports', targetSupply: 75, targetDemand: 30 }, timber: { preference: 'exports', targetSupply: 90, targetDemand: 20 }, iron: { preference: 'imports', targetSupply: 20, targetDemand: 60 }, gold: { preference: 'neutral', targetSupply: 25, targetDemand: 25 } } },
havana: { name: 'Havana', position: { x: -80, z: 100 }, faction: 'neutral', color: 0x3d6b2e, markets: { rum: { preference: 'exports', targetSupply: 85, targetDemand: 25 }, sugar: { preference: 'exports', targetSupply: 95, targetDemand: 15 }, tobacco: { preference: 'exports', targetSupply: 90, targetDemand: 20 }, spices: { preference: 'neutral', targetSupply: 40, targetDemand: 40 }, tea: { preference: 'imports', targetSupply: 15, targetDemand: 60 }, silk: { preference: 'imports', targetSupply: 10, targetDemand: 55 }, gunpowder: { preference: 'imports', targetSupply: 20, targetDemand: 70 }, timber: { preference: 'neutral', targetSupply: 50, targetDemand: 50 }, iron: { preference: 'imports', targetSupply: 25, targetDemand: 65 }, gold: { preference: 'exports', targetSupply: 45, targetDemand: 35 } } },
kingston: { name: 'Kingston', position: { x: 100, z: 120 }, faction: 'english', color: 0x4a7a3a, markets: { rum: { preference: 'neutral', targetSupply: 50, targetDemand: 50 }, sugar: { preference: 'exports', targetSupply: 75, targetDemand: 30 }, tobacco: { preference: 'exports', targetSupply: 65, targetDemand: 35 }, spices: { preference: 'exports', targetSupply: 70, targetDemand: 25 }, tea: { preference: 'imports', targetSupply: 20, targetDemand: 65 }, silk: { preference: 'imports', targetSupply: 15, targetDemand: 50 }, gunpowder: { preference: 'neutral', targetSupply: 35, targetDemand: 35 }, timber: { preference: 'imports', targetSupply: 30, targetDemand: 60 }, iron: { preference: 'imports', targetSupply: 25, targetDemand: 55 }, gold: { preference: 'imports', targetSupply: 15, targetDemand: 45 } } },
barbados: { name: 'Barbados', position: { x: 200, z: 50 }, faction: 'eitc', color: 0x5a8a4a, markets: { rum: { preference: 'exports', targetSupply: 90, targetDemand: 20 }, sugar: { preference: 'exports', targetSupply: 95, targetDemand: 15 }, tobacco: { preference: 'neutral', targetSupply: 45, targetDemand: 45 }, spices: { preference: 'neutral', targetSupply: 40, targetDemand: 40 }, tea: { preference: 'imports', targetSupply: 20, targetDemand: 70 }, silk: { preference: 'imports', targetSupply: 15, targetDemand: 60 }, gunpowder: { preference: 'imports', targetSupply: 25, targetDemand: 55 }, timber: { preference: 'imports', targetSupply: 30, targetDemand: 55 }, iron: { preference: 'imports', targetSupply: 20, targetDemand: 60 }, gold: { preference: 'imports', targetSupply: 10, targetDemand: 50 } } },
cartagena: { name: 'Cartagena', position: { x: -180, z: -50 }, faction: 'neutral', color: 0x6a5a3a, markets: { rum: { preference: 'imports', targetSupply: 30, targetDemand: 60 }, sugar: { preference: 'neutral', targetSupply: 45, targetDemand: 45 }, tobacco: { preference: 'imports', targetSupply: 25, targetDemand: 55 }, spices: { preference: 'exports', targetSupply: 65, targetDemand: 30 }, tea: { preference: 'neutral', targetSupply: 35, targetDemand: 35 }, silk: { preference: 'exports', targetSupply: 55, targetDemand: 30 }, gunpowder: { preference: 'imports', targetSupply: 20, targetDemand: 70 }, timber: { preference: 'neutral', targetSupply: 50, targetDemand: 50 }, iron: { preference: 'exports', targetSupply: 60, targetDemand: 35 }, gold: { preference: 'exports', targetSupply: 70, targetDemand: 20 } } }
},
factions: {
english: { name: 'Royal Navy', icon: '', taxRate: 0.05, startingRep: { english: 25, eitc: 0, pirates: -25 }, pirateChanceMult: 0.5, tributeMult: 0.7 },
eitc: { name: 'Trading Co.', icon: '', taxRate: 0, startingRep: { english: 0, eitc: 25, pirates: -15 }, cargoBonus: 0.2, priceBonus: 0.05, logbookBonus: true },
pirates: { name: 'Brethren', icon: '', taxRate: 0, startingRep: { english: -30, eitc: -20, pirates: 50 }, contrabandBonus: 0.5, speedBonus: 0.2, pirateChanceMult: 1.3 }
},
// UPGRADES with real tradeoffs - pros array for positive effects, cons array for negative
upgrades: {
swiftSails: {
name: 'Swift Sails', cost: 600, icon: '',
desc: 'Better wind usage but fragile rigging needs more upkeep',
pros: ['+30% wind bonus'],
cons: ['+0.5 supplies/day'],
effects: { windBonus: 0.3, supplyCostExtra: 0.5 }
},
reinforcedHold: {
name: 'Reinforced Hold', cost: 750, icon: '',
desc: 'Protects cargo in fights but weighs down the ship',
pros: ['50% cargo protection'],
cons: ['-10% speed', '-5 cargo capacity'],
effects: { cargoProtection: 0.5, speedPenalty: 0.1, capacityPenalty: 5 }
},
luxuryLocker: {
name: 'Luxury Locker', cost: 500, icon: '',
desc: 'Specialized storage for delicate luxury goods',
pros: ['+8 luxury capacity'],
cons: ['-3 commodity capacity'],
effects: { luxuryCapBonus: 8, commodityCapPenalty: 3 }
},
smugglerCompartments: {
name: 'Smuggler Compartments', cost: 650, icon: '',
desc: 'Hidden spaces reduce inspection risk but take room',
pros: ['-50% inspection chance', '+10% contraband profit'],
cons: ['-4 total capacity', '+0.25 supplies/day'],
effects: { inspectionReduction: 0.5, contrabandProfitBonus: 0.1, capacityPenalty: 4, supplyCostExtra: 0.25 }
},
vault: {
name: 'Iron Vault', cost: 900, icon: '',
desc: 'Protects wealth from pirates but heavy and expensive',
pros: ['-40% tribute cost', '-30% gold loss in fights'],
cons: ['-8% speed', '-3 capacity'],
effects: { tributeReduction: 0.4, goldProtection: 0.3, speedPenalty: 0.08, capacityPenalty: 3 }
}
},
// TITLES - endless progression tiers
titles: {
merchant: {
    name: 'Merchant',
    icon: '',
    thresholds: [500, 2000, 5000, 15000, 50000], // net worth
    tierNames: ['Peddler', 'Trader', 'Merchant', 'Magnate', 'Tycoon', 'Legend'],
    effects: { repGainMult: 0.02 } // +2% per tier
},
smuggler: {
    name: 'Smuggler',
    icon: '',
    thresholds: [5, 20, 50, 100, 200], // lifetime contraband traded
    tierNames: ['Runner', 'Smuggler', 'Kingpin', 'Shadow Lord', 'Ghost', 'Phantom'],
    effects: { repLossReduction: 0.04, tributeReduction: 0.03 } // per tier
},
voyager: {
    name: 'Voyager',
    icon: '',
    thresholds: [10, 30, 75, 150, 300], // days sailed
    tierNames: ['Deckhand', 'Sailor', 'Voyager', 'Navigator', 'Admiral', 'Legend'],
    effects: { inspectionReduction: 0.02 } // per tier
}
},
// CONTRACT TYPES - BALANCE: Reduced rewards & rep, contracts supplement trading not replace it
contractTypes: {
delivery: { name: 'Delivery', icon: '', baseReward: 50, repReward: 2, riskMult: 1.0 },        // Rep 5->2, just a routine delivery
smuggling: { name: 'Smuggling', icon: '', baseReward: 100, repReward: -5, riskMult: 1.8, heatGain: 20 }, // Rep penalty stays
courier: { name: 'Courier', icon: '', baseReward: 25, repReward: 2, riskMult: 0.8, depositPct: 0.3 },  // Rep 5->2, just travel
supply: { name: 'Supply Run', icon: '', baseReward: 20, repReward: 2, riskMult: 0.6, supplyCost: 8 },  // Rep 3->2, minor help
faction: { name: 'Faction Work', icon: '', baseReward: 15, repReward: 5, riskMult: 1.2 }    // Rep 12->5, was way too high
},
events: [
{ id: 'festival', name: 'Festival', desc: 'Luxury demand up!', duration: 3, affects: ['luxury'], multiplier: 1.5 },
{ id: 'shortage', name: 'Shortage', desc: 'Prices up!', duration: 4, affects: ['commodity'], multiplier: 1.4 },
{ id: 'surplus', name: 'Surplus', desc: 'Prices down!', duration: 3, affects: ['commodity'], multiplier: 0.7 }
],
// REGIONAL EVENTS for living world
regionalEvents: [
{ id: 'trade_boom', name: 'Trade Boom', desc: 'All prices up 20%', duration: 5, categoryMult: { commodity: 1.2, luxury: 1.2, contraband: 1.1 } },
{ id: 'pirate_activity', name: 'Pirate Activity', desc: 'Contraband prices soar', duration: 4, categoryMult: { commodity: 1.0, luxury: 1.0, contraband: 1.5 } },
{ id: 'naval_blockade', name: 'Naval Blockade', desc: 'Commodity shortage', duration: 4, categoryMult: { commodity: 1.4, luxury: 1.1, contraband: 0.8 } },
{ id: 'merchant_fair', name: 'Merchant Fair', desc: 'Luxury demand high', duration: 3, categoryMult: { commodity: 0.9, luxury: 1.4, contraband: 1.0 } }
],
encounters: {
storm: { name: 'Storm!', icon: '', desc: 'A violent storm approaches!', baseChance: 0.04 },
adriftMerchant: { name: 'Adrift Merchant', icon: '', desc: 'A merchant offers a trade.', baseChance: 0.03 },
wreckSalvage: { name: 'Wreckage', icon: '', desc: 'Floating debris. Investigate?', baseChance: 0.03 },
inspection: { name: 'Inspection!', icon: '', desc: 'Naval patrol demands to search your vessel!', baseChance: 0.05 },
// === LIVING SEA ENCOUNTERS ===
desperateMerchant: { name: 'The Desperate Merchant', icon: '', desc: 'A damaged trader hails you. They\'re out of supplies and offer their cargo at half pricebut taking it means they\'ll die at sea.', baseChance: 0.02 },
driftingMarket: { name: 'The Drifting Market', icon: '', desc: 'The Free Merchantsno flags, no tariffs, no promises. They\'re packing up. Last chance.', baseChance: 0.0 }, // Triggered by drift entity
blockadeRunner: { name: 'The Blockade Runner', icon: '', desc: 'A smuggler offers to guide you through a blockaded port for a fee.', baseChance: 0.02 },
stormsEye: { name: 'The Storm\'s Eye', icon: '', desc: 'Mid-storm, you find a pocket of calm with a wrecked ship.', baseChance: 0.0 }, // Triggered during storms
pirateFleetEncounter: { name: 'Pirate Armada!', icon: '', desc: 'A pirate fleet surrounds you! Multiple ships demand tribute.', baseChance: 0.0 }, // Triggered by drift entity
convoyEncounter: { name: 'Navy Convoy', icon: '', desc: 'You\'ve entered Navy convoy waters. They offer protectionif you submit to inspection.', baseChance: 0.0 } // Triggered by drift entity
},
// PORT STATES - dynamic port conditions
portStates: {
    prosperous: { name: 'Prosperous', icon: '', desc: 'Fat and happyand they\'ll inspect every crate.', inspectMult: 1.5, tariffMult: 1.2, priceMult: 0.9, supplyMult: 1.3 },
    struggling: { name: 'Struggling', icon: '', desc: 'They need goods. They\'ll overlook... irregularities.', inspectMult: 0.5, tariffMult: 0.8, priceMult: 1.2, supplyMult: 0.7 },
    blockaded: { name: 'Blockaded', icon: '', desc: 'Nothing gets in. Nothing gets out. Officially.', inspectMult: 2.0, tariffMult: 1.5, priceMult: 2.5, supplyMult: 0.2, smugglerBonus: 2.0 },
    lawless: { name: 'Lawless', icon: '', desc: 'No law here. Watch your back.', inspectMult: 0, tariffMult: 0, priceMult: 1.1, supplyMult: 0.8, pirateRisk: 0.15 },
    starving: { name: 'Starving', icon: '', desc: 'They\'ll pay anything. Anything.', inspectMult: 0.3, tariffMult: 0, priceMult: 3.0, supplyMult: 0.1, foodCategory: 'commodity', foodMult: 4.0, reliefRep: 10 },
    flooded: { name: 'Flooded', icon: '', desc: 'Half the docks are underwater. They need everything.', inspectMult: 0.5, tariffMult: 0.5, priceMult: 1.8, supplyMult: 0.4, materialBonus: 1.5 }
},
// SEASONS - 4 distinct seasons with material effects
seasons: {
    calmWinds: { name: 'Calm Winds', icon: '', desc: 'Smooth sailing. Thin margins.', dayStart: 1, dayEnd: 12, stormMult: 0.3, windStrengthBias: -1, priceMult: 1.0, piratesMult: 0.8 },
    tradeWinds: { name: 'Trade Winds', icon: '', desc: 'The lanes are open. Make your fortune.', dayStart: 13, dayEnd: 30, stormMult: 0.5, windStrengthBias: 1, priceMult: 0.95, piratesMult: 1.0 },
    monsoon: { name: 'Monsoon', icon: '', desc: 'The sea takes what it wants.', dayStart: 31, dayEnd: 50, stormMult: 3.0, windStrengthBias: 2, priceMult: 1.3, piratesMult: 0.6, supplyCostMult: 1.5 },
    doldrums: { name: 'Doldrums', icon: '', desc: 'Still water. Restless crews. Patience.', dayStart: 51, dayEnd: 60, stormMult: 0.2, windStrengthBias: -2, priceMult: 1.1, piratesMult: 1.2, speedMult: 0.7 }
},
// MOVING ENTITIES for the Drift Map
driftEntities: {
    stormFront: { name: 'Storm Front', icon: '', color: '#4a8a9a', speed: 8, lifetime: 10, encounterType: 'storm' },
    pirateFleet: { name: 'Pirate Fleet', icon: '', color: '#8b2500', speed: 5, lifetime: 15, encounterType: 'pirateFleet', dangerRadius: 40 },
    navyConvoy: { name: 'Navy Convoy', icon: '', color: '#c41e3a', speed: 4, lifetime: 20, encounterType: 'convoy', inspectRadius: 50 },
    floatingMarket: { name: 'Floating Market', icon: '', color: '#c9a227', speed: 3, lifetime: 8, encounterType: 'market', interactRadius: 30 },
    merchantFleet: { name: 'Merchant Fleet', icon: '', color: '#1e4d2b', speed: 4, lifetime: 12, encounterType: 'merchants' }
},
// RUMOR TEMPLATES
rumorTemplates: [
    { template: 'Navy\'s hunting something big near {island}.', type: 'convoy', accuracy: 0.8 },
    { template: '{island} hasn\'t seen a supply ship in weeks.', type: 'shortage', accuracy: 0.85 },
    { template: 'Floating market was seen drifting toward {direction}.', type: 'market', accuracy: 0.7 },
    { template: 'Storm season\'s coming earlyold sailors feel it.', type: 'weather', accuracy: 0.6 },
    { template: 'The Company\'s convoy left {island} heavy-laden.', type: 'convoy', accuracy: 0.75 },
    { template: 'Pirates took three ships near {island}.', type: 'pirates', accuracy: 0.9 },
    { template: 'Merchant named Voss made a fortune in {good} last week.', type: 'price', accuracy: 0.7 },
    { template: 'I wouldn\'t trust anything you hear in {island}.', type: 'meta', accuracy: 1.0 },
    { template: '{island} is paying triple for {good}.', type: 'price', accuracy: 0.65 },
    { template: 'The {faction} are cracking down on smugglers.', type: 'crackdown', accuracy: 0.8 },
    { template: 'Heard there\'s a blockade forming around {island}.', type: 'blockade', accuracy: 0.75 },
    { template: 'Plague ship spotted near {island}. Stay clear.', type: 'danger', accuracy: 0.85 },
    { template: '{cove_hint}', type: 'cove', accuracy: 0.9 }
],
// SEASONAL EVENTS - 10 major events
seasonalEvents: [
    { id: 'crimson_tide', name: 'The Crimson Tide', desc: 'Fishing collapsed; food prices spike everywhere', season: 'monsoon', duration: 6, effects: { commodity: 1.8, luxury: 1.0, contraband: 1.1 } },
    { id: 'embargo', name: 'Embargo Declared', desc: 'Two factions at war; convoys double, inspections triple', season: 'any', duration: 8, effects: { inspectMult: 3.0, convoySpawn: 2.0 } },
    { id: 'ghost_fleet', name: 'The Ghost Fleet', desc: 'Pirate armada appears; southern waters deadly', season: 'doldrums', duration: 10, effects: { pirateSpawn: 3.0, piratesMult: 2.0 } },
    { id: 'harvest_glut', name: 'Harvest Glut', desc: 'Food prices crash; luxury demand explodes', season: 'calmWinds', duration: 5, effects: { commodity: 0.6, luxury: 1.5 } },
    { id: 'great_race', name: 'The Great Race', desc: 'First merchant to reach destination wins big', season: 'tradeWinds', duration: 4, effects: { raceBonus: 5.0 } },
    { id: 'plague_ship', name: 'Plague Ship', desc: 'One port quarantined; medicine worth fortunes', season: 'any', duration: 7, effects: { quarantine: true, medicineMult: 3.0 } },
    { id: 'kings_wedding', name: 'The King\'s Wedding', desc: 'Luxury goods worth 3x at capital', season: 'calmWinds', duration: 5, effects: { luxury: 3.0, destination: 'portRoyal' } },
    { id: 'hurricane_season', name: 'Hurricane Season', desc: 'Storms cluster and strengthen; damage doubled', season: 'monsoon', duration: 8, effects: { stormMult: 2.0, stormDamage: 2.0 } },
    { id: 'mutiny_wave', name: 'The Mutiny Wave', desc: 'Random crew events more common', season: 'doldrums', duration: 6, effects: { crewEvents: 2.0, supplyCost: 1.5 } },
    { id: 'free_trade', name: 'Free Trade Week', desc: 'All tariffs suspended; inspections halved', season: 'tradeWinds', duration: 5, effects: { tariffMult: 0, inspectMult: 0.5 } }
],
settings: {
startingGold: 1000, startingSupplies: 30, baseCargoCapacity: 50, baseShipSpeed: 1.0,
baseSupplyRate: 1, dockDistance: 35, islandCollisionRadius: 25,
pirateEncounterChance: 0.08, windChangeDays: 5,
heatDecayPerDay: 2, heatGainContraband: 8, heatGainDockEnglishEITC: 5,
highMarginThreshold: 15, // minimum profit/weight to glow
maxActiveContracts: 3, contractBoardSize: 5, contractRefreshDays: 3,
seasonCycleDays: 60, // Full year cycle (4 seasons)
crackdownDecayPerDay: 2, crackdownMaxLevel: 100,
// Living Sea settings
maxDriftEntities: 8, driftEntitySpawnChance: 0.12, rumorRefreshDays: 2, maxRumorsPerPort: 4,
portStateChangeChance: 0.08, reliefRunThreshold: 10
},
// ==================== BALANCE TUNING ====================
// All balance values in one place for easy adjustment.
//
// === BALANCE PATCH v1.0 - TUNING TABLE ===
//
// SYSTEM                  | VALUE              | RANGE      | EFFECT
// ----------------------- | ------------------ | ---------- | ---------------------------------
// Power Score             |                    |            | Tracks player progression
//   goldWeight            | 0.0005             | 0.0001-0.001 | Higher = gold matters more
//   cargoWeight           | 0.001              | 0.0005-0.005 | Higher = cargo value matters more
//   upgradeWeight         | 200                | 100-500    | Points per upgrade
//   titleWeight           | 50                 | 25-100     | Points per title tier
//   daysWeight            | 2                  | 1-5        | Points per day survived
//   contractsWeight       | 10                 | 5-25       | Points per completed contract
//
// Power Thresholds        |                    |            | Game phase boundaries
//   mid                   | 500                | 300-800    | Early->mid transition
//   late                  | 1500               | 1000-2500  | Mid->late transition
//   endgame               | 3000               | 2000-5000  | Late->endgame transition
//
// Upkeep (gold sinks)     |                    |            | Reduces hoarding
//   crewWagesPerDay       | 3                  | 1-10       | Base daily cost
//   maintenancePerDay     | 2                  | 1-5        | Ship maintenance
//   dockingFee            | 25                 | 10-50      | Per-port cost
//   dockingFeeHostile     | 50                 | 25-100     | Extra for hostile ports
//
// Anti-Spam               |                    |            | Prevents trade loops
//   tradeFatigue.perVisit | 10                 | 5-20       | Trades before penalty
//   tradeFatigue.penalty  | 0.03               | 0.01-0.1   | Price penalty per excess trade
//   bulkTrade.threshold   | 5                  | 3-10       | Units before bulk penalty
//   portVisit.minDays     | 2                  | 1-5        | Days for cooldown reset
//
// Smuggling               |                    |            | Contraband risk/reward
//   heatGainBase          | 12                 | 5-20       | Heat per transaction
//   heatGainPerUnit       | 2                  | 1-5        | Additional heat per unit
//   fenceLimit            | 10                 | 5-20       | Max units per port visit
//   inspectionBaseChance  | 0.08               | 0.03-0.15  | Base inspection chance
//
// Bounty System           |                    |            | Escalating consequences
//   baseGainPerCrime      | 50                 | 25-100     | Bounty per major crime
//   bountyDecayPerDay     | 5                  | 2-15       | Daily decay rate
//   wanted threshold      | 100                | 50-200     | First notoriety tier
//   hunted threshold      | 300                | 200-500    | Second tier
//   infamous threshold    | 600                | 400-1000   | Maximum tier
//
// Encounter Scaling       |                    |            | Power-based difficulty
//   pirateStrengthBase    | 0.1                | 0.05-0.2   | Base tribute %
//   pirateFightWinBase    | 0.5                | 0.3-0.7    | Base win chance
//   wreckPositiveChance   | 0.7                | 0.5-0.9    | Wreck success rate
//   merchantDiscountMax   | 0.5                | 0.3-0.6    | Best merchant discount
//   merchantDiscountMin   | 0.2                | 0.1-0.3    | Worst merchant discount
//
// Contract Balance        |                    |            | Contracts supplement trading
//   delivery.baseReward   | 50                 | 30-80      | Down from 100 - lose goods profit
//   smuggling.baseReward  | 100                | 60-150     | Down from 200 - high risk
//   courier.baseReward    | 25                 | 15-40      | Down from 80 - requires 30% deposit
//   supply.baseReward     | 20                 | 10-35      | Down from 60 - costs 8 supplies
//   faction.baseReward    | 15                 | 10-25      | Down from 50 - rep-focused
//
// Contract Reputation      |                    |            | Rep should match difficulty
//   delivery.repReward    | 2                  | 1-3        | Down from 5 - routine work
//   smuggling.repReward   | -5                 | -3 to -8   | Penalty stays - illegal
//   courier.repReward     | 2                  | 1-3        | Down from 5 - just travel
//   supply.repReward      | 2                  | 1-3        | Down from 3 - minor help
//   faction.repReward     | 5                  | 3-8        | Down from 12 - was way too high
//
// Progression Scaling     |                    |            | Anti-snowball
//   contractRewardMin     | 0.7                | 0.5-0.9    | Min reward multiplier
//   upgradeCostMax        | 2.0                | 1.5-3.0    | Max cost multiplier
//
// === END TUNING TABLE ===

balance: {
    // === PLAYER POWER SCORE WEIGHTS ===
    // Used to calculate overall player strength for scaling
    powerScore: {
        goldWeight: 0.0005,        // 1 point per 2000 gold (range: 0.0001-0.001)
        cargoWeight: 0.001,        // 1 point per 1000 cargo value (range: 0.0005-0.005)
        upgradeWeight: 200,        // Points per upgrade owned (range: 100-500)
        titleWeight: 50,           // Points per title tier (range: 25-100)
        daysWeight: 2,             // Points per day survived (range: 1-5)
        contractsWeight: 10        // Points per completed contract (range: 5-25)
    },
    // Power thresholds for game phases
    powerThresholds: {
        early: 0,      // 0-500 power: early game
        mid: 500,      // 500-1500: mid game
        late: 1500,    // 1500-3000: late game
        endgame: 3000  // 3000+: endgame
    },

    // === ECONOMY CONTROLS ===
    upkeep: {
        enabled: true,
        crewWagesPerDay: 3,        // Base gold per day for crew
        crewWagesPerUpgrade: 1,    // Additional per upgrade owned
        maintenancePerDay: 2,      // Ship maintenance per day
        dockingFee: 25,            // Fee to dock at any port
        dockingFeeHostile: 50      // Additional fee at hostile ports
    },
    demandSaturation: {
        enabled: true,
        decayRate: 0.15,           // Price drops 15% per unit sold above threshold
        threshold: 5,              // Units sold before saturation kicks in
        recoveryPerDay: 2,         // Units of saturation that recover per day
        maxPenalty: 0.5            // Minimum price multiplier (50% of base)
    },
    tradeCooldown: {
        enabled: true,
        sameGoodPenalty: 0.05,     // 5% less profit per repeated same-good trade
        maxPenalty: 0.3,           // Max 30% penalty for repeated trades
        decayPerDay: 0.1           // Penalty decays 10% per day
    },
    bulkTrade: {
        enabled: true,
        threshold: 5,              // Units before bulk penalty kicks in
        penaltyPerUnit: 0.02,      // 2% worse price per unit above threshold
        maxPenalty: 0.3            // Max 30% penalty for bulk trades
    },
    portVisitCooldown: {
        enabled: true,
        minDaysBetween: 2,         // Minimum days between visits for full prices
        penaltyPerEarlyDay: 0.1,   // 10% penalty per day early
        maxPenalty: 0.2            // Max 20% penalty for visiting too soon
    },
    tradeFatigue: {
        enabled: true,
        transactionsPerVisit: 10,  // After N trades, prices worsen
        penaltyPerTrade: 0.03,     // 3% worse per trade after limit
        maxPenalty: 0.25           // Max 25% penalty from fatigue
    },

    // === SMUGGLING BALANCE ===
    smuggling: {
        heatGainBase: 12,          // Heat per contraband transaction (up from 8)
        heatGainPerUnit: 2,        // Additional heat per unit traded
        heatDecayBase: 1,          // Base decay per day (down from 2)
        heatDecayAtSea: 0.5,       // Reduced decay while at sea
        fenceLimit: 10,            // Max contraband units per port per visit
        fenceLimitDecayDays: 5,    // Days for fence limit to reset
        priceDropPerUnit: 0.03,    // 3% price drop per unit sold to fence
        inspectionBaseChance: 0.08, // Increased base inspection chance
        inspectionHeatMult: 1.5    // Heat multiplier for inspection chance
    },

    // === BOUNTY/NOTORIETY SYSTEM ===
    bounty: {
        enabled: true,
        baseGainPerCrime: 50,      // Gold bounty per major infraction
        contrabandBounty: 10,      // Per contraband unit when caught
        fleeingBounty: 25,         // Bounty for fleeing inspection
        bountyDecayPerDay: 5,      // Bounty decay per day
        bountyDecayDocked: 10,     // Faster decay when docked at friendly port
        // Bounty thresholds trigger different responses
        thresholds: {
            wanted: 100,           // Inspections more frequent
            hunted: 300,           // Navy actively seeks you
            infamous: 600          // Bounty hunters appear
        },
        // Bounty affects tribute demands
        tributeBountyMult: 0.002   // +0.2% tribute per bounty point
    },

    // === ENCOUNTER SCALING ===
    encounters: {
        pirateStrengthBase: 0.1,   // Base tribute % of gold
        pirateStrengthPower: 0.0001, // Additional % per power point
        pirateMinTribute: 50,      // Minimum tribute
        pirateFightWinBase: 0.5,   // Base fight win chance
        pirateFightWinPenalty: 0.05, // Reduced by this per power tier
        pirateLootBase: 50,        // Base loot from winning
        pirateLootPowerMult: 0.02, // Loot scales slightly with power
        wreckPositiveChance: 0.7,  // Down from 90% positive
        merchantDiscountMax: 0.5,  // Merchant discount capped at 50%
        merchantDiscountMin: 0.2   // Min discount (gets worse with power)
    },

    // === PROGRESSION SCALING ===
    progression: {
        contractRewardBase: 1.0,        // Base multiplier
        contractRewardPowerMult: -0.0001, // Slight decrease per power point
        contractRewardMin: 0.7,         // Minimum 70% of base reward
        upgradeCostPowerMult: 0.0005,   // Upgrades cost more as power grows
        upgradeCostMax: 2.0,            // Max 2x base cost
        titleBonusDecay: 0.9            // Each title tier bonus is 90% of previous
    },

    // === DIFFICULTY SCALING ===
    difficulty: {
        inspectionPowerMult: 0.0002,  // Inspection chance increases with power
        piratePowerMult: 0.0001,      // Pirate encounter rate scales
        stormPowerMult: 0,            // Storms don't scale (nature doesn't care)
        priceVolatilityPower: 0.0001, // Markets more volatile at high power
        maxScaling: 2.0               // Cap on any scaling multiplier
    }
},

// ==================== META PRESSURE SYSTEM ====================
// Detects and softly punishes repetitive "meta" behavior patterns
// Makes the world feel alive and responsive to player strategies
metaPressure: {
    enabled: true,
    windowSize: 30,                    // Number of recent events to track
    decayPerDay: 0.02,                 // Bias scores decay 2% per day with variety

    // Thresholds - if top item share exceeds this, bias starts building
    thresholds: {
        route: 0.30,                   // 30% of routes are same = starts bias
        good: 0.35,                    // 35% of trades are same good
        port: 0.30,                    // 30% of visits to same port
        faction: 0.45                  // 45% of interactions in same faction's territory
    },

    // Effect caps - maximum additional penalties from meta pressure
    caps: {
        pirateChance: 0.25,            // +25% max pirate encounter chance
        stormChance: 0.20,             // +20% max storm chance on route
        priceReduction: 0.20,          // -20% max sell price for oversold good
        saturationMult: 1.5,           // 1.5x faster market saturation
        dockFeeIncrease: 0.30,         // +30% max dock fee at over-visited ports
        inspectionChance: 0.15         // +15% max inspection chance
    },

    // Milestones for player feedback (as pressure crosses these values)
    feedbackMilestones: [0.3, 0.5, 0.7, 0.9],

    // Flavor text for world adaptation notifications
    flavorText: {
        route: {
            rising: [
                'Pirates have noted your regular course...',
                'Lookouts report ships watching your usual lanes.',
                'Your route has become... predictable.'
            ],
            peak: [
                'Every pirate on the sea knows where to find you.',
                'Your lanes are crawling with opportunists.',
                'The seas grow dangerous along your path.'
            ]
        },
        good: {
            rising: [
                'Markets are flooded with your preferred cargo...',
                'Merchants grumble about your saturation tactics.',
                'Supply is catching up with your demand.'
            ],
            peak: [
                'Nobody wants more of what you\'re selling.',
                'The market groans under the weight of your goods.',
                'Buyers scatter when they see your sail.'
            ]
        },
        port: {
            rising: [
                'Dock fees are rising at your favorite port...',
                'Officials grow suspicious of your frequent visits.',
                'The harbormaster knows you by name now.'
            ],
            peak: [
                'They\'ve learned all your tricks here.',
                'Every official has their hand out when you dock.',
                'Perhaps try a different port for a while.'
            ]
        },
        faction: {
            rising: [
                'The authorities have noticed your patterns...',
                'Patrols are being redirected to watch you.',
                'Your activities have drawn official attention.'
            ],
            peak: [
                'They\'ve assigned someone to track your movements.',
                'The crackdown intensifies wherever you sail.',
                'Perhaps diversify your allegiances.'
            ]
        }
    }
},

// ==================== LIVING SEA UPDATE CONFIG ====================
// Save version for migration
saveVersion: 2,

// Ship Classes - distinct vessel types with different characteristics
shipClasses: {
    sloop: {
        name: 'Sloop',
        icon: '',
        desc: 'Fast and nimble. Perfect for quick runs and escapes.',
        baseSpeed: 1.3,
        cargoCapacity: 35,
        hullMax: 80,
        riggingMax: 100,
        repairCostMult: 0.7,
        upkeepMult: 0.6,
        escapeBonus: 0.25,
        chaseSpeedBonus: 0.2,
        cost: 0 // Starting class
    },
    brigantine: {
        name: 'Brigantine',
        icon: '',
        desc: 'Balanced trader. Good capacity with decent speed.',
        baseSpeed: 1.0,
        cargoCapacity: 50,
        hullMax: 100,
        riggingMax: 100,
        repairCostMult: 1.0,
        upkeepMult: 1.0,
        escapeBonus: 0,
        chaseSpeedBonus: 0,
        cost: 1500
    },
    galleon: {
        name: 'Galleon',
        icon: '',
        desc: 'Massive cargo hauler. Slow but tough.',
        baseSpeed: 0.7,
        cargoCapacity: 80,
        hullMax: 150,
        riggingMax: 80,
        repairCostMult: 1.5,
        upkeepMult: 1.8,
        escapeBonus: -0.2,
        chaseSpeedBonus: -0.15,
        cost: 4000
    }
},

// Officers - crew members with perks and drawbacks
officers: {
    quartermaster: {
        name: 'Quartermaster',
        role: 'quartermaster',
        icon: '',
        perk: 'Reduces upkeep by 25% and cargo loss by 30%',
        drawback: 'Demands higher wage',
        effects: { upkeepMult: 0.75, cargoProtection: 0.3 },
        baseWage: 8,
        rarity: 'common'
    },
    navigator: {
        name: 'Navigator',
        role: 'navigator',
        icon: '',
        perk: 'Reveals wind predictions and reduces travel time',
        drawback: 'Requires expensive charts',
        effects: { windPrediction: true, speedBonus: 0.1 },
        baseWage: 10,
        rarity: 'uncommon'
    },
    gunner: {
        name: 'Master Gunner',
        role: 'gunner',
        icon: '',
        perk: '+30% combat win chance, +20% boarding loot',
        drawback: 'Increases maintenance costs',
        effects: { combatBonus: 0.3, lootBonus: 0.2, maintenanceMult: 1.25 },
        baseWage: 12,
        rarity: 'uncommon'
    },
    smuggler: {
        name: 'Smuggler Contact',
        role: 'smuggler',
        icon: '',
        perk: '-40% inspection chance, +15% fence prices',
        drawback: 'Increases heat gain',
        effects: { inspectionReduction: 0.4, fenceBonus: 0.15, heatMult: 1.3 },
        baseWage: 15,
        rarity: 'rare'
    },
    surgeon: {
        name: 'Ship Surgeon',
        role: 'surgeon',
        icon: '',
        perk: 'Crew morale recovers faster, +5 max morale',
        drawback: 'Requires medical supplies',
        effects: { moraleRecovery: 1.5, maxMoraleBonus: 5, supplyCostExtra: 0.5 },
        baseWage: 10,
        rarity: 'uncommon'
    },
    bosun: {
        name: 'Bosun',
        role: 'bosun',
        icon: '',
        perk: 'Ship repairs are 30% cheaper, rigging wear -20%',
        drawback: 'Strict discipline affects morale',
        effects: { repairDiscount: 0.3, riggingWearMult: 0.8, moralePenalty: 5 },
        baseWage: 8,
        rarity: 'common'
    }
},

// Hidden Coves - discoverable locations
hiddenCoves: {
    smugglersReef: {
        name: "Smuggler's Reef",
        icon: '',
        desc: 'A hidden cove where smugglers fence goods off the books.',
        type: 'fence',
        position: { x: -200, z: 100 },
        services: ['fence', 'rumors'],
        discoveryHint: 'Pirates whisper of a reef where the Navy never looks...'
    },
    wreckersHaven: {
        name: "Wrecker's Haven",
        icon: '',
        desc: 'Wreckers have salvaged treasures from countless ships.',
        type: 'salvage',
        position: { x: 180, z: -120 },
        services: ['salvage', 'charts'],
        discoveryHint: 'Old sailors speak of lights that lure ships to their doom...'
    },
    healersIsle: {
        name: "Healer's Isle",
        icon: '',
        desc: 'A remote sanctuary where ships can repair cheaply.',
        type: 'repair',
        position: { x: -50, z: -180 },
        services: ['repair', 'rest'],
        discoveryHint: 'They say there is an island where even the most battered ship can be made whole...'
    },
    piratesCache: {
        name: "Blackbeard's Cache",
        icon: '',
        desc: 'Legendary pirate treasure, if you can find it.',
        type: 'treasure',
        position: { x: 220, z: 150 },
        services: ['treasure'],
        discoveryHint: 'The map speaks of gold buried where the sun sets on the third day...'
    }
},

// Questlines - tiered progression system (complete tier to unlock next)
// Anti-cheese: goods must be acquired AFTER starting the questline
questlines: {
    // === TIER 1: Starter questlines (available immediately) ===
    courier_run: {
        id: 'courier_run',
        name: 'Courier Run',
        icon: '',
        desc: 'A simple delivery job to prove your reliability.',
        faction: 'neutral',
        tier: 1,
        steps: [
            { type: 'deliver_count', goods: { timber: 2 }, to: 'kingston', count: 2, reward: 25, desc: 'Deliver timber to Kingston' },
            { type: 'collect', at: 'portRoyal', desc: 'Collect payment at Port Royal' }
        ],
        rewards: { gold: 100, reputation: { english: 3, eitc: 2 } },
        deadline: 20
    },
    rum_runner: {
        id: 'rum_runner',
        name: 'Rum Runner',
        icon: '',
        desc: 'The pirates need supplies. Keep it quiet.',
        faction: 'pirates',
        tier: 1,
        steps: [
            { type: 'deliver_count', goods: { rum: 3 }, to: 'tortuga', count: 2, reward: 30, desc: 'Deliver rum to Tortuga' },
            { type: 'collect', at: 'nassau', desc: 'Collect payment at Nassau' }
        ],
        rewards: { gold: 120, reputation: { pirates: 5 } },
        deadline: 20
    },
    company_errand: {
        id: 'company_errand',
        name: 'Company Errand',
        icon: '',
        desc: 'The Trading Company needs a reliable courier.',
        faction: 'eitc',
        tier: 1,
        steps: [
            { type: 'deliver_count', goods: { spices: 2 }, to: 'havana', count: 2, reward: 35, desc: 'Deliver spices to Havana' },
            { type: 'collect', at: 'barbados', desc: 'Collect payment at Barbados' }
        ],
        rewards: { gold: 130, reputation: { eitc: 5, english: 2 } },
        deadline: 20
    },

    // === TIER 2: Unlocked after completing any Tier 1 ===
    relief_effort: {
        id: 'relief_effort',
        name: 'The Relief Effort',
        icon: '',
        desc: 'Help struggling ports by delivering essential supplies.',
        faction: 'neutral',
        tier: 2,
        requires: 1, // Requires 1 tier-1 completion
        steps: [
            { type: 'deliver_count', goods: { timber: 3, iron: 2 }, to: 'kingston', count: 3, reward: 40, desc: 'Deliver supplies to Kingston' },
            { type: 'collect', at: 'portRoyal', desc: 'Collect payment at Port Royal' }
        ],
        rewards: { gold: 250, reputation: { english: 8, eitc: 5 }, title: 'Benefactor' },
        deadline: 25
    },
    smuggling_ring: {
        id: 'smuggling_ring',
        name: 'The Smuggling Ring',
        icon: '',
        desc: 'Run contraband for the pirate network.',
        faction: 'pirates',
        tier: 2,
        requires: 1,
        steps: [
            { type: 'deliver_count', goods: { gunpowder: 4 }, to: 'tortuga', count: 2, reward: 60, desc: 'Smuggle gunpowder to Tortuga' },
            { type: 'deliver_count', goods: { gunpowder: 4 }, to: 'nassau', count: 2, reward: 60, desc: 'Smuggle gunpowder to Nassau' },
            { type: 'collect', at: 'tortuga', desc: 'Collect payment at Tortuga' }
        ],
        rewards: { gold: 350, reputation: { pirates: 10 } },
        deadline: 30
    },
    trading_company: {
        id: 'trading_company',
        name: 'Company Contract',
        icon: '',
        desc: 'Establish yourself as a Trading Company supplier.',
        faction: 'eitc',
        tier: 2,
        requires: 1,
        steps: [
            { type: 'deliver_count', goods: { tea: 2, spices: 2 }, to: 'havana', count: 3, reward: 50, desc: 'Supply luxuries to Havana' },
            { type: 'collect', at: 'havana', desc: 'Collect bonus at Havana' }
        ],
        rewards: { gold: 300, reputation: { eitc: 10, english: 5 } },
        deadline: 28
    },

    // === TIER 3: Unlocked after completing any Tier 2 ===
    crown_service: {
        id: 'crown_service',
        name: 'Crown Service',
        icon: '',
        desc: 'Prove your loyalty to the Crown through naval supply runs.',
        faction: 'english',
        tier: 3,
        requires: 2,
        steps: [
            { type: 'deliver_count', goods: { iron: 4, timber: 4 }, to: 'portRoyal', count: 3, reward: 50, desc: 'Deliver naval supplies to Port Royal' },
            { type: 'deliver_count', goods: { gunpowder: 3 }, to: 'kingston', count: 2, reward: 60, desc: 'Supply munitions to Kingston' },
            { type: 'collect', at: 'portRoyal', desc: 'Receive Royal commendation' }
        ],
        rewards: { gold: 500, reputation: { english: 15, pirates: -10 }, pardon: true, title: 'Privateer' },
        deadline: 35
    },
    pirate_lord: {
        id: 'pirate_lord',
        name: 'Pirate Lord\'s Favor',
        icon: '',
        desc: 'Arm the pirate fleet for a major operation.',
        faction: 'pirates',
        tier: 3,
        requires: 2,
        steps: [
            { type: 'deliver_count', goods: { gunpowder: 6, iron: 4 }, to: 'tortuga', count: 3, reward: 80, desc: 'Arm Tortuga' },
            { type: 'deliver_count', goods: { gunpowder: 6, iron: 4 }, to: 'nassau', count: 3, reward: 80, desc: 'Arm Nassau' },
            { type: 'collect', at: 'tortuga', desc: 'Receive the Pirate Lord\'s blessing' }
        ],
        rewards: { gold: 600, reputation: { pirates: 20, english: -15, eitc: -10 }, unlocks: 'smugglersReef', title: 'Smuggler King' },
        deadline: 40
    },
    merchant_prince: {
        id: 'merchant_prince',
        name: 'Merchant Prince',
        icon: '',
        desc: 'Become the premier luxury goods supplier in the Caribbean.',
        faction: 'eitc',
        tier: 3,
        requires: 2,
        steps: [
            { type: 'deliver_count', goods: { silk: 3, tea: 3 }, to: 'havana', count: 3, reward: 70, desc: 'Supply Havana\'s elite' },
            { type: 'deliver_count', goods: { spices: 4, silk: 2 }, to: 'cartagena', count: 2, reward: 80, desc: 'Exclusive Cartagena delivery' },
            { type: 'collect', at: 'havana', desc: 'Receive your merchant charter' }
        ],
        rewards: { gold: 700, reputation: { eitc: 18, english: 8 }, title: 'Merchant Prince' },
        deadline: 40
    }
},

// Ship Condition tuning
shipCondition: {
    // Wear rates per day at sea
    hullWearBase: 0.5,
    hullWearStorm: 5,
    hullWearOverload: 2,
    riggingWearBase: 0.3,
    riggingWearStorm: 3,
    riggingWearHighWind: 1,
    moraleWearBase: 0.5,
    moraleDoldrumsExtra: 2,
    moraleLowSuppliesExtra: 3,

    // Thresholds for penalties
    criticalThreshold: 30,
    warningThreshold: 50,

    // Effects of low condition
    lowHullSinkChance: 0.05,      // Per storm at hull < 30
    lowHullRepairPenalty: 0.5,    // Sea repairs 50% less effective
    lowRiggingSpeedPenalty: 0.3,  // -30% speed at rigging < 30
    lowRiggingEscapePenalty: 0.25, // -25% escape chance
    lowMoraleEncounterBonus: 0.2, // +20% encounter chance
    lowMoraleMutinyChance: 0.02,  // Per day at morale < 30

    // Repair costs (gold per point)
    dockRepairCostHull: 3,
    dockRepairCostRigging: 2,
    dockRestCost: 15,
    seaRepairCostSupplies: 1,     // Supplies per 5 points

    // Recovery rates
    dockRepairRate: 20,           // Points per rest action
    seaRepairRate: 10,
    dockMoraleRecovery: 15
},

// Chase encounter system
chase: {
    baseDuration: 15000,          // 15 seconds
    minDuration: 10000,
    maxDuration: 20000,
    baseEscapeChance: 0.5,
    windSpeedFactor: 0.15,
    cargoWeightPenalty: 0.005,    // Per cargo unit
    riggingFactor: 0.003,         // Per rigging point
    hazardChance: 0.15,
    hazardTypes: ['rocks', 'storm', 'shallows'],
    jukeCooldown: 3000,
    jukeBonus: 0.1
},

// Bounty hunters and pardon
bountyHunters: {
    // Named hunters that appear at infamous level
    hunters: [
        { name: 'Captain Blackwood', icon: '', strength: 1.2, reward: 200 },
        { name: 'The Iron Maiden', icon: '', strength: 1.5, reward: 350 },
        { name: 'Admiral Graves', icon: '', strength: 2.0, reward: 500 }
    ],
    // Hunter encounter chance per day at sea (by tier)
    encounterChance: {
        wanted: 0,
        hunted: 0.03,
        infamous: 0.08
    },
    // Pardon costs by port type
    pardonCosts: {
        english: { base: 500, perBounty: 2 },
        eitc: { base: 400, perBounty: 1.5 },
        neutral: { base: 800, perBounty: 3 }
    }
},

// Faction war fronts
warFronts: {
    // Island influence change per event
    influencePerTrade: 0.5,
    influencePerQuest: 5,
    influencePerSmuggle: -2,
    stabilityRecoveryPerDay: 0.5,
    blockadeDuration: 5,
    warZoneDuration: 8,
    controlThreshold: 60  // Faction needs 60%+ influence to control
},

// Debug toggles
debug: {
    enabled: false,
    logWear: false,
    logChase: false,
    logBounty: false,
    logQuests: false,
    skipChase: false
}
};

const WIND_DIRS = [
{ name: 'N', angle: 0, v: { x: 0, z: -1 } }, { name: 'NE', angle: 45, v: { x: 0.7, z: -0.7 } },
{ name: 'E', angle: 90, v: { x: 1, z: 0 } }, { name: 'SE', angle: 135, v: { x: 0.7, z: 0.7 } },
{ name: 'S', angle: 180, v: { x: 0, z: 1 } }, { name: 'SW', angle: 225, v: { x: -0.7, z: 0.7 } },
{ name: 'W', angle: 270, v: { x: -1, z: 0 } }, { name: 'NW', angle: 315, v: { x: -0.7, z: -0.7 } }
];
const WIND_STR = [{ name: 'Calm', m: 0 }, { name: 'Light', m: 0.15 }, { name: 'Moderate', m: 0.25 }, { name: 'Strong', m: 0.4 }];

// ==================== PLAYER POWER SCORE SYSTEM ====================
// Calculates overall player strength for difficulty scaling
function getPlayerPower(gs) {
    const ps = CONFIG.balance.powerScore;
    let power = 0;

    // Wealth contribution
    power += (gs.player.gold || 0) * ps.goldWeight;

    // Cargo value (use base prices to avoid circular dependency)
    let cargoValue = 0;
    Object.entries(gs.player.cargo || {}).forEach(([gid, qty]) => {
        cargoValue += (CONFIG.goods[gid]?.basePrice || 0) * qty;
    });
    power += cargoValue * ps.cargoWeight;

    // Upgrades owned
    const upgradeCount = Object.keys(gs.player.upgrades || {}).filter(k => gs.player.upgrades[k]).length;
    power += upgradeCount * ps.upgradeWeight;

    // Title tiers (sum across all tracks)
    let totalTiers = 0;
    Object.keys(CONFIG.titles).forEach(trackId => {
        totalTiers += getTitleTierSafe(trackId, gs);
    });
    power += totalTiers * ps.titleWeight;

    // Days survived
    power += (gs.player.days || 1) * ps.daysWeight;

    // Contracts completed
    power += (gs.player.stats?.contractsCompleted || 0) * ps.contractsWeight;

    return Math.floor(power);
}

// Safe title tier lookup that doesn't cause circular dependency
function getTitleTierSafe(trackId, gs) {
    const track = CONFIG.titles[trackId];
    if (!track) return 0;
    let value = 0;
    switch (trackId) {
        case 'merchant': value = (gs.player.gold || 0); break; // Simplified, no cargo
        case 'smuggler': value = gs.player.stats?.contrabandTraded || 0; break;
        case 'voyager': value = gs.player.days || 0; break;
    }
    let tier = 0;
    for (let i = 0; i < track.thresholds.length; i++) {
        if (value >= track.thresholds[i]) tier = i + 1;
        else break;
    }
    return tier;
}

// Returns game phase: 'early', 'mid', 'late', 'endgame'
function getGamePhase(gs) {
    const power = getPlayerPower(gs);
    const t = CONFIG.balance.powerThresholds;
    if (power >= t.endgame) return 'endgame';
    if (power >= t.late) return 'late';
    if (power >= t.mid) return 'mid';
    return 'early';
}

// Get power-scaled multiplier (clamped between min and max)
function getPowerScaling(gs, baseMult, powerMult, min = 0, max = CONFIG.balance.difficulty.maxScaling) {
    const power = getPlayerPower(gs);
    return Math.max(min, Math.min(max, baseMult + power * powerMult));
}

// ==================== BOUNTY SYSTEM ====================
function getBounty(gs) {
    return gs.player.bounty || 0;
}

function addBounty(gs, amount) {
    if (!CONFIG.balance.bounty.enabled) return;
    gs.player.bounty = Math.max(0, (gs.player.bounty || 0) + amount);
}

function decayBounty(gs, isDocked = false, isFriendlyPort = false) {
    if (!CONFIG.balance.bounty.enabled) return;
    const bb = CONFIG.balance.bounty;
    let decay = bb.bountyDecayPerDay;
    if (isDocked && isFriendlyPort) decay = bb.bountyDecayDocked;
    gs.player.bounty = Math.max(0, (gs.player.bounty || 0) - decay);
}

function getBountyLevel(gs) {
    const bounty = getBounty(gs);
    const t = CONFIG.balance.bounty.thresholds;
    if (bounty >= t.infamous) return 'infamous';
    if (bounty >= t.hunted) return 'hunted';
    if (bounty >= t.wanted) return 'wanted';
    return 'clean';
}

// ==================== META PRESSURE SYSTEM ====================
// Detects repetitive player behavior and applies soft adaptive pressure

// Initialize or reset meta pressure for a game state
function metaInit(gs) {
    if (!gs.player.meta) {
        gs.player.meta = {
            recentRoutes: [],
            recentGoods: [],
            recentPorts: [],
            recentFactions: [],
            routeCounts: {},
            goodCounts: {},
            portCounts: {},
            factionCounts: {},
            pressure: { route: 0, good: 0, port: 0, faction: 0, total: 0 },
            lastPort: null,
            lastMilestones: { route: 0, good: 0, port: 0, faction: 0 },
            lastUpdateDay: 0
        };
    }
    return gs.player.meta;
}

// Helper: clamp value between 0 and 1
function clamp01(v) { return Math.max(0, Math.min(1, v)); }

// Helper: add to rolling window and maintain frequency counts
function metaAddToWindow(arr, counts, value, maxSize) {
    arr.push(value);
    counts[value] = (counts[value] || 0) + 1;

    // Trim window to max size
    while (arr.length > maxSize) {
        const removed = arr.shift();
        counts[removed]--;
        if (counts[removed] <= 0) delete counts[removed];
    }
}

// Helper: calculate bias score for a category
function metaCalcBias(counts, threshold, windowLen) {
    if (windowLen === 0) return 0;

    // Find top item share
    let topCount = 0;
    for (const key in counts) {
        if (counts[key] > topCount) topCount = counts[key];
    }

    const topShare = topCount / windowLen;

    // If under threshold, no bias
    if (topShare <= threshold) return 0;

    // Scale from threshold to 1.0
    return clamp01((topShare - threshold) / (1 - threshold));
}

// Helper: get the most frequent item in a counts object
function metaGetTopItem(counts) {
    let topItem = null, topCount = 0;
    for (const key in counts) {
        if (counts[key] > topCount) {
            topCount = counts[key];
            topItem = key;
        }
    }
    return topItem;
}

// Record a route (called when player docks at a new port)
function metaRecordRoute(gs, fromPort, toPort) {
    if (!CONFIG.metaPressure.enabled) return;
    const meta = metaInit(gs);

    // Create route key (normalized: alphabetical order for bidirectional routes)
    const routeKey = [fromPort, toPort].sort().join('>');

    metaAddToWindow(
        meta.recentRoutes,
        meta.routeCounts,
        routeKey,
        CONFIG.metaPressure.windowSize
    );

    // Also record the destination port
    const island = CONFIG.islands[toPort];
    if (island) {
        metaAddToWindow(
            meta.recentPorts,
            meta.portCounts,
            toPort,
            CONFIG.metaPressure.windowSize
        );

        // Record faction interaction
        metaAddToWindow(
            meta.recentFactions,
            meta.factionCounts,
            island.faction,
            CONFIG.metaPressure.windowSize
        );
    }

    // Update last port for next route calculation
    meta.lastPort = toPort;

    // Recalculate pressures
    metaRecalcPressure(gs);
}

// Record a trade (called when selling goods for profit)
function metaRecordTrade(gs, goodId, profit) {
    if (!CONFIG.metaPressure.enabled) return;
    if (profit <= 0) return; // Only track profitable trades

    const meta = metaInit(gs);

    metaAddToWindow(
        meta.recentGoods,
        meta.goodCounts,
        goodId,
        CONFIG.metaPressure.windowSize
    );

    // Recalculate pressures
    metaRecalcPressure(gs);
}

// Recalculate all pressure scores
function metaRecalcPressure(gs) {
    const meta = metaInit(gs);
    const cfg = CONFIG.metaPressure;

    // Calculate each bias
    meta.pressure.route = metaCalcBias(
        meta.routeCounts,
        cfg.thresholds.route,
        meta.recentRoutes.length
    );

    meta.pressure.good = metaCalcBias(
        meta.goodCounts,
        cfg.thresholds.good,
        meta.recentGoods.length
    );

    meta.pressure.port = metaCalcBias(
        meta.portCounts,
        cfg.thresholds.port,
        meta.recentPorts.length
    );

    meta.pressure.faction = metaCalcBias(
        meta.factionCounts,
        cfg.thresholds.faction,
        meta.recentFactions.length
    );

    // Total is weighted max of individual pressures
    meta.pressure.total = Math.max(
        meta.pressure.route,
        meta.pressure.good,
        meta.pressure.port * 0.8, // Port pressure weighted slightly less
        meta.pressure.faction * 0.7 // Faction pressure weighted less
    );
}

// Daily update: apply decay if player shows variety
function metaUpdateDaily(gs, showToast = null) {
    if (!CONFIG.metaPressure.enabled) return;
    const meta = metaInit(gs);
    const cfg = CONFIG.metaPressure;

    // Only update once per day
    if (meta.lastUpdateDay >= gs.player.days) return;
    meta.lastUpdateDay = gs.player.days;

    // Apply decay to pressure scores (represents world forgetting)
    const decayRate = cfg.decayPerDay;
    meta.pressure.route = Math.max(0, meta.pressure.route - decayRate);
    meta.pressure.good = Math.max(0, meta.pressure.good - decayRate);
    meta.pressure.port = Math.max(0, meta.pressure.port - decayRate);
    meta.pressure.faction = Math.max(0, meta.pressure.faction - decayRate);

    // Recalculate total
    meta.pressure.total = Math.max(
        meta.pressure.route,
        meta.pressure.good,
        meta.pressure.port * 0.8,
        meta.pressure.faction * 0.7
    );

    // Check for milestone notifications
    if (showToast) {
        metaCheckMilestones(gs, showToast);
    }
}

// Check if pressure crossed a milestone and show feedback
function metaCheckMilestones(gs, showToast) {
    const meta = metaInit(gs);
    const cfg = CONFIG.metaPressure;
    const milestones = cfg.feedbackMilestones;

    const categories = ['route', 'good', 'port', 'faction'];

    for (const cat of categories) {
        const pressure = meta.pressure[cat];
        const lastMilestone = meta.lastMilestones[cat] || 0;

        // Find the highest milestone we've crossed
        let crossedMilestone = 0;
        for (const m of milestones) {
            if (pressure >= m && m > lastMilestone) {
                crossedMilestone = m;
            }
        }

        if (crossedMilestone > 0) {
            meta.lastMilestones[cat] = crossedMilestone;

            // Get flavor text
            const texts = cfg.flavorText[cat];
            if (texts) {
                const isHigh = pressure >= 0.7;
                const pool = isHigh ? texts.peak : texts.rising;
                const msg = pool[Math.floor(Math.random() * pool.length)];
                showToast('World Adapts', msg);
            }
        }

        // Reset milestone if pressure drops
        if (pressure < milestones[0] && lastMilestone > 0) {
            meta.lastMilestones[cat] = 0;
        }
    }
}

// Get modifiers based on current meta pressure for game systems
// context: { route: "PortA>PortB", good: "rum", port: "portRoyal", faction: "english" }
function metaGetModifiers(gs, context = {}) {
    if (!CONFIG.metaPressure.enabled) {
        return {
            pirateChanceMult: 1,
            stormChanceMult: 1,
            priceMultSell: 1,
            saturationMult: 1,
            dockFeeMult: 1,
            inspectionChanceMult: 1
        };
    }

    const meta = metaInit(gs);
    const cfg = CONFIG.metaPressure;
    const caps = cfg.caps;

    let mods = {
        pirateChanceMult: 1,
        stormChanceMult: 1,
        priceMultSell: 1,
        saturationMult: 1,
        dockFeeMult: 1,
        inspectionChanceMult: 1
    };

    // Route-based modifiers (pirates and storms on that specific route)
    if (context.route) {
        const routeKey = context.route.includes('>') ? context.route : null;
        if (routeKey && meta.routeCounts[routeKey]) {
            const routeShare = meta.routeCounts[routeKey] / Math.max(1, meta.recentRoutes.length);
            if (routeShare > cfg.thresholds.route) {
                const intensity = clamp01((routeShare - cfg.thresholds.route) / (1 - cfg.thresholds.route));
                mods.pirateChanceMult += intensity * caps.pirateChance;
                mods.stormChanceMult += intensity * caps.stormChance;
            }
        }
    }

    // Good-based modifiers (prices for that good)
    if (context.good && meta.goodCounts[context.good]) {
        const goodShare = meta.goodCounts[context.good] / Math.max(1, meta.recentGoods.length);
        if (goodShare > cfg.thresholds.good) {
            const intensity = clamp01((goodShare - cfg.thresholds.good) / (1 - cfg.thresholds.good));
            mods.priceMultSell -= intensity * caps.priceReduction;
            mods.saturationMult += intensity * (caps.saturationMult - 1);
        }
    }

    // Port-based modifiers (dock fees and inspection at that port)
    if (context.port && meta.portCounts[context.port]) {
        const portShare = meta.portCounts[context.port] / Math.max(1, meta.recentPorts.length);
        if (portShare > cfg.thresholds.port) {
            const intensity = clamp01((portShare - cfg.thresholds.port) / (1 - cfg.thresholds.port));
            mods.dockFeeMult += intensity * caps.dockFeeIncrease;
            mods.inspectionChanceMult += intensity * caps.inspectionChance;
        }
    }

    // Faction-based modifiers (inspection in that faction's territory)
    if (context.faction && meta.factionCounts[context.faction]) {
        const factionShare = meta.factionCounts[context.faction] / Math.max(1, meta.recentFactions.length);
        if (factionShare > cfg.thresholds.faction) {
            const intensity = clamp01((factionShare - cfg.thresholds.faction) / (1 - cfg.thresholds.faction));
            mods.inspectionChanceMult += intensity * caps.inspectionChance * 0.5; // Stacks partially
        }
    }

    return mods;
}

// Get a summary of current meta pressure for UI display
function metaGetSummary(gs) {
    const meta = metaInit(gs);

    // Determine primary pressure type
    const pressures = [
        { type: 'route', value: meta.pressure.route },
        { type: 'good', value: meta.pressure.good },
        { type: 'port', value: meta.pressure.port },
        { type: 'faction', value: meta.pressure.faction }
    ].sort((a, b) => b.value - a.value);

    const primary = pressures[0];

    // Get the top item causing the pressure
    let topItem = null;
    switch (primary.type) {
        case 'route': topItem = metaGetTopItem(meta.routeCounts); break;
        case 'good': topItem = metaGetTopItem(meta.goodCounts); break;
        case 'port': topItem = metaGetTopItem(meta.portCounts); break;
        case 'faction': topItem = metaGetTopItem(meta.factionCounts); break;
    }

    return {
        total: meta.pressure.total,
        primary: primary.type,
        primaryValue: primary.value,
        topItem,
        route: meta.pressure.route,
        good: meta.pressure.good,
        port: meta.pressure.port,
        faction: meta.pressure.faction
    };
}

// ==================== DEMAND SATURATION SYSTEM ====================
function getMarketSaturation(gs, iid, gid) {
    if (!CONFIG.balance.demandSaturation.enabled) return 0;
    return gs.world.saturation?.[iid]?.[gid] || 0;
}

function addMarketSaturation(gs, iid, gid, qty) {
    if (!CONFIG.balance.demandSaturation.enabled) return;
    if (!gs.world.saturation) gs.world.saturation = {};
    if (!gs.world.saturation[iid]) gs.world.saturation[iid] = {};
    // === META PRESSURE: Good bias makes saturation ramp faster ===
    const metaMods = metaGetModifiers(gs, { good: gid });
    const effectiveQty = Math.ceil(qty * metaMods.saturationMult);
    gs.world.saturation[iid][gid] = (gs.world.saturation[iid][gid] || 0) + effectiveQty;
}

function decayMarketSaturation(gs) {
    if (!CONFIG.balance.demandSaturation.enabled || !gs.world.saturation) return;
    const recovery = CONFIG.balance.demandSaturation.recoveryPerDay;
    for (const iid of Object.keys(gs.world.saturation)) {
        for (const gid of Object.keys(gs.world.saturation[iid])) {
            gs.world.saturation[iid][gid] = Math.max(0, gs.world.saturation[iid][gid] - recovery);
            if (gs.world.saturation[iid][gid] <= 0) delete gs.world.saturation[iid][gid];
        }
        if (Object.keys(gs.world.saturation[iid]).length === 0) delete gs.world.saturation[iid];
    }
}

function getSaturationPenalty(gs, iid, gid) {
    if (!CONFIG.balance.demandSaturation.enabled) return 1;
    const sat = getMarketSaturation(gs, iid, gid);
    const ds = CONFIG.balance.demandSaturation;
    if (sat <= ds.threshold) return 1;
    const excess = sat - ds.threshold;
    const penalty = 1 - (excess * ds.decayRate);
    return Math.max(ds.maxPenalty, penalty);
}

// ==================== FENCE LIMIT SYSTEM ====================
function getFenceUsage(gs, iid) {
    const fenceData = gs.world.fenceUsage?.[iid];
    if (!fenceData) return 0;
    const daysSince = gs.player.days - fenceData.lastDay;
    if (daysSince >= CONFIG.balance.smuggling.fenceLimitDecayDays) return 0;
    return fenceData.amount || 0;
}

function addFenceUsage(gs, iid, qty) {
    if (!gs.world.fenceUsage) gs.world.fenceUsage = {};
    const existing = gs.world.fenceUsage[iid];
    if (existing && (gs.player.days - existing.lastDay) < CONFIG.balance.smuggling.fenceLimitDecayDays) {
        existing.amount += qty;
        existing.lastDay = gs.player.days;
    } else {
        gs.world.fenceUsage[iid] = { amount: qty, lastDay: gs.player.days };
    }
}

function canFence(gs, iid, qty) {
    const current = getFenceUsage(gs, iid);
    const limit = CONFIG.balance.smuggling.fenceLimit;
    return (current + qty) <= limit;
}

function getFenceRemaining(gs, iid) {
    return Math.max(0, CONFIG.balance.smuggling.fenceLimit - getFenceUsage(gs, iid));
}

// ==================== UPKEEP SYSTEM ====================
function calculateDailyUpkeep(gs) {
    if (!CONFIG.balance.upkeep.enabled) return 0;
    const up = CONFIG.balance.upkeep;
    const upgradeCount = Object.keys(gs.player.upgrades || {}).filter(k => gs.player.upgrades[k]).length;

    // Base upkeep
    let upkeep = up.crewWagesPerDay + (upgradeCount * up.crewWagesPerUpgrade) + up.maintenancePerDay;

    // Ship class upkeep multiplier
    const shipClass = CONFIG.shipClasses[gs.player.shipClass] || CONFIG.shipClasses.brigantine;
    upkeep *= shipClass.upkeepMult;

    // Officer wages
    upkeep += getOfficerWages(gs);

    // Quartermaster reduces upkeep
    if (hasOfficer(gs, 'quartermaster')) {
        upkeep *= CONFIG.officers.quartermaster.effects.upkeepMult;
    }

    // Gunner increases maintenance
    if (hasOfficer(gs, 'gunner')) {
        upkeep *= CONFIG.officers.gunner.effects.maintenanceMult;
    }

    return Math.ceil(upkeep);
}

function calculateDockingFee(gs, iid) {
    if (!CONFIG.balance.upkeep.enabled) return 0;
    const up = CONFIG.balance.upkeep;
    const isl = CONFIG.islands[iid];
    let fee = up.dockingFee;
    // Hostile port fee
    if (isl?.faction && isl.faction !== 'neutral' && isl.faction !== gs.player.faction) {
        const rep = gs.player.reputation?.[isl.faction] || 0;
        if (rep < -20) fee += up.dockingFeeHostile;
    }
    // === META PRESSURE: Port bias increases dock fees (they've learned to charge you more) ===
    const metaMods = metaGetModifiers(gs, { port: iid });
    fee = Math.ceil(fee * metaMods.dockFeeMult);
    return fee;
}

// ==================== ANTI-SPAM SYSTEMS ====================

// Trade fatigue: prices worsen after too many transactions at one port
function getTradeFatigue(gs, iid) {
    if (!CONFIG.balance.tradeFatigue.enabled) return 0;
    const fatigue = gs.player.tradeFatigue?.[iid] || 0;
    const tf = CONFIG.balance.tradeFatigue;
    const excessTrades = Math.max(0, fatigue - tf.transactionsPerVisit);
    return Math.min(tf.maxPenalty, excessTrades * tf.penaltyPerTrade);
}

function addTradeFatigue(gs, iid) {
    if (!gs.player.tradeFatigue) gs.player.tradeFatigue = {};
    gs.player.tradeFatigue[iid] = (gs.player.tradeFatigue[iid] || 0) + 1;
}

function resetTradeFatigue(gs) {
    // Reset all fatigue when leaving port
    gs.player.tradeFatigue = {};
}

// Port visit cooldown: visiting same port too quickly worsens prices
function getPortVisitPenalty(gs, iid) {
    if (!CONFIG.balance.portVisitCooldown.enabled) return 0;
    const lastVisit = gs.player.portVisitDays?.[iid];
    if (lastVisit === undefined) return 0;

    const pv = CONFIG.balance.portVisitCooldown;
    const daysSince = gs.player.days - lastVisit;
    if (daysSince >= pv.minDaysBetween) return 0;

    const earlyDays = pv.minDaysBetween - daysSince;
    return Math.min(pv.maxPenalty, earlyDays * pv.penaltyPerEarlyDay);
}

function recordPortVisit(gs, iid) {
    if (!gs.player.portVisitDays) gs.player.portVisitDays = {};
    gs.player.portVisitDays[iid] = gs.player.days;
}

// Bulk trade penalty: larger single transactions have diminishing returns
function getBulkTradePenalty(qty) {
    if (!CONFIG.balance.bulkTrade.enabled) return 0;
    const bt = CONFIG.balance.bulkTrade;
    const excessUnits = Math.max(0, qty - bt.threshold);
    return Math.min(bt.maxPenalty, excessUnits * bt.penaltyPerUnit);
}

// Combined anti-spam price modifier (for selling)
function getAntiSpamSellMult(gs, iid, qty) {
    const fatiguePenalty = getTradeFatigue(gs, iid);
    const visitPenalty = getPortVisitPenalty(gs, iid);
    const bulkPenalty = getBulkTradePenalty(qty);
    return Math.max(0.5, 1 - fatiguePenalty - visitPenalty - bulkPenalty);
}

// Combined anti-spam price modifier (for buying - less punitive)
function getAntiSpamBuyMult(gs, iid, qty) {
    const fatiguePenalty = getTradeFatigue(gs, iid) * 0.5; // Half penalty for buying
    const visitPenalty = getPortVisitPenalty(gs, iid) * 0.5;
    const bulkPenalty = getBulkTradePenalty(qty) * 0.5;
    return Math.min(1.5, 1 + fatiguePenalty + visitPenalty + bulkPenalty); // Prices go UP
}

// ==================== TITLE SYSTEM ====================
function getTitleTier(trackId, gs) {
    const track = CONFIG.titles[trackId];
    if (!track) return 0;
    const value = getTitleTrackValue(trackId, gs);
    let tier = 0;
    for (let i = 0; i < track.thresholds.length; i++) {
        if (value >= track.thresholds[i]) tier = i + 1;
        else break;
    }
    // Beyond last threshold: scale infinitely
    if (tier >= track.thresholds.length) {
        const lastThreshold = track.thresholds[track.thresholds.length - 1];
        const extraTiers = Math.floor((value - lastThreshold) / (lastThreshold * 0.5));
        tier = track.thresholds.length + extraTiers;
    }
    return tier;
}

function getTitleTrackValue(trackId, gs) {
    switch (trackId) {
        case 'merchant': return getNetWorth(gs);
        case 'smuggler': return gs.player.stats?.contrabandTraded || 0;
        case 'voyager': return gs.player.days || 0;
        default: return 0;
    }
}

function getTitleName(trackId, tier) {
    const track = CONFIG.titles[trackId];
    if (!track) return 'Unknown';
    if (tier < track.tierNames.length) return track.tierNames[tier];
    return track.tierNames[track.tierNames.length - 1] + ' ' + (tier - track.tierNames.length + 2);
}

function getNextThreshold(trackId, gs) {
    const track = CONFIG.titles[trackId];
    if (!track) return null;
    const value = getTitleTrackValue(trackId, gs);
    for (const t of track.thresholds) {
        if (value < t) return t;
    }
    // Beyond last: calculate next scaling threshold
    const lastThreshold = track.thresholds[track.thresholds.length - 1];
    const extraTiers = Math.floor((value - lastThreshold) / (lastThreshold * 0.5)) + 1;
    return lastThreshold + extraTiers * (lastThreshold * 0.5);
}

function getTitleModifiers(gs) {
    const mods = {
        repGainMult: 1.0,      // Multiplier for rep gains
        repLossReduction: 0,   // % reduction in rep losses
        inspectionReduction: 0, // % reduction in inspection chance
        tributeReduction: 0,   // % reduction in tribute costs
        tariffReduction: 0     // % reduction in tariffs
    };

    for (const [trackId, track] of Object.entries(CONFIG.titles)) {
        const tier = getTitleTier(trackId, gs);
        if (tier > 0 && track.effects) {
            if (track.effects.repGainMult) mods.repGainMult += track.effects.repGainMult * tier;
            if (track.effects.repLossReduction) mods.repLossReduction += track.effects.repLossReduction * tier;
            if (track.effects.inspectionReduction) mods.inspectionReduction += track.effects.inspectionReduction * tier;
            if (track.effects.tributeReduction) mods.tributeReduction += track.effects.tributeReduction * tier;
            if (track.effects.tariffReduction) mods.tariffReduction += track.effects.tariffReduction * tier;
        }
    }

    // Faction standing bonuses
    for (const faction of ['english', 'eitc', 'pirates']) {
        const rep = gs.player.reputation[faction] || 0;
        if (rep > 50) mods.tariffReduction += 0.05; // High standing = better tariffs
    }

    // Cap modifiers
    mods.repLossReduction = Math.min(0.5, mods.repLossReduction); // Max 50% reduction
    mods.inspectionReduction = Math.min(0.5, mods.inspectionReduction);
    mods.tributeReduction = Math.min(0.4, mods.tributeReduction);
    mods.tariffReduction = Math.min(0.2, mods.tariffReduction);

    return mods;
}

function updateTitles(gs, showToast = null) {
    if (!gs.player.titles) gs.player.titles = {};

    for (const trackId of Object.keys(CONFIG.titles)) {
        const oldTier = gs.player.titles[trackId] || 0;
        const newTier = getTitleTier(trackId, gs);

        if (newTier > oldTier) {
            gs.player.titles[trackId] = newTier;
            if (showToast) {
                const track = CONFIG.titles[trackId];
                showToast(track.icon, getTitleName(trackId, newTier), `${track.name} title earned!`);
            }
        }
    }
}

// ==================== REPUTATION SYSTEM ====================
function applyRepChange(gs, faction, delta, source = null) {
    const mods = getTitleModifiers(gs);

    // Apply modifiers
    if (delta > 0) {
        delta = Math.round(delta * mods.repGainMult);
    } else if (delta < 0) {
        delta = Math.round(delta * (1 - mods.repLossReduction));
    }

    // Apply change with clamping
    const oldRep = gs.player.reputation[faction] || 0;
    gs.player.reputation[faction] = Math.max(-100, Math.min(100, oldRep + delta));

    // Track stats
    if (!gs.player.stats) gs.player.stats = {};
    if (!gs.player.stats.repChanges) gs.player.stats.repChanges = {};
    if (!gs.player.stats.repChanges[faction]) gs.player.stats.repChanges[faction] = { gained: 0, lost: 0 };

    if (delta > 0) gs.player.stats.repChanges[faction].gained += delta;
    else if (delta < 0) gs.player.stats.repChanges[faction].lost += Math.abs(delta);

    return gs.player.reputation[faction] - oldRep;
}

// ==================== CONTRACT SYSTEM ====================
let contractIdCounter = 1;

function generateContractId() {
    return 'c_' + (contractIdCounter++) + '_' + Date.now().toString(36);
}

function generateContractsForIsland(gs, iid) {
    const contracts = [];
    const island = CONFIG.islands[iid];
    if (!island) return contracts;

    const numContracts = 3 + Math.floor(Math.random() * (CONFIG.settings.contractBoardSize - 2));
    const otherIslands = Object.keys(CONFIG.islands).filter(id => id !== iid);

    for (let i = 0; i < numContracts; i++) {
        const destId = otherIslands[Math.floor(Math.random() * otherIslands.length)];
        const dest = CONFIG.islands[destId];
        const dist = getIslandDistance(island.position, dest.position);
        const baseDays = Math.ceil(dist / 30);

        // Pick contract type based on island faction
        const types = ['delivery', 'courier', 'supply'];
        if (island.faction === 'pirates' || dest.faction === 'pirates') types.push('smuggling', 'smuggling');
        if (island.faction !== 'neutral') types.push('faction');

        const typeId = types[Math.floor(Math.random() * types.length)];
        const type = CONFIG.contractTypes[typeId];

        // Calculate rewards based on distance, urgency, risk
        const urgency = 0.8 + Math.random() * 0.4; // 0.8-1.2
        const deadline = Math.max(2, Math.floor(baseDays * (1.5 + (1 - urgency) * 2)));
        const riskFactor = type.riskMult * (1 + getRouteRiskBetween(gs, iid, destId) * 0.5);

        // === BALANCE: Contract rewards scale down with player power ===
        // Prevents snowballing - as player gets richer, contracts become less lucrative
        const prog = CONFIG.balance.progression;
        const powerRewardMult = getPowerScaling(gs, prog.contractRewardBase, prog.contractRewardPowerMult, prog.contractRewardMin, 1.0);

        let goldReward = Math.floor(type.baseReward * (1 + dist / 100) * riskFactor * urgency * powerRewardMult);
        let repReward = type.repReward;
        let repFaction = island.faction !== 'neutral' ? island.faction : (Math.random() > 0.5 ? 'english' : 'eitc');

        // Contract-specific requirements
        let requirement = null;
        let goodId = null;
        let qty = 0;

        if (typeId === 'delivery') {
            const goods = Object.keys(CONFIG.goods).filter(g => CONFIG.goods[g].category !== 'contraband');
            goodId = goods[Math.floor(Math.random() * goods.length)];
            qty = 3 + Math.floor(Math.random() * 8);
            requirement = { type: 'deliver', goodId, qty };
        } else if (typeId === 'smuggling') {
            goodId = 'gunpowder';
            qty = 2 + Math.floor(Math.random() * 5);
            requirement = { type: 'deliver', goodId, qty };
            repFaction = 'pirates';
            goldReward = Math.floor(goldReward * 1.5);
        } else if (typeId === 'courier') {
            requirement = { type: 'reach', noInspection: Math.random() > 0.5 };
        } else if (typeId === 'supply') {
            requirement = { type: 'supplies', minSupplies: 10 + Math.floor(Math.random() * 10) };
        } else if (typeId === 'faction') {
            requirement = { type: 'reach' };
            goldReward = Math.floor(goldReward * 0.6);
            repReward = Math.floor(repReward * 1.5);
        }

        contracts.push({
            id: generateContractId(),
            typeId,
            title: generateContractTitle(typeId, goodId, dest.name),
            fromIsland: iid,
            toIsland: destId,
            deadline,
            requirement,
            rewards: { gold: goldReward, rep: repReward, repFaction },
            dayAccepted: null,
            status: 'available'
        });
    }

    return contracts;
}

function generateContractTitle(typeId, goodId, destName) {
    const good = goodId ? CONFIG.goods[goodId] : null;
    switch (typeId) {
        case 'delivery': return `Deliver ${good?.name || 'goods'} to ${destName}`;
        case 'smuggling': return `Smuggle cargo to ${destName}`;
        case 'courier': return `Urgent dispatch to ${destName}`;
        case 'supply': return `Supply run to ${destName}`;
        case 'faction': return `Official business at ${destName}`;
        default: return `Contract to ${destName}`;
    }
}

function getIslandDistance(pos1, pos2) {
    return Math.sqrt((pos1.x - pos2.x) ** 2 + (pos1.z - pos2.z) ** 2);
}

function getRouteRiskBetween(gs, fromId, toId) {
    const from = CONFIG.islands[fromId];
    const to = CONFIG.islands[toId];
    let risk = 0;
    if (to.faction === 'pirates') risk += 0.3;
    if (from.faction === 'pirates') risk += 0.2;
    return Math.min(1, risk);
}

function acceptContract(gs, contractId) {
    const active = gs.player.contracts.active || [];
    if (active.length >= CONFIG.settings.maxActiveContracts) return { success: false, reason: 'Too many active contracts' };

    // Find contract in any board
    for (const iid of Object.keys(gs.world.boards)) {
        const board = gs.world.boards[iid];
        const idx = board.contracts.findIndex(c => c.id === contractId);
        if (idx !== -1) {
            const contract = board.contracts[idx];
            const type = CONFIG.contractTypes[contract.typeId];

            // === BALANCE: Contract acceptance costs ===
            // Courier contracts require a deposit (refunded on completion)
            if (type.depositPct) {
                const deposit = Math.floor(contract.rewards.gold * type.depositPct);
                if (gs.player.gold < deposit) {
                    return { success: false, reason: `Need ${deposit}g deposit` };
                }
                gs.player.gold -= deposit;
                contract.deposit = deposit;
            }

            // Supply contracts consume supplies upfront
            if (type.supplyCost) {
                if (gs.player.supplies < type.supplyCost) {
                    return { success: false, reason: `Need ${type.supplyCost} supplies` };
                }
                gs.player.supplies -= type.supplyCost;
            }

            // Remove from board and activate
            board.contracts.splice(idx, 1);
            contract.dayAccepted = gs.player.days;
            contract.status = 'active';
            active.push(contract);
            gs.player.contracts.active = active;
            return { success: true, contract };
        }
    }
    return { success: false, reason: 'Contract not found' };
}

function abandonContract(gs, contractId) {
    const idx = gs.player.contracts.active.findIndex(c => c.id === contractId);
    if (idx === -1) return false;

    const contract = gs.player.contracts.active.splice(idx, 1)[0];
    contract.status = 'abandoned';
    gs.player.contracts.failed.push(contract);

    // Small rep penalty
    applyRepChange(gs, contract.rewards.repFaction, -3, 'abandon_contract');

    if (gs.player.trackedContractId === contractId) {
        gs.player.trackedContractId = null;
    }

    return true;
}

function evaluateContractsOnDock(gs, iid) {
    const completed = [];
    const toRemove = [];

    for (const contract of gs.player.contracts.active) {
        if (contract.toIsland !== iid) continue;

        let success = false;
        const req = contract.requirement;

        if (req.type === 'deliver') {
            const have = gs.player.cargo[req.goodId] || 0;
            if (have >= req.qty) {
                gs.player.cargo[req.goodId] = have - req.qty;
                if (gs.player.cargo[req.goodId] <= 0) delete gs.player.cargo[req.goodId];
                success = true;

                // Track contraband for smuggler title
                if (CONFIG.goods[req.goodId]?.category === 'contraband') {
                    if (!gs.player.stats) gs.player.stats = {};
                    gs.player.stats.contrabandTraded = (gs.player.stats.contrabandTraded || 0) + req.qty;
                }
            }
        } else if (req.type === 'reach') {
            if (req.noInspection && contract.wasInspected) {
                success = false;
            } else {
                success = true;
            }
        } else if (req.type === 'supplies') {
            if (gs.player.supplies >= req.minSupplies) {
                success = true;
            }
        } else {
            success = true;
        }

        if (success) {
            completed.push(contract);
            toRemove.push(contract.id);
        }
    }

    // Remove completed from active
    gs.player.contracts.active = gs.player.contracts.active.filter(c => !toRemove.includes(c.id));

    // Award rewards
    for (const contract of completed) {
        gs.player.gold += contract.rewards.gold;

        // === BALANCE: Refund deposit if any ===
        if (contract.deposit) {
            gs.player.gold += contract.deposit;
        }

        applyRepChange(gs, contract.rewards.repFaction, contract.rewards.rep, 'contract_complete');
        contract.status = 'completed';
        gs.player.contracts.completed.push(contract);

        // Track stats
        if (!gs.player.stats) gs.player.stats = {};
        gs.player.stats.contractsCompleted = (gs.player.stats.contractsCompleted || 0) + 1;

        // Smuggling increases crackdown
        if (contract.typeId === 'smuggling') {
            gs.world.crackdown.level = Math.min(
                CONFIG.settings.crackdownMaxLevel,
                (gs.world.crackdown.level || 0) + 15
            );
        }

        if (gs.player.trackedContractId === contract.id) {
            gs.player.trackedContractId = null;
        }
    }

    return completed;
}

function expireContracts(gs) {
    const expired = [];
    const toRemove = [];

    for (const contract of gs.player.contracts.active) {
        const daysElapsed = gs.player.days - contract.dayAccepted;
        if (daysElapsed >= contract.deadline) {
            expired.push(contract);
            toRemove.push(contract.id);
        }
    }

    gs.player.contracts.active = gs.player.contracts.active.filter(c => !toRemove.includes(c.id));

    for (const contract of expired) {
        contract.status = 'failed';
        gs.player.contracts.failed.push(contract);
        applyRepChange(gs, contract.rewards.repFaction, -Math.abs(contract.rewards.rep), 'contract_failed');

        if (gs.player.trackedContractId === contract.id) {
            gs.player.trackedContractId = null;
        }
    }

    return expired;
}

function getTrackedContract(gs) {
    if (!gs.player.trackedContractId) return null;
    return gs.player.contracts.active.find(c => c.id === gs.player.trackedContractId);
}

function refreshContractBoard(gs, iid) {
    if (!gs.world.boards) gs.world.boards = {};

    const board = gs.world.boards[iid];
    const shouldRefresh = !board ||
        (gs.player.days - board.dayGenerated) >= CONFIG.settings.contractRefreshDays ||
        board.contracts.length === 0;

    if (shouldRefresh) {
        gs.world.boards[iid] = {
            dayGenerated: gs.player.days,
            contracts: generateContractsForIsland(gs, iid)
        };
    }

    return gs.world.boards[iid];
}

// ==================== LIVING WORLD SYSTEM ====================
function tickWorldStatePerDay(gs) {
    if (!gs.world) gs.world = {};

    // Crackdown decay
    if (gs.world.crackdown) {
        gs.world.crackdown.level = Math.max(0, (gs.world.crackdown.level || 0) - CONFIG.settings.crackdownDecayPerDay);
    }

    // Regional event management
    if (gs.world.regionalEvent) {
        gs.world.regionalEvent.daysRemaining--;
        if (gs.world.regionalEvent.daysRemaining <= 0) {
            gs.world.regionalEvent = null;
        }
    }

    // Chance to spawn new regional event
    if (!gs.world.regionalEvent && Math.random() < 0.05) {
        const event = CONFIG.regionalEvents[Math.floor(Math.random() * CONFIG.regionalEvents.length)];
        gs.world.regionalEvent = {
            id: event.id,
            name: event.name,
            desc: event.desc,
            categoryMult: { ...event.categoryMult },
            daysRemaining: event.duration,
            affectedIslands: getRandomIslandSubset(3 + Math.floor(Math.random() * 3))
        };
    }

    // === LIVING SEA UPDATES ===

    // Update drift entities (storms, fleets, markets move across map)
    updateDriftEntities(gs);

    // Update port states
    updatePortStates(gs);

    // Update faction influence, blockades, and war zones
    updateFactionInfluence(gs);

    // Seasonal event management
    if (gs.world.seasonalEvent) {
        gs.world.seasonalEvent.daysRemaining--;
        if (gs.world.seasonalEvent.daysRemaining <= 0) {
            gs.world.seasonalEvent = null;
        }
    }

    // Chance to spawn seasonal event (based on current season)
    if (!gs.world.seasonalEvent && Math.random() < 0.03) {
        const season = getCurrentSeason(gs);
        const eligibleEvents = CONFIG.seasonalEvents.filter(e =>
            e.season === 'any' || e.season === season.id
        );
        if (eligibleEvents.length > 0) {
            const event = eligibleEvents[Math.floor(Math.random() * eligibleEvents.length)];
            gs.world.seasonalEvent = {
                id: event.id,
                name: event.name,
                desc: event.desc,
                effects: { ...event.effects },
                daysRemaining: event.duration,
                startDay: gs.player.days
            };
        }
    }

    // Check for season change notification
    const prevSeason = gs.world.lastSeason;
    const currentSeason = getCurrentSeason(gs);
    if (prevSeason && prevSeason !== currentSeason.id) {
        gs.world.seasonChanged = { from: prevSeason, to: currentSeason.id };
    }
    gs.world.lastSeason = currentSeason.id;
}

function getRandomIslandSubset(count) {
    const islands = Object.keys(CONFIG.islands);
    const shuffled = islands.sort(() => Math.random() - 0.5);
    return shuffled.slice(0, Math.min(count, islands.length));
}

function getCrackdownLevel(gs) {
    return gs.world?.crackdown?.level || 0;
}

// ==================== LIVING SEA - SEASONS ====================
function getCurrentSeason(gs) {
    const day = ((gs.player.days - 1) % CONFIG.settings.seasonCycleDays) + 1;
    for (const [id, season] of Object.entries(CONFIG.seasons)) {
        if (day >= season.dayStart && day <= season.dayEnd) {
            return { id, ...season, currentDay: day };
        }
    }
    return { id: 'calmWinds', ...CONFIG.seasons.calmWinds, currentDay: day };
}

function getSeasonLabel(gs) {
    const season = getCurrentSeason(gs);
    const daysInSeason = season.dayEnd - season.dayStart + 1;
    const dayInSeason = season.currentDay - season.dayStart + 1;
    return {
        label: season.name,
        icon: season.icon,
        class: season.id === 'monsoon' ? 'storm-season' : '',
        desc: season.desc,
        progress: `Day ${dayInSeason}/${daysInSeason}`
    };
}

function isStormSeason(gs) {
    const season = getCurrentSeason(gs);
    return season.id === 'monsoon';
}

function getSeasonModifiers(gs) {
    const season = getCurrentSeason(gs);
    return {
        stormMult: season.stormMult || 1,
        priceMult: season.priceMult || 1,
        piratesMult: season.piratesMult || 1,
        speedMult: season.speedMult || 1,
        supplyCostMult: season.supplyCostMult || 1,
        windStrengthBias: season.windStrengthBias || 0
    };
}

// ==================== LIVING SEA - PORT STATES ====================
function getPortState(gs, iid) {
    return gs.world?.portStates?.[iid] || 'prosperous';
}

function getPortStateConfig(gs, iid) {
    const stateId = getPortState(gs, iid);
    return CONFIG.portStates[stateId] || CONFIG.portStates.prosperous;
}

function updatePortStates(gs) {
    if (!gs.world.portStates) gs.world.portStates = {};

    for (const iid of Object.keys(CONFIG.islands)) {
        const island = gs.islands[iid];
        const currentState = gs.world.portStates[iid] || 'prosperous';

        // Check for state transitions based on conditions
        if (Math.random() < CONFIG.settings.portStateChangeChance) {
            const newState = determinePortState(gs, iid, island);
            if (newState !== currentState) {
                gs.world.portStates[iid] = newState;
                gs.world.portStateChanges = gs.world.portStateChanges || [];
                gs.world.portStateChanges.push({ iid, from: currentState, to: newState, day: gs.player.days });
            }
        }
    }
}

function determinePortState(gs, iid, island) {
    const season = getCurrentSeason(gs);
    const roll = Math.random();

    // Seasonal influences
    if (season.id === 'monsoon' && roll < 0.2) return 'flooded';
    if (season.id === 'doldrums' && roll < 0.15) return 'struggling';

    // Faction influences
    if (island.faction === 'pirates' && roll < 0.25) return 'lawless';

    // Supply-based states
    let totalSupply = 0, totalDemand = 0;
    Object.values(island.markets).forEach(m => {
        totalSupply += m.supply;
        totalDemand += m.demand;
    });

    const ratio = totalSupply / Math.max(1, totalDemand);
    if (ratio < 0.3) return Math.random() < 0.5 ? 'starving' : 'struggling';
    if (ratio > 1.5) return 'prosperous';

    // Random events
    if (roll < 0.05) return 'blockaded';
    if (roll < 0.08) return 'lawless';

    // Tendency toward normalcy
    return roll < 0.6 ? 'prosperous' : 'struggling';
}

// ==================== LIVING SEA - FACTION INFLUENCE & WAR FRONTS ====================
function initIslandInfluence(gs) {
    if (!gs.world.islandInfluence) gs.world.islandInfluence = {};

    // Initialize influence for each island based on base faction
    for (const [iid, island] of Object.entries(CONFIG.islands)) {
        if (!gs.world.islandInfluence[iid]) {
            gs.world.islandInfluence[iid] = {
                english: island.faction === 'english' ? 60 : (island.faction === 'neutral' ? 30 : 15),
                eitc: island.faction === 'eitc' ? 60 : (island.faction === 'neutral' ? 30 : 15),
                pirates: island.faction === 'pirates' ? 60 : (island.faction === 'neutral' ? 30 : 15),
                stability: 100
            };
        }
    }
}

function getIslandInfluence(gs, iid) {
    initIslandInfluence(gs);
    return gs.world.islandInfluence[iid] || { english: 33, eitc: 33, pirates: 33, stability: 100 };
}

function getDominantFaction(gs, iid) {
    const inf = getIslandInfluence(gs, iid);
    const threshold = CONFIG.warFronts.controlThreshold;

    // Check if any faction has control
    if (inf.english >= threshold) return 'english';
    if (inf.eitc >= threshold) return 'eitc';
    if (inf.pirates >= threshold) return 'pirates';

    // No clear control - contested
    return 'contested';
}

function isIslandContested(gs, iid) {
    return getDominantFaction(gs, iid) === 'contested';
}

function modifyInfluence(gs, iid, faction, amount) {
    initIslandInfluence(gs);
    const inf = gs.world.islandInfluence[iid];
    if (!inf) return;

    // Add to the specified faction
    inf[faction] = Math.max(0, Math.min(100, (inf[faction] || 0) + amount));

    // Proportionally reduce others to keep total around 100
    const total = inf.english + inf.eitc + inf.pirates;
    if (total > 100) {
        const excess = total - 100;
        const others = ['english', 'eitc', 'pirates'].filter(f => f !== faction);
        const otherTotal = others.reduce((sum, f) => sum + inf[f], 0);
        if (otherTotal > 0) {
            for (const f of others) {
                inf[f] = Math.max(0, inf[f] - (inf[f] / otherTotal) * excess);
            }
        }
    }

    // Reduce stability when influence changes rapidly
    if (Math.abs(amount) > 2) {
        inf.stability = Math.max(0, inf.stability - Math.abs(amount) * 0.5);
    }
}

function applyTradeInfluence(gs, iid, playerFaction) {
    const wf = CONFIG.warFronts;
    modifyInfluence(gs, iid, playerFaction, wf.influencePerTrade);
}

function applyQuestInfluence(gs, iid, faction) {
    const wf = CONFIG.warFronts;
    modifyInfluence(gs, iid, faction, wf.influencePerQuest);
}

function applySmuggleInfluence(gs, iid) {
    const wf = CONFIG.warFronts;
    // Smuggling destabilizes all factions
    const inf = getIslandInfluence(gs, iid);
    modifyInfluence(gs, iid, 'pirates', Math.abs(wf.influencePerSmuggle));
    inf.stability = Math.max(0, inf.stability - 5);
}

function updateFactionInfluence(gs) {
    initIslandInfluence(gs);
    const wf = CONFIG.warFronts;

    // Daily stability recovery
    for (const [iid, inf] of Object.entries(gs.world.islandInfluence)) {
        inf.stability = Math.min(100, inf.stability + wf.stabilityRecoveryPerDay);

        // Natural drift toward base faction
        const baseFaction = CONFIG.islands[iid]?.faction;
        if (baseFaction && baseFaction !== 'neutral') {
            modifyInfluence(gs, iid, baseFaction, 0.2);
        }
    }

    // Update blockades
    updateBlockades(gs);

    // Update war zones
    updateWarZones(gs);
}

// ==================== LIVING SEA - BLOCKADES ====================
function getActiveBlockades(gs) {
    return gs.world.activeBlockades || [];
}

function isIslandBlockaded(gs, iid) {
    return getActiveBlockades(gs).some(b => b.islandId === iid && b.daysRemaining > 0);
}

function getBlockadeInfo(gs, iid) {
    return getActiveBlockades(gs).find(b => b.islandId === iid && b.daysRemaining > 0);
}

function startBlockade(gs, iid, blockadingFaction) {
    if (!gs.world.activeBlockades) gs.world.activeBlockades = [];

    // Check if already blockaded
    if (isIslandBlockaded(gs, iid)) return null;

    const blockade = {
        id: 'blockade_' + Date.now(),
        islandId: iid,
        blockadingFaction,
        daysRemaining: CONFIG.warFronts.blockadeDuration,
        startDay: gs.player.days,
        strength: 50 + Math.floor(Math.random() * 50) // 50-100%
    };

    gs.world.activeBlockades.push(blockade);

    // Set port state to blockaded
    if (!gs.world.portStates) gs.world.portStates = {};
    gs.world.portStates[iid] = 'blockaded';

    return blockade;
}

function updateBlockades(gs) {
    if (!gs.world.activeBlockades) gs.world.activeBlockades = [];

    // Decrement days and remove expired blockades
    gs.world.activeBlockades = gs.world.activeBlockades.filter(b => {
        b.daysRemaining--;
        if (b.daysRemaining <= 0) {
            // Remove blockaded port state
            if (gs.world.portStates?.[b.islandId] === 'blockaded') {
                gs.world.portStates[b.islandId] = 'struggling';
            }
            return false;
        }
        return true;
    });

    // Random chance to spawn new blockade during unstable periods
    if (Math.random() < 0.02) {
        // Pick a contested or low-stability island
        const candidates = Object.entries(gs.world.islandInfluence || {})
            .filter(([iid, inf]) => inf.stability < 50 || isIslandContested(gs, iid))
            .filter(([iid]) => !isIslandBlockaded(gs, iid));

        if (candidates.length > 0) {
            const [targetId] = candidates[Math.floor(Math.random() * candidates.length)];
            const island = CONFIG.islands[targetId];

            // Opposing faction blockades
            const blockader = island.faction === 'english' ? 'pirates' :
                             island.faction === 'pirates' ? 'english' :
                             (Math.random() < 0.5 ? 'english' : 'pirates');

            startBlockade(gs, targetId, blockader);
        }
    }
}

// ==================== LIVING SEA - WAR ZONES ====================
function getActiveWarZones(gs) {
    return gs.world.activeWarZones || [];
}

function isIslandWarZone(gs, iid) {
    return getActiveWarZones(gs).some(w => w.islandId === iid && w.daysRemaining > 0);
}

function getWarZoneInfo(gs, iid) {
    return getActiveWarZones(gs).find(w => w.islandId === iid && w.daysRemaining > 0);
}

function startWarZone(gs, iid, factions) {
    if (!gs.world.activeWarZones) gs.world.activeWarZones = [];

    if (isIslandWarZone(gs, iid)) return null;

    const warZone = {
        id: 'warzone_' + Date.now(),
        islandId: iid,
        factions,
        daysRemaining: CONFIG.warFronts.warZoneDuration,
        startDay: gs.player.days,
        intensity: 50 + Math.floor(Math.random() * 50)
    };

    gs.world.activeWarZones.push(warZone);
    return warZone;
}

function updateWarZones(gs) {
    if (!gs.world.activeWarZones) gs.world.activeWarZones = [];

    // Decrement days and remove expired war zones
    gs.world.activeWarZones = gs.world.activeWarZones.filter(w => {
        w.daysRemaining--;
        if (w.daysRemaining <= 0) {
            // War resolution affects influence
            const winner = Math.random() < 0.5 ? w.factions[0] : w.factions[1];
            modifyInfluence(gs, w.islandId, winner, 15);
            return false;
        }
        return true;
    });

    // Random chance to spawn war zone in contested areas
    if (Math.random() < 0.01) {
        const contested = Object.keys(gs.world.islandInfluence || {})
            .filter(iid => isIslandContested(gs, iid) && !isIslandWarZone(gs, iid));

        if (contested.length > 0) {
            const targetId = contested[Math.floor(Math.random() * contested.length)];
            const inf = getIslandInfluence(gs, targetId);

            // Two highest factions fight
            const sorted = ['english', 'eitc', 'pirates'].sort((a, b) => inf[b] - inf[a]);
            startWarZone(gs, targetId, [sorted[0], sorted[1]]);
        }
    }
}

// Get risk modifier for traveling near blockaded/warzone islands
function getBlockadeRisk(gs, iid) {
    let risk = 0;
    if (isIslandBlockaded(gs, iid)) risk += 0.3;
    if (isIslandWarZone(gs, iid)) risk += 0.2;
    return risk;
}

// ==================== LIVING SEA - HIDDEN COVES & EXPLORATION ====================
function getDiscoveredCoves(gs) {
    return gs.player.discoveredCoves || [];
}

function isCoveDiscovered(gs, coveId) {
    return getDiscoveredCoves(gs).includes(coveId);
}

function discoverCove(gs, coveId) {
    if (!gs.player.discoveredCoves) gs.player.discoveredCoves = [];
    if (!isCoveDiscovered(gs, coveId)) {
        gs.player.discoveredCoves.push(coveId);
        return true;
    }
    return false;
}

function getChartFragments(gs) {
    return gs.player.chartFragments || 0;
}

function addChartFragment(gs) {
    if (!gs.player.chartFragments) gs.player.chartFragments = 0;
    gs.player.chartFragments++;

    // Auto-reveal cove when 3 fragments collected
    if (gs.player.chartFragments >= 3) {
        const result = useChartFragments(gs);
        if (result) {
            return { discovered: true, coveId: result.coveId };
        }
    }
    return { discovered: false };
}

function canRevealCove(gs) {
    // 3 chart fragments reveal a random undiscovered cove
    return getChartFragments(gs) >= 3;
}

function useChartFragments(gs) {
    if (!canRevealCove(gs)) return null;
    gs.player.chartFragments -= 3;

    // Find undiscovered coves
    const undiscovered = Object.keys(CONFIG.hiddenCoves).filter(id => !isCoveDiscovered(gs, id));
    if (undiscovered.length === 0) return null;

    // Reveal random cove
    const coveId = undiscovered[Math.floor(Math.random() * undiscovered.length)];
    discoverCove(gs, coveId);
    return { coveId, cove: CONFIG.hiddenCoves[coveId] };
}

function getCoveByPosition(gs, radius = 40) {
    const pp = gs.player.position;
    for (const [coveId, cove] of Object.entries(CONFIG.hiddenCoves)) {
        if (!isCoveDiscovered(gs, coveId)) continue;
        const dist = Math.sqrt((cove.position.x - pp.x) ** 2 + (cove.position.z - pp.z) ** 2);
        if (dist < radius) {
            return { coveId, cove, distance: dist };
        }
    }
    return null;
}

function exploreForCove(gs) {
    // Exploration has a chance to discover nearby coves
    const pp = gs.player.position;
    for (const [coveId, cove] of Object.entries(CONFIG.hiddenCoves)) {
        if (isCoveDiscovered(gs, coveId)) continue;
        const dist = Math.sqrt((cove.position.x - pp.x) ** 2 + (cove.position.z - pp.z) ** 2);
        // Within 100 units, chance scales with proximity
        if (dist < 100) {
            const chance = 0.1 * (1 - dist / 100); // 10% at close range
            if (Math.random() < chance) {
                discoverCove(gs, coveId);
                return { coveId, cove };
            }
        }
    }
    return null;
}

function getCoveHint(gs, iid) {
    // Port rumors may reveal cove hints
    const rumors = getRumorsForPort(gs, iid);
    const hintRumor = rumors.find(r => r.type === 'cove' && r.isTrue);
    if (hintRumor) {
        const undiscovered = Object.keys(CONFIG.hiddenCoves).filter(id => !isCoveDiscovered(gs, id));
        if (undiscovered.length > 0) {
            const coveId = undiscovered[Math.floor(Math.random() * undiscovered.length)];
            return CONFIG.hiddenCoves[coveId];
        }
    }
    return null;
}

// ==================== LIVING SEA - DRIFT ENTITIES ====================
function initDriftEntities(gs) {
    if (!gs.world.driftEntities) gs.world.driftEntities = [];
}

function spawnDriftEntity(gs, typeId = null) {
    if (gs.world.driftEntities.length >= CONFIG.settings.maxDriftEntities) return null;

    const types = Object.keys(CONFIG.driftEntities);
    if (!typeId) {
        // Weight spawn chances by season
        const season = getCurrentSeason(gs);
        const weights = types.map(t => {
            let w = 1;
            if (t === 'stormFront' && season.id === 'monsoon') w = 3;
            if (t === 'pirateFleet' && season.id === 'doldrums') w = 2;
            if (t === 'floatingMarket' && season.id === 'tradeWinds') w = 2;
            if (t === 'navyConvoy' && gs.world.crackdown.level > 30) w = 2;
            return w;
        });
        const totalWeight = weights.reduce((a, b) => a + b, 0);
        let r = Math.random() * totalWeight;
        for (let i = 0; i < types.length; i++) {
            r -= weights[i];
            if (r <= 0) { typeId = types[i]; break; }
        }
    }

    const config = CONFIG.driftEntities[typeId];
    const islands = Object.values(CONFIG.islands);

    // Spawn at edge of map or near island
    let pos;
    if (Math.random() < 0.3) {
        // Near random island
        const isl = islands[Math.floor(Math.random() * islands.length)];
        pos = { x: isl.position.x + (Math.random() - 0.5) * 100, z: isl.position.z + (Math.random() - 0.5) * 100 };
    } else {
        // Edge of map
        const edge = Math.floor(Math.random() * 4);
        switch (edge) {
            case 0: pos = { x: -250, z: (Math.random() - 0.5) * 400 }; break;
            case 1: pos = { x: 250, z: (Math.random() - 0.5) * 400 }; break;
            case 2: pos = { x: (Math.random() - 0.5) * 500, z: -200 }; break;
            case 3: pos = { x: (Math.random() - 0.5) * 500, z: 200 }; break;
        }
    }

    // Random heading
    const heading = Math.random() * Math.PI * 2;

    const entity = {
        id: 'drift_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5),
        typeId,
        position: pos,
        heading,
        velocity: { x: Math.sin(heading) * config.speed, z: Math.cos(heading) * config.speed },
        daysRemaining: config.lifetime + Math.floor(Math.random() * 5),
        spawnDay: gs.player.days
    };

    gs.world.driftEntities.push(entity);
    return entity;
}

function updateDriftEntities(gs) {
    initDriftEntities(gs);

    // Move existing entities
    for (const entity of gs.world.driftEntities) {
        entity.position.x += entity.velocity.x;
        entity.position.z += entity.velocity.z;
        entity.daysRemaining--;

        // Slight course changes
        if (Math.random() < 0.2) {
            entity.heading += (Math.random() - 0.5) * 0.5;
            const config = CONFIG.driftEntities[entity.typeId];
            entity.velocity.x = Math.sin(entity.heading) * config.speed;
            entity.velocity.z = Math.cos(entity.heading) * config.speed;
        }

        // Wrap around map edges
        if (entity.position.x < -280) entity.position.x = 280;
        if (entity.position.x > 280) entity.position.x = -280;
        if (entity.position.z < -230) entity.position.z = 230;
        if (entity.position.z > 230) entity.position.z = -230;
    }

    // Remove expired entities
    gs.world.driftEntities = gs.world.driftEntities.filter(e => e.daysRemaining > 0);

    // Spawn new entities
    if (Math.random() < CONFIG.settings.driftEntitySpawnChance) {
        spawnDriftEntity(gs);
    }
}

function getNearbyDriftEntities(gs, radius = 50) {
    const pp = gs.player.position;
    const nearby = [];

    for (const entity of (gs.world.driftEntities || [])) {
        const dist = Math.sqrt((entity.position.x - pp.x) ** 2 + (entity.position.z - pp.z) ** 2);
        const config = CONFIG.driftEntities[entity.typeId];
        const effectRadius = config.dangerRadius || config.inspectRadius || config.interactRadius || 30;

        if (dist < radius + effectRadius) {
            nearby.push({ ...entity, distance: dist, config });
        }
    }

    return nearby;
}

// ==================== LIVING SEA - RUMORS ====================
function generateRumors(gs, iid) {
    const rumors = [];
    const islands = Object.keys(CONFIG.islands);
    const goods = Object.keys(CONFIG.goods);
    const factions = ['Navy', 'Company', 'Pirates'];
    const directions = ['north', 'south', 'east', 'west'];

    const numRumors = 2 + Math.floor(Math.random() * (CONFIG.settings.maxRumorsPerPort - 1));

    for (let i = 0; i < numRumors; i++) {
        const template = CONFIG.rumorTemplates[Math.floor(Math.random() * CONFIG.rumorTemplates.length)];
        const otherIslands = islands.filter(id => id !== iid);

        let text = template.template
            .replace('{island}', CONFIG.islands[otherIslands[Math.floor(Math.random() * otherIslands.length)]].name)
            .replace('{good}', CONFIG.goods[goods[Math.floor(Math.random() * goods.length)]].name)
            .replace('{faction}', factions[Math.floor(Math.random() * factions.length)])
            .replace('{direction}', directions[Math.floor(Math.random() * directions.length)]);

        // Handle cove hint rumors
        if (template.type === 'cove') {
            const undiscoveredCoves = Object.entries(CONFIG.hiddenCoves)
                .filter(([id, _]) => !isCoveDiscovered(gs, id));
            if (undiscoveredCoves.length > 0) {
                const [_, cove] = undiscoveredCoves[Math.floor(Math.random() * undiscoveredCoves.length)];
                text = cove.discoveryHint;
            } else {
                // All coves discovered, skip this rumor
                continue;
            }
        }

        // Determine if rumor is true
        const isTrue = Math.random() < template.accuracy;
        const daysOld = Math.floor(Math.random() * 3);

        rumors.push({
            id: 'rumor_' + Date.now() + '_' + i,
            text,
            type: template.type,
            isTrue,
            daysOld,
            generatedDay: gs.player.days
        });
    }

    return rumors;
}

function refreshRumors(gs, iid) {
    if (!gs.world.rumors) gs.world.rumors = {};

    const existing = gs.world.rumors[iid];
    const shouldRefresh = !existing ||
        (gs.player.days - existing.generatedDay) >= CONFIG.settings.rumorRefreshDays;

    if (shouldRefresh) {
        gs.world.rumors[iid] = {
            generatedDay: gs.player.days,
            rumors: generateRumors(gs, iid)
        };
    }

    return gs.world.rumors[iid];
}

function getRumorsForPort(gs, iid) {
    refreshRumors(gs, iid);
    return gs.world.rumors[iid]?.rumors || [];
}

// ==================== SHIP STAT HELPERS ====================
// Returns effective ship speed factoring in upgrades
function getShipSpeed(gs) {
// Get ship class base speed
const shipClass = CONFIG.shipClasses[gs.player.shipClass] || CONFIG.shipClasses.brigantine;
let s = CONFIG.settings.baseShipSpeed * shipClass.baseSpeed;

// Faction bonus
if (gs.player.faction === 'pirates') s *= 1.2;

// Apply upgrade penalties
if (gs.player.upgrades?.reinforcedHold) s *= (1 - CONFIG.upgrades.reinforcedHold.effects.speedPenalty);
if (gs.player.upgrades?.vault) s *= (1 - CONFIG.upgrades.vault.effects.speedPenalty);

// Officer navigator speed bonus
if (hasOfficer(gs, 'navigator')) s *= (1 + CONFIG.officers.navigator.effects.speedBonus);

// Low rigging penalty
const rigging = gs.player.ship?.rigging ?? 100;
if (rigging < CONFIG.shipCondition.criticalThreshold) {
    s *= (1 - CONFIG.shipCondition.lowRiggingSpeedPenalty);
}

return s;
}

// Returns effective cargo capacity factoring in upgrades, faction, and ship class
function getCargoCapacity(gs) {
// Get ship class cargo capacity
const shipClass = CONFIG.shipClasses[gs.player.shipClass] || CONFIG.shipClasses.brigantine;
let c = shipClass.cargoCapacity;

// Faction bonus
if (gs.player.faction === 'eitc') c *= 1.2;

// Apply upgrade effects
if (gs.player.upgrades?.reinforcedHold) c -= CONFIG.upgrades.reinforcedHold.effects.capacityPenalty;
if (gs.player.upgrades?.smugglerCompartments) c -= CONFIG.upgrades.smugglerCompartments.effects.capacityPenalty;
if (gs.player.upgrades?.vault) c -= CONFIG.upgrades.vault.effects.capacityPenalty;

return Math.floor(Math.max(20, c)); // minimum 20
}

// Returns supplies consumed per day
function getSupplyRate(gs) {
let rate = CONFIG.settings.baseSupplyRate;
if (gs.player.upgrades?.swiftSails) rate += CONFIG.upgrades.swiftSails.effects.supplyCostExtra;
if (gs.player.upgrades?.smugglerCompartments) rate += CONFIG.upgrades.smugglerCompartments.effects.supplyCostExtra;

// Officer surgeon supply cost
if (hasOfficer(gs, 'surgeon')) rate += CONFIG.officers.surgeon.effects.supplyCostExtra;

// Apply season supply cost multiplier
const seasonMods = getSeasonModifiers(gs);
rate *= (seasonMods.supplyCostMult || 1);
return rate;
}

// ==================== LIVING SEA: SHIP CONDITION SYSTEM ====================
function getShipHull(gs) {
    return gs.player.ship?.hull ?? 100;
}

function getShipRigging(gs) {
    return gs.player.ship?.rigging ?? 100;
}

function getShipMorale(gs) {
    return gs.player.ship?.morale ?? 100;
}

function getMaxHull(gs) {
    const shipClass = CONFIG.shipClasses[gs.player.shipClass] || CONFIG.shipClasses.brigantine;
    return shipClass.hullMax;
}

function getMaxRigging(gs) {
    const shipClass = CONFIG.shipClasses[gs.player.shipClass] || CONFIG.shipClasses.brigantine;
    return shipClass.riggingMax;
}

function getMaxMorale(gs) {
    let max = 100;
    if (hasOfficer(gs, 'surgeon')) max += CONFIG.officers.surgeon.effects.maxMoraleBonus;
    return max;
}

function damageHull(gs, amount) {
    if (!gs.player.ship) gs.player.ship = { hull: 100, rigging: 100, morale: 100 };
    gs.player.ship.hull = Math.max(0, gs.player.ship.hull - amount);
    if (CONFIG.debug.logWear) console.log(`[Wear] Hull -${amount} = ${gs.player.ship.hull}`);
}

function damageRigging(gs, amount) {
    if (!gs.player.ship) gs.player.ship = { hull: 100, rigging: 100, morale: 100 };
    // Bosun reduces rigging wear
    if (hasOfficer(gs, 'bosun')) amount *= CONFIG.officers.bosun.effects.riggingWearMult;
    gs.player.ship.rigging = Math.max(0, gs.player.ship.rigging - amount);
    if (CONFIG.debug.logWear) console.log(`[Wear] Rigging -${amount} = ${gs.player.ship.rigging}`);
}

function damageMorale(gs, amount) {
    if (!gs.player.ship) gs.player.ship = { hull: 100, rigging: 100, morale: 100 };
    // Bosun's strict discipline affects morale
    if (hasOfficer(gs, 'bosun')) amount += CONFIG.officers.bosun.effects.moralePenalty * 0.1;
    gs.player.ship.morale = Math.max(0, gs.player.ship.morale - amount);
    if (CONFIG.debug.logWear) console.log(`[Wear] Morale -${amount} = ${gs.player.ship.morale}`);
}

function repairHull(gs, amount, atSea = false) {
    if (!gs.player.ship) return;
    // Sea repairs less effective with low hull
    if (atSea && gs.player.ship.hull < CONFIG.shipCondition.criticalThreshold) {
        amount *= (1 - CONFIG.shipCondition.lowHullRepairPenalty);
    }
    gs.player.ship.hull = Math.min(getMaxHull(gs), gs.player.ship.hull + amount);
}

function repairRigging(gs, amount) {
    if (!gs.player.ship) return;
    gs.player.ship.rigging = Math.min(getMaxRigging(gs), gs.player.ship.rigging + amount);
}

function restoreMorale(gs, amount) {
    if (!gs.player.ship) return;
    // Surgeon improves morale recovery
    if (hasOfficer(gs, 'surgeon')) amount *= CONFIG.officers.surgeon.effects.moraleRecovery;
    gs.player.ship.morale = Math.min(getMaxMorale(gs), gs.player.ship.morale + amount);
}

function applyDailyWear(gs, isStorm = false, windStrength = 0) {
    const sc = CONFIG.shipCondition;
    const seasonMods = getSeasonModifiers(gs);

    // Hull wear
    let hullWear = sc.hullWearBase;
    if (isStorm) hullWear += sc.hullWearStorm;
    // Cargo overload
    const cargoUsed = getCargoUsed(gs);
    const capacity = getCargoCapacity(gs);
    if (cargoUsed > capacity * 0.9) hullWear += sc.hullWearOverload;
    damageHull(gs, hullWear);

    // Rigging wear
    let riggingWear = sc.riggingWearBase;
    if (isStorm) riggingWear += sc.riggingWearStorm;
    if (windStrength >= 3) riggingWear += sc.riggingWearHighWind;
    damageRigging(gs, riggingWear);

    // Morale wear
    let moraleWear = sc.moraleWearBase;
    // Doldrums season
    if (seasonMods.speedMult && seasonMods.speedMult < 1) moraleWear += sc.moraleDoldrumsExtra;
    // Low supplies
    if (gs.player.supplies < 10) moraleWear += sc.moraleLowSuppliesExtra;
    damageMorale(gs, moraleWear);
}

function getRepairCost(gs, type, amount = 0) {
    const sc = CONFIG.shipCondition;
    const shipClass = CONFIG.shipClasses[gs.player.shipClass] || CONFIG.shipClasses.brigantine;
    let cost = 0;

    if (type === 'hull') cost = amount * sc.dockRepairCostHull;
    else if (type === 'rigging') cost = amount * sc.dockRepairCostRigging;
    else if (type === 'rest' || type === 'morale') {
        // Scale morale cost with amount, minimum 5g
        cost = Math.max(5, Math.ceil(amount * 0.5)) + 5;
    }

    // Ship class cost multiplier
    cost *= shipClass.repairCostMult || 1;

    // Bosun discount
    if (hasOfficer(gs, 'bosun')) cost *= (1 - (CONFIG.officers.bosun?.effects?.repairDiscount || 0));

    // Minimum cost of 1g for any repair
    return Math.max(1, Math.ceil(cost));
}

function isShipCritical(gs) {
    const sc = CONFIG.shipCondition;
    return getShipHull(gs) < sc.criticalThreshold ||
           getShipRigging(gs) < sc.criticalThreshold ||
           getShipMorale(gs) < sc.criticalThreshold;
}

function checkMutinyRisk(gs) {
    if (getShipMorale(gs) < CONFIG.shipCondition.criticalThreshold) {
        if (Math.random() < CONFIG.shipCondition.lowMoraleMutinyChance) {
            return true;
        }
    }
    return false;
}

// ==================== LIVING SEA: OFFICERS SYSTEM ====================
function hasOfficer(gs, role) {
    return gs.player.officers?.some(o => o.role === role) || false;
}

function getOfficer(gs, role) {
    return gs.player.officers?.find(o => o.role === role) || null;
}

function hireOfficer(gs, officerId) {
    const officerConfig = CONFIG.officers[officerId];
    if (!officerConfig) return { success: false, reason: 'Unknown officer type' };
    if (gs.player.officers.length >= 3) return { success: false, reason: 'Crew full (max 3 officers)' };
    if (hasOfficer(gs, officerConfig.role)) return { success: false, reason: 'Already have this role' };

    const officer = {
        id: officerId,
        role: officerConfig.role,
        name: generateOfficerName(officerConfig.role),
        hiredDay: gs.player.days,
        wage: officerConfig.baseWage
    };

    gs.player.officers.push(officer);
    return { success: true, officer };
}

function fireOfficer(gs, officerId) {
    const index = gs.player.officers.findIndex(o => o.id === officerId || o.role === officerId);
    if (index >= 0) {
        gs.player.officers.splice(index, 1);
        return true;
    }
    return false;
}

function getOfficerWages(gs) {
    return gs.player.officers?.reduce((total, o) => {
        const config = Object.values(CONFIG.officers).find(c => c.role === o.role);
        return total + (config?.baseWage || 5);
    }, 0) || 0;
}

function generateOfficerName(role) {
    const firstNames = ['James', 'William', 'Thomas', 'Edward', 'John', 'Mary', 'Anne', 'Elizabeth', 'Grace', 'Sarah'];
    const lastNames = ['Blackwood', 'Stormwind', 'Ironside', 'Wavecrest', 'Saltborne', 'Tidebringer', 'Keel', 'Compass'];
    return `${firstNames[Math.floor(Math.random() * firstNames.length)]} ${lastNames[Math.floor(Math.random() * lastNames.length)]}`;
}

function getAvailableOfficersAtPort(gs, islandId) {
    // Generate 1-2 random officers available at this port
    const allOfficers = Object.keys(CONFIG.officers);
    const available = [];
    const count = 1 + Math.floor(Math.random() * 2);

    for (let i = 0; i < count && i < allOfficers.length; i++) {
        const idx = Math.floor(Math.random() * allOfficers.length);
        const officerId = allOfficers[idx];
        const cfg = CONFIG.officers[officerId];
        if (!available.some(o => o.type === officerId) && !hasOfficer(gs, cfg.role)) {
            available.push({
                type: officerId,
                name: generateOfficerName(cfg.role)
            });
        }
    }
    return available;
}

// ==================== LIVING SEA: CHASE ENCOUNTER SYSTEM ====================
function calculateEscapeChance(gs) {
    const chase = CONFIG.chase;
    const shipClass = CONFIG.shipClasses[gs.player.shipClass] || CONFIG.shipClasses.brigantine;

    let chance = chase.baseEscapeChance;

    // Ship class bonus
    chance += shipClass.escapeBonus;

    // Wind factor
    const windStr = gs.wind?.strength || 0;
    chance += windStr * chase.windSpeedFactor;

    // Cargo weight penalty
    const cargoUsed = getCargoUsed(gs);
    chance -= cargoUsed * chase.cargoWeightPenalty;

    // Rigging condition
    const rigging = getShipRigging(gs);
    if (rigging < CONFIG.shipCondition.criticalThreshold) {
        chance -= CONFIG.shipCondition.lowRiggingEscapePenalty;
    } else {
        chance += (rigging - 50) * chase.riggingFactor;
    }

    // Gunner officer makes fighting more attractive but doesn't help escape
    // Navigator helps with escape
    if (hasOfficer(gs, 'navigator')) chance += 0.1;

    // Bounty level makes escape harder
    const bountyLevel = getBountyLevel(gs);
    if (bountyLevel === 'wanted') chance -= 0.05;
    else if (bountyLevel === 'hunted') chance -= 0.1;
    else if (bountyLevel === 'infamous') chance -= 0.15;

    return Math.max(0.1, Math.min(0.9, chance));
}

function getChaseDuration(gs) {
    const chase = CONFIG.chase;
    const shipClass = CONFIG.shipClasses[gs.player.shipClass] || CONFIG.shipClasses.brigantine;

    // Base duration modified by ship speed
    let duration = chase.baseDuration;
    duration -= (shipClass.baseSpeed - 1) * 3000; // Faster ships = shorter chase

    // Cargo slows you down
    const cargoUsed = getCargoUsed(gs);
    duration += cargoUsed * 50;

    return Math.max(chase.minDuration, Math.min(chase.maxDuration, duration));
}

// ==================== LIVING SEA: COVE RUMORS ====================
function getCoveRumor(gs) {
    const undiscovered = Object.keys(CONFIG.hiddenCoves).filter(id => !isCoveDiscovered(gs, id));
    if (undiscovered.length === 0) return null;

    const coveId = undiscovered[Math.floor(Math.random() * undiscovered.length)];
    const cove = CONFIG.hiddenCoves[coveId];
    return { coveId, hint: cove.discoveryHint };
}

// ==================== LIVING SEA: BOUNTY HUNTER SYSTEM ====================
function spawnBountyHunter(gs) {
    const bountyLevel = getBountyLevel(gs);
    const hunters = CONFIG.bountyHunters.hunters;

    // Get undefeated hunters
    const available = hunters.filter((h, i) => !gs.player.huntersDefeated.includes(i));
    if (available.length === 0) return null;

    // Pick based on bounty level
    let hunterIndex = 0;
    if (bountyLevel === 'infamous') {
        hunterIndex = Math.min(available.length - 1, gs.player.stats.huntersDefeated || 0);
    }

    return { ...available[Math.min(hunterIndex, available.length - 1)], index: hunters.indexOf(available[hunterIndex]) };
}

function defeatHunter(gs, hunterIndex) {
    if (!gs.player.huntersDefeated.includes(hunterIndex)) {
        gs.player.huntersDefeated.push(hunterIndex);
        gs.player.stats.huntersDefeated = (gs.player.stats.huntersDefeated || 0) + 1;
    }
}

function getPardonCost(gs, islandId) {
    const island = CONFIG.islands[islandId];
    if (!island) return null;

    const faction = island.faction;
    if (faction === 'pirates') return null; // Pirates don't offer pardons

    const costs = CONFIG.bountyHunters.pardonCosts[faction] || CONFIG.bountyHunters.pardonCosts.neutral;
    const bounty = getBounty(gs);

    return Math.ceil(costs.base + bounty * costs.perBounty);
}

function grantPardon(gs) {
    gs.player.bounty = 0;
    gs.player.huntersDefeated = [];
}

// ==================== LIVING SEA: QUESTLINE SYSTEM ====================
function startQuestline(gs, questlineId) {
    const questline = CONFIG.questlines[questlineId];
    if (!questline) return { success: false, reason: 'Unknown questline' };
    if (gs.player.activeQuestline) return { success: false, reason: 'Already on a questline' };

    gs.player.activeQuestline = questlineId;
    gs.player.questlineProgress[questlineId] = {
        currentStep: 0,
        startDay: gs.player.days,
        stepProgress: {}
    };

    return { success: true, questline };
}

function getQuestlineProgress(gs) {
    if (!gs.player.activeQuestline) return null;
    const questlineId = gs.player.activeQuestline;
    const questline = CONFIG.questlines[questlineId];
    const progress = gs.player.questlineProgress[questlineId];

    if (!questline || !progress) return null;

    const currentStep = questline.steps[progress.currentStep];
    const daysRemaining = questline.deadline - (gs.player.days - progress.startDay);

    return {
        questlineId,
        questline,
        currentStep,
        stepIndex: progress.currentStep,
        totalSteps: questline.steps.length,
        daysRemaining,
        stepProgress: progress.stepProgress
    };
}

function advanceQuestline(gs) {
    const progress = getQuestlineProgress(gs);
    if (!progress) return { success: false };

    const questlineId = gs.player.activeQuestline;
    gs.player.questlineProgress[questlineId].currentStep++;
    gs.player.questlineProgress[questlineId].stepProgress = {};

    // Check if completed
    if (gs.player.questlineProgress[questlineId].currentStep >= progress.questline.steps.length) {
        return completeQuestline(gs);
    }

    return { success: true, advanced: true };
}

function completeQuestline(gs) {
    const questlineId = gs.player.activeQuestline;
    const questline = CONFIG.questlines[questlineId];
    if (!questline) return { success: false };

    const rewards = questline.rewards;

    // Apply rewards
    if (rewards.gold) gs.player.gold += rewards.gold;
    if (rewards.reputation) {
        Object.entries(rewards.reputation).forEach(([fid, amount]) => {
            applyRepChange(gs, fid, amount, 'questline_' + questlineId);
        });
    }
    if (rewards.pardon) grantPardon(gs);
    if (rewards.unlocks) discoverCove(gs, rewards.unlocks);

    // Mark questline as completed (prevents repeat, unlocks next tier)
    gs.player.questlineProgress[questlineId].completed = true;
    gs.player.activeQuestline = null;

    return { success: true, completed: true, rewards };
}

function failQuestline(gs) {
    gs.player.activeQuestline = null;
    return { success: true, failed: true };
}

function checkQuestlineDeadline(gs) {
    const progress = getQuestlineProgress(gs);
    if (!progress) return false;

    if (progress.daysRemaining <= 0) {
        failQuestline(gs);
        return true;
    }
    return false;
}

// Check and advance questline step based on event
function checkQuestlineStep(gs, event, eventData = {}) {
    const progress = getQuestlineProgress(gs);
    if (!progress) return { advanced: false };

    const step = progress.currentStep;
    if (!step) return { advanced: false };

    // Only check on dock events
    if (event !== 'dock' || !eventData.islandId) {
        return { advanced: false };
    }

    const qProgress = gs.player.questlineProgress[progress.questlineId];

    switch (step.type) {
        case 'deliver_count':
            // Repeated delivery task - check if at right island with goods
            if (step.to === eventData.islandId && step.goods) {
                const hasGoods = Object.entries(step.goods).every(([gid, qty]) =>
                    (gs.player.cargo[gid] || 0) >= qty
                );
                if (hasGoods) {
                    // Anti-cheese: goods must be from a different island than destination
                    const purchaseLocs = gs.player.purchaseLocations || {};
                    const goodsFromHere = Object.keys(step.goods).some(gid =>
                        purchaseLocs[gid] === eventData.islandId
                    );
                    if (goodsFromHere) {
                        return {
                            advanced: false,
                            blocked: true,
                            message: 'Goods must be sourced from another port!'
                        };
                    }

                    // Remove delivered goods
                    Object.entries(step.goods).forEach(([gid, qty]) => {
                        gs.player.cargo[gid] = (gs.player.cargo[gid] || 0) - qty;
                        // Clear purchase location for delivered goods
                        if (gs.player.cargo[gid] <= 0 && gs.player.purchaseLocations) {
                            delete gs.player.purchaseLocations[gid];
                        }
                    });
                    // Increment delivery count
                    qProgress.stepProgress.delivered = (qProgress.stepProgress.delivered || 0) + 1;
                    const delivered = qProgress.stepProgress.delivered;
                    const needed = step.count || 1;
                    // Give per-delivery reward
                    const reward = step.reward || 0;
                    if (reward > 0) gs.player.gold += reward;

                    if (delivered >= needed) {
                        // Step complete - move to next
                        qProgress.stepProgress = {}; // Reset for next step
                        const result = advanceQuestline(gs);
                        return {
                            advanced: true,
                            completed: result.completed,
                            rewards: result.rewards,
                            stepDone: true,
                            message: `${step.desc} complete!`,
                            reward: reward
                        };
                    } else {
                        // Partial progress
                        return {
                            advanced: false,
                            progress: true,
                            delivered: delivered,
                            needed: needed,
                            message: `Delivery ${delivered}/${needed}`,
                            reward: reward
                        };
                    }
                }
            }
            break;

        case 'collect':
            // Final collection step - just visit the island
            if (step.at === eventData.islandId) {
                qProgress.stepProgress = {};
                const result = advanceQuestline(gs);
                return {
                    advanced: true,
                    completed: result.completed,
                    rewards: result.rewards,
                    stepDone: true,
                    message: 'Payment collected!'
                };
            }
            break;

        case 'deliver':
            // Single delivery (legacy support)
            const atDestination = !step.to || step.to === eventData.islandId;
            if (atDestination && step.goods) {
                const hasGoods = Object.entries(step.goods).every(([gid, qty]) =>
                    (gs.player.cargo[gid] || 0) >= qty
                );
                if (hasGoods) {
                    Object.entries(step.goods).forEach(([gid, qty]) => {
                        gs.player.cargo[gid] = (gs.player.cargo[gid] || 0) - qty;
                    });
                    const result = advanceQuestline(gs);
                    return { advanced: true, completed: result.completed, rewards: result.rewards, stepDone: true };
                }
            }
            break;

        case 'visit':
            if (!step.at || step.at === eventData.islandId) {
                const result = advanceQuestline(gs);
                return { advanced: true, completed: result.completed, rewards: result.rewards, stepDone: true };
            }
            break;
    }

    return { advanced: false };
}

// Category-aware capacity check: luxury locker gives bonus for luxury, penalty for commodity
function getCategoryCapacity(gs, category) {
let cap = getCargoCapacity(gs);
// luxuryLocker: +8 for luxury, -3 for commodity
if (gs.player.upgrades?.luxuryLocker) {
if (category === 'luxury') cap += CONFIG.upgrades.luxuryLocker.effects.luxuryCapBonus;
else if (category === 'commodity') cap -= CONFIG.upgrades.luxuryLocker.effects.commodityCapPenalty;
}
return Math.max(0, cap);
}

// Check if player can carry more of a specific good (category-aware)
function canCarryMore(gid, qty, gs) {
const good = CONFIG.goods[gid];
const currentUsed = getCargoUsed(gs);
const catCap = getCategoryCapacity(gs, good.category);
const catUsed = getCargoUsedByCategory(gs, good.category);
const newWeight = good.weight * qty;
// Check total capacity and category-specific capacity
const totalOk = currentUsed + newWeight <= getCargoCapacity(gs);
const catOk = catUsed + newWeight <= catCap;

return { canCarry: totalOk && catOk, reason: !totalOk ? 'Hold full' : !catOk ? 'Category limit' : null };

}

function getCargoUsed(gs) {
let t = 0;
Object.entries(gs.player.cargo).forEach(([g, q]) => t += (CONFIG.goods[g]?.weight || 1) * q);
return t;
}

function getCargoUsedByCategory(gs, category) {
let t = 0;
Object.entries(gs.player.cargo).forEach(([gid, q]) => {
const g = CONFIG.goods[gid];
if (g && g.category === category) t += g.weight * q;
});
return t;
}

// Wind effect on speed
function getWindEffect(gs, moveDir) {
if (!gs.wind) return { mult: 1, label: '' };
const wd = WIND_DIRS[gs.wind.direction], ws = WIND_STR[gs.wind.strength];
if (ws.m === 0) return { mult: 1, label: '' };
const dot = moveDir.x * wd.v.x + moveDir.z * wd.v.z;
const bonus = gs.player.upgrades?.swiftSails ? CONFIG.upgrades.swiftSails.effects.windBonus : 0;
if (dot > 0.5) return { mult: 1 + ws.m * (1 + bonus), label: `+${Math.round(ws.m * (1 + bonus) * 100)}%` };
if (dot < -0.5) return { mult: 1 - ws.m * 0.7, label: `-${Math.round(ws.m * 70)}%` };
return { mult: 1, label: '' };
}

// Cargo protection (fights, storms)
function calcCargoLoss(gs, base) {
if (gs.player.upgrades?.reinforcedHold) base *= (1 - CONFIG.upgrades.reinforcedHold.effects.cargoProtection);
return base;
}

// Gold loss protection
function calcGoldLoss(gs, base) {
if (gs.player.upgrades?.vault) base *= (1 - CONFIG.upgrades.vault.effects.goldProtection);
return Math.floor(base);
}

// Tribute cost reduction
function calcTributeCost(gs, base) {
if (gs.player.upgrades?.vault) base *= (1 - CONFIG.upgrades.vault.effects.tributeReduction);
const fc = CONFIG.factions[gs.player.faction];
if (fc.tributeMult) base *= fc.tributeMult;
// Title modifiers
const mods = getTitleModifiers(gs);
base *= (1 - mods.tributeReduction);
return Math.floor(base);
}

// ==================== RISK & VALUE HELPERS ====================
// Estimate cargo value using recorded prices or base prices
// IMPORTANT: Do NOT call calcPrice here - it causes circular dependency:
// estimateCargoValue  calcPrice  calcTariff  getTitleModifiers  getTitleTier  getTitleTrackValue  getNetWorth  estimateCargoValue
function estimateCargoValue(gs) {
let value = 0;
const iid = gs.currentIsland;
Object.entries(gs.player.cargo).forEach(([gid, qty]) => {
let price = CONFIG.goods[gid].basePrice;
// Use recorded prices only - never call calcPrice to avoid circular dependency
if (iid && gs.player.visitedIslands?.[iid]?.lastPrices?.[gid]) {
    // Use last recorded price for current island
    price = gs.player.visitedIslands[iid].lastPrices[gid];
} else if (gs.player.visitedIslands) {
    // Use any known recorded price from visited islands
    for (const vid of Object.keys(gs.player.visitedIslands)) {
        const lp = gs.player.visitedIslands[vid]?.lastPrices?.[gid];
        if (lp) { price = lp; break; }
    }
}
// Falls back to CONFIG.goods[gid].basePrice if no recorded prices
value += price * qty;
});
return value;
}

function getNetWorth(gs) {
    return gs.player.gold + estimateCargoValue(gs);
}

// Route risk score (0-1): influenced by cargo value, faction, destination, heat
function getRouteRisk(gs) {
let risk = 0;
// Cargo value contribution (0-0.4)
const cargoVal = estimateCargoValue(gs);
risk += Math.min(0.4, cargoVal / 2000);

// Faction contribution (0-0.15)
if (gs.player.faction === 'pirates') risk += 0.1;
else if (gs.player.faction === 'eitc') risk += 0.05;

// Destination faction waters (0-0.15)
if (gs.player.destinationIslandId) {
    const destFaction = CONFIG.islands[gs.player.destinationIslandId]?.faction;
    if (destFaction === 'pirates') risk += 0.15;
    else if (destFaction === 'english' || destFaction === 'eitc') risk += 0.05;
}

// Heat contribution (0-0.2)
risk += (gs.player.heat || 0) / 500;

// Days since dock contribution (0-0.1)
risk += Math.min(0.1, (gs.player.daysSinceDock || 0) / 20);

return Math.min(1, Math.max(0, risk));

}

function getRiskLabel(risk) {
if (risk < 0.3) return { label: 'Low', class: 'risk-low' };
if (risk < 0.6) return { label: 'Med', class: 'risk-med' };
return { label: 'High', class: 'risk-high' };
}

// Check if near English/EITC controlled waters (for inspections)
function isNearHostileWaters(gs) {
const pp = gs.player.position;
for (const [id, isl] of Object.entries(CONFIG.islands)) {
if (isl.faction === 'english' || isl.faction === 'eitc') {
const dist = Math.sqrt((isl.position.x - pp.x)**2 + (isl.position.z - pp.z)**2);
if (dist < 100) return true;
}
}
return false;
}

// Count contraband in cargo
function getContrabandCount(gs) {
let count = 0;
Object.entries(gs.player.cargo).forEach(([gid, qty]) => {
if (CONFIG.goods[gid]?.category === 'contraband') count += qty;
});
return count;
}

// ==================== HEAT SYSTEM ====================
function addHeat(gs, amount) {
gs.player.heat = Math.min(100, Math.max(0, (gs.player.heat || 0) + amount));
}

function decayHeat(gs) {
gs.player.heat = Math.max(0, (gs.player.heat || 0) - CONFIG.settings.heatDecayPerDay);
}

// Balanced heat decay - slower at sea, faster when docked at friendly ports
function decayHeatBalanced(gs, isDocked = false, isFriendlyPort = false) {
    const smug = CONFIG.balance.smuggling;
    let decay = smug.heatDecayBase;
    if (!isDocked) {
        // At sea: slower decay
        decay = smug.heatDecayAtSea;
    } else if (isFriendlyPort) {
        // Docked at friendly port: faster decay
        decay = smug.heatDecayBase * 2;
    }
    gs.player.heat = Math.max(0, (gs.player.heat || 0) - decay);
}

// ==================== ECONOMY ====================
// Base market price without player-specific bonuses (used for logbook/intel)
function calcBasePrice(gid, iid, gs) {
const g = CONFIG.goods[gid], isl = gs.islands[iid], m = isl?.markets?.[gid];
if (!g || !m) return g?.basePrice || 0;
const scarcity = Math.max(0.5, Math.min(2, 1 + (m.targetSupply - m.supply) / m.targetSupply));
const demand = Math.max(0.5, Math.min(2, 1 + (m.demand - m.targetDemand) / m.targetDemand));
let bias = m.preference === 'exports' ? 0.8 : m.preference === 'imports' ? 1.2 : 1;
const tariff = calcTariff(gs.player.faction, isl.faction, gs, iid);
let evMult = 1;
if (isl.activeEvent) { const ev = CONFIG.events.find(e => e.id === isl.activeEvent.id); if (ev?.affects.includes(g.category)) evMult = ev.multiplier; }

// Regional event multiplier
if (gs.world?.regionalEvent?.affectedIslands?.includes(iid)) {
    const catMult = gs.world.regionalEvent.categoryMult[g.category];
    if (catMult) evMult *= catMult;
}

// Port state effects
const portState = getPortStateConfig(gs, iid);
let portMult = portState.priceMult || 1;
if (portState.foodMult && g.category === 'commodity') portMult *= portState.foodMult;
if (portState.smugglerBonus && g.category === 'contraband') portMult *= portState.smugglerBonus;
if (portState.materialBonus && (gid === 'timber' || gid === 'iron')) portMult *= portState.materialBonus;

// Season effects on prices
const seasonMods = getSeasonModifiers(gs);
let seasonMult = seasonMods.priceMult || 1;

// Seasonal event effects
if (gs.world?.seasonalEvent?.effects) {
    const seFx = gs.world.seasonalEvent.effects;
    if (seFx[g.category]) seasonMult *= seFx[g.category];
    if (seFx.luxury && g.category === 'luxury') seasonMult *= seFx.luxury;
}

return Math.max(1, Math.round(g.basePrice * scarcity * demand * bias * tariff * evMult * portMult * seasonMult));
}

// Buy price: player bonuses REDUCE price (discounts help buying)
function calcBuyPrice(gid, iid, gs) {
const base = calcBasePrice(gid, iid, gs);
const g = CONFIG.goods[gid];
let discount = 1;

// EITC gets 5% discount when BUYING
if (gs.player.faction === 'eitc') discount *= 0.95;

// Pirates get 50% discount on contraband when BUYING (underworld connections)
if (gs.player.faction === 'pirates' && g?.category === 'contraband') discount *= 0.5;

// Smuggler compartments: 10% discount on contraband when buying
if (gs.player.upgrades?.smugglerCompartments && g?.category === 'contraband') {
    discount *= (1 - CONFIG.upgrades.smugglerCompartments.effects.contrabandProfitBonus);
}

// Merchant favor: 2% discount per point, max 10%
const favor = gs.player.merchantFavor || 0;
if (favor > 0) {
    discount *= (1 - Math.min(0.10, favor * 0.02));
}

return Math.max(1, Math.round(base * discount));
}

// Sell price: player bonuses INCREASE price (bonuses help selling)
function calcSellPrice(gid, iid, gs) {
const base = calcBasePrice(gid, iid, gs);
const g = CONFIG.goods[gid];
let bonus = 1;

// EITC gets 5% bonus when SELLING (better negotiation)
if (gs.player.faction === 'eitc') bonus *= 1.05;

// Pirates get 50% bonus on contraband when SELLING (know the black market)
if (gs.player.faction === 'pirates' && g?.category === 'contraband') bonus *= 1.5;

// Smuggler compartments: 10% bonus on contraband when selling
if (gs.player.upgrades?.smugglerCompartments && g?.category === 'contraband') {
    bonus *= (1 + CONFIG.upgrades.smugglerCompartments.effects.contrabandProfitBonus);
}

// === META PRESSURE: Good bias reduces prices (markets flooded with your favorite goods) ===
const metaMods = metaGetModifiers(gs, { good: gid });
bonus *= metaMods.priceMultSell;

return Math.max(1, Math.round(base * bonus));
}

// Legacy function for backward compatibility (uses base price)
function calcPrice(gid, iid, gs) {
return calcBasePrice(gid, iid, gs);
}

function calcTariff(pf, if_, gs, iid = null) {
if (if_ === 'neutral' || pf === if_) return 1;
const rep = gs.player.reputation[if_] || 0;
let t = 1 + (CONFIG.factions[if_]?.taxRate || 0);
if (rep < -50) t += 0.3; else if (rep < -20) t += 0.15; else if (rep > 50) t -= 0.1;
// Title modifier
const mods = getTitleModifiers(gs);
t *= (1 - mods.tariffReduction);
// Port state tariff multiplier (blockaded = higher tariffs, lawless = no tariffs)
if (iid) {
    const portState = getPortStateConfig(gs, iid);
    t *= (portState.tariffMult ?? 1);
}
return Math.max(0.9, Math.min(2, t));
}

function buyGood(gid, qty, iid, gs) {
const m = gs.islands[iid].markets[gid], g = CONFIG.goods[gid];
// === BALANCE: Apply anti-spam price increase ===
const antiSpamMult = getAntiSpamBuyMult(gs, iid, qty);
const price = Math.max(1, Math.round(calcBuyPrice(gid, iid, gs) * antiSpamMult));

const check = canCarryMore(gid, qty, gs);
if (qty > m.supply || price * qty > gs.player.gold || !check.canCarry) return { success: false, reason: check.reason };
gs.player.gold -= price * qty;
gs.player.cargo[gid] = (gs.player.cargo[gid] || 0) + qty;
gs.player.purchaseHistory[gid] = price;
// Track where goods were purchased (for questline anti-cheese)
if (!gs.player.purchaseLocations) gs.player.purchaseLocations = {};
gs.player.purchaseLocations[gid] = iid;
m.supply -= qty;
recordPrice(gid, iid, calcBasePrice(gid, iid, gs), gs); // Record base price for logbook
// === BALANCE: Track trade fatigue ===
addTradeFatigue(gs, iid);
// === LIVING SEA: Apply faction influence ===
applyTradeInfluence(gs, iid, gs.player.faction);
// Heat for buying contraband
if (g.category === 'contraband') addHeat(gs, CONFIG.settings.heatGainContraband);
return { success: true, cost: price * qty };
}

function sellGood(gid, qty, iid, gs) {
const stock = gs.player.cargo[gid] || 0, g = CONFIG.goods[gid];
if (qty > stock) return { success: false, reason: 'Not enough stock' };

// Fence limit check for contraband
if (g.category === 'contraband') {
    const fenceRemaining = getFenceRemaining(gs, iid);
    if (qty > fenceRemaining) {
        return { success: false, reason: `Fence can only take ${fenceRemaining} more units today` };
    }
}

// Calculate price with saturation penalty AND anti-spam penalty
let price = calcSellPrice(gid, iid, gs);
const satPenalty = getSaturationPenalty(gs, iid, gid);
// === BALANCE: Apply anti-spam sell penalty ===
const antiSpamMult = getAntiSpamSellMult(gs, iid, qty);
price = Math.max(1, Math.round(price * satPenalty * antiSpamMult));

const revenue = price * qty;
gs.player.gold += revenue;
gs.player.cargo[gid] = stock - qty;
if (gs.player.cargo[gid] <= 0) delete gs.player.cargo[gid];
gs.islands[iid].markets[gid].supply += qty;
recordPrice(gid, iid, calcBasePrice(gid, iid, gs), gs); // Record base price for logbook

// Add market saturation
addMarketSaturation(gs, iid, gid, qty);

// === BALANCE: Track trade fatigue ===
addTradeFatigue(gs, iid);

// === META PRESSURE: Record profitable trade ===
const purchasePrice = gs.player.purchaseHistory[gid] || 0;
const profit = (price - purchasePrice) * qty;
if (profit > 0) {
    metaRecordTrade(gs, gid, profit);
}

// === LIVING SEA: Apply faction influence ===
applyTradeInfluence(gs, iid, gs.player.faction);

// Heat and tracking for contraband
if (g.category === 'contraband') {
    // Enhanced heat gain with scaling
    const smug = CONFIG.balance.smuggling;
    const heatGain = smug.heatGainBase + (qty * smug.heatGainPerUnit);
    addHeat(gs, heatGain);

    // Track fence usage
    addFenceUsage(gs, iid, qty);

    // Track for smuggler title
    if (!gs.player.stats) gs.player.stats = {};
    gs.player.stats.contrabandTraded = (gs.player.stats.contrabandTraded || 0) + qty;

    // === LIVING SEA: Smuggling destabilizes region ===
    applySmuggleInfluence(gs, iid);
}
return { success: true, revenue };
}

function recordPrice(gid, iid, price, gs) {
if (!gs.player.visitedIslands[iid]) gs.player.visitedIslands[iid] = { lastPrices: {}, lastVisitDay: 0 };
gs.player.visitedIslands[iid].lastPrices[gid] = price;
gs.player.visitedIslands[iid].lastVisitDay = gs.player.days;
}

function recordAllPrices(iid, gs) { Object.keys(CONFIG.goods).forEach(gid => recordPrice(gid, iid, calcPrice(gid, iid, gs), gs)); }

function getPriceTrend(gid, iid, cp, gs) {
const v = gs.player.visitedIslands[iid];
if (!v?.lastPrices[gid]) return 'none';
const last = v.lastPrices[gid];
return cp > last * 1.05 ? 'up' : cp < last * 0.95 ? 'down' : 'stable';
}

function getConfidence(iid, gs) {
const v = gs.player.visitedIslands[iid];
if (!v) return { level: 'none', label: 'None', days: 999 };
const age = gs.player.days - v.lastVisitDay;
const bonus = gs.player.faction === 'eitc' ? 2 : 0;
if (age <= 3 + bonus) return { level: 'high', label: 'High', days: age };
if (age <= 7 + bonus) return { level: 'med', label: 'Med', days: age };
return { level: 'low', label: 'Low', days: age };
}

function simMarketDay(gs) {
Object.keys(gs.islands).forEach(id => {
const isl = gs.islands[id];
Object.keys(isl.markets).forEach(gid => {
const m = isl.markets[gid];
m.supply = Math.max(0, Math.min(m.targetSupply * 2, Math.round(m.supply + (m.targetSupply - m.supply) * 0.05 + (Math.random() - 0.5) * 4)));
m.demand = Math.max(0, Math.min(m.targetDemand * 2, Math.round(m.demand + (m.targetDemand - m.demand) * 0.03 + (Math.random() - 0.5) * 2)));
});
if (isl.activeEvent) { isl.activeEvent.daysRemaining--; if (isl.activeEvent.daysRemaining <= 0) isl.activeEvent = null; }
if (!isl.activeEvent && Math.random() < 0.08) {
const ev = CONFIG.events[Math.floor(Math.random() * CONFIG.events.length)];
isl.activeEvent = { id: ev.id, daysRemaining: ev.duration };
}
});
}

// Calculate deals and mark top 3 as high-margin candidates
function calcDeals(gs, iid) {
const deals = [], curPrices = {};
Object.keys(CONFIG.goods).forEach(gid => { curPrices[gid] = calcPrice(gid, iid, gs); });
Object.keys(gs.player.visitedIslands).forEach(did => {
if (did === iid) return;
const dData = gs.player.visitedIslands[did], conf = getConfidence(did, gs);
if (conf.level === 'none') return;
Object.keys(CONFIG.goods).forEach(gid => {
const g = CONFIG.goods[gid], bp = curPrices[gid], sp = dData.lastPrices[gid];
if (!sp) return;
const profit = sp - bp;
if (profit > 5) deals.push({ gid, good: g, buyIsland: iid, sellIsland: did, buyPrice: bp, sellPrice: sp, profit, profitPerWeight: profit / g.weight, confidence: conf });
});
});
return deals.sort((a, b) => b.profitPerWeight - a.profitPerWeight).slice(0, 5);
}

// Smarter high-margin detection: top 3 deals or profit/weight > threshold
function getHighMarginGoods(gs) {
if (!gs.currentIsland) return new Set();
const deals = calcDeals(gs, gs.currentIsland);
const highMargin = new Set();
// Top 3 by profit/weight
deals.slice(0, 3).forEach(d => highMargin.add(d.gid));
// Also anything above threshold
deals.forEach(d => {
if (d.profitPerWeight >= CONFIG.settings.highMarginThreshold) highMargin.add(d.gid);
});
return highMargin;
}

function getSafeSpawn(iid = 'portRoyal') {
const isl = CONFIG.islands[iid];
return { x: isl.position.x, z: isl.position.z + CONFIG.settings.islandCollisionRadius + 15 };
}

function createState(faction) {
const fc = CONFIG.factions[faction], islands = {};
Object.entries(CONFIG.islands).forEach(([id, cfg]) => {
const markets = {};
Object.entries(cfg.markets).forEach(([gid, mc]) => {
markets[gid] = { supply: mc.targetSupply + Math.floor((Math.random() - 0.5) * 20), demand: mc.targetDemand + Math.floor((Math.random() - 0.5) * 10), targetSupply: mc.targetSupply, targetDemand: mc.targetDemand, preference: mc.preference };
});
islands[id] = { id, name: cfg.name, faction: cfg.faction, markets, activeEvent: null };
});
return {
saveVersion: CONFIG.saveVersion,
player: {
faction, gold: CONFIG.settings.startingGold, days: 1, supplies: CONFIG.settings.startingSupplies,
cargo: {}, position: getSafeSpawn(), reputation: { ...fc.startingRep },
visitedIslands: {}, purchaseHistory: {}, upgrades: {}, destinationIslandId: null,
heat: 0, daysSinceDock: 0,
// New fields
titles: {},
stats: { contrabandTraded: 0, contractsCompleted: 0, repChanges: {}, chasesEscaped: 0, huntersDefeated: 0 },
contracts: { active: [], completed: [], failed: [] },
trackedContractId: null,
tokens: 0,
inspectionTriggeredThisContract: false,
// Living Sea Update fields
shipClass: 'brigantine',
ship: {
    hull: 100,
    rigging: 100,
    morale: 100
},
officers: [],
discoveredCoves: [],
chartFragments: 0,
covesTreasured: [],
destinationCoveId: null,
activeQuestline: null,
questlineProgress: {},
huntersDefeated: [],
// Meta Pressure tracking
meta: {
    recentRoutes: [],      // Last N route keys "PortA>PortB"
    recentGoods: [],       // Last N main profit goods traded
    recentPorts: [],       // Last N port IDs visited
    recentFactions: [],    // Last N faction territories interacted with
    routeCounts: {},       // Frequency map for routes in window
    goodCounts: {},        // Frequency map for goods in window
    portCounts: {},        // Frequency map for ports in window
    factionCounts: {},     // Frequency map for factions in window
    pressure: {            // Current pressure scores (0-1)
        route: 0,
        good: 0,
        port: 0,
        faction: 0,
        total: 0
    },
    lastPort: null,        // Track last port for route recording
    lastMilestones: { route: 0, good: 0, port: 0, faction: 0 }, // Track feedback milestones
    lastUpdateDay: 0       // Day of last pressure update
}
},
islands,
wind: { direction: Math.floor(Math.random() * 8), strength: Math.floor(Math.random() * 4), daysUntilChange: CONFIG.settings.windChangeDays },
world: {
    seasonDay: 1,
    crackdown: { level: 0 },
    regionalEvent: null,
    boards: {},
    // Living Sea fields
    driftEntities: [],
    portStates: {},
    rumors: {},
    seasonalEvent: null,
    // War front / influence tracking per island
    islandInfluence: {},
    activeBlockades: [],
    activeWarZones: []
},
currentIsland: null, isDocked: false
};
}

// Migrate old saves - add defaults for new fields
function migrateState(gs) {
if (!gs.player.purchaseHistory) gs.player.purchaseHistory = {};
if (!gs.player.upgrades) gs.player.upgrades = {};
if (gs.player.destinationIslandId === undefined) gs.player.destinationIslandId = null;
if (gs.player.heat === undefined) gs.player.heat = 0;
if (gs.player.daysSinceDock === undefined) gs.player.daysSinceDock = 0;
if (!gs.wind) gs.wind = { direction: Math.floor(Math.random() * 8), strength: Math.floor(Math.random() * 4), daysUntilChange: 5 };
if (gs.isDocked && !gs.currentIsland) gs.isDocked = false;

// New migrations for contracts/titles/world
if (!gs.player.titles) gs.player.titles = {};
if (!gs.player.stats) gs.player.stats = { contrabandTraded: 0, contractsCompleted: 0, repChanges: {} };
if (!gs.player.stats.contrabandTraded) gs.player.stats.contrabandTraded = 0;
if (!gs.player.stats.contractsCompleted) gs.player.stats.contractsCompleted = 0;
if (!gs.player.stats.repChanges) gs.player.stats.repChanges = {};
if (!gs.player.contracts) gs.player.contracts = { active: [], completed: [], failed: [] };
if (!gs.player.contracts.active) gs.player.contracts.active = [];
if (!gs.player.contracts.completed) gs.player.contracts.completed = [];
if (!gs.player.contracts.failed) gs.player.contracts.failed = [];
if (gs.player.trackedContractId === undefined) gs.player.trackedContractId = null;
if (gs.player.tokens === undefined) gs.player.tokens = 0;
if (gs.player.inspectionTriggeredThisContract === undefined) gs.player.inspectionTriggeredThisContract = false;

// World state
if (!gs.world) gs.world = {};
if (gs.world.seasonDay === undefined) gs.world.seasonDay = 1;
if (!gs.world.crackdown) gs.world.crackdown = { level: 0 };
if (gs.world.regionalEvent === undefined) gs.world.regionalEvent = null;
if (!gs.world.boards) gs.world.boards = {};

// === BALANCE: New state migrations ===
// Bounty/notoriety system
if (gs.player.bounty === undefined) gs.player.bounty = 0;
// Market saturation tracking { islandId: { goodId: saturationLevel } }
if (!gs.player.saturation) gs.player.saturation = {};
// Fence usage tracking { islandId: { units: number, lastVisitDay: number } }
if (!gs.player.fenceUsage) gs.player.fenceUsage = {};
// Track total upkeep paid
if (!gs.player.stats.totalUpkeep) gs.player.stats.totalUpkeep = 0;
// Port visit days for cooldown system { islandId: lastVisitDay }
if (!gs.player.portVisitDays) gs.player.portVisitDays = {};
// Trade fatigue per port (resets on undock) { islandId: transactionCount }
if (!gs.player.tradeFatigue) gs.player.tradeFatigue = {};

// Living Sea migrations
if (!gs.world.driftEntities) gs.world.driftEntities = [];
if (!gs.world.portStates) gs.world.portStates = {};
if (!gs.world.rumors) gs.world.rumors = {};
if (gs.world.seasonalEvent === undefined) gs.world.seasonalEvent = null;

// === LIVING SEA UPDATE v2 MIGRATIONS ===
// Save version tracking
if (gs.saveVersion === undefined) gs.saveVersion = 1;

// Ship class system
if (!gs.player.shipClass) gs.player.shipClass = 'brigantine';

// Ship condition system
if (!gs.player.ship) {
    const shipClass = CONFIG.shipClasses[gs.player.shipClass] || CONFIG.shipClasses.brigantine;
    gs.player.ship = {
        hull: shipClass.hullMax,
        rigging: shipClass.riggingMax,
        morale: 100
    };
}

// Officers system
if (!gs.player.officers) gs.player.officers = [];

// Exploration system
if (!gs.player.discoveredCoves) gs.player.discoveredCoves = [];
if (gs.player.chartFragments === undefined) gs.player.chartFragments = 0;
if (!gs.player.covesTreasured) gs.player.covesTreasured = [];
if (gs.player.destinationCoveId === undefined) gs.player.destinationCoveId = null;

// Questline system
if (gs.player.activeQuestline === undefined) gs.player.activeQuestline = null;
if (!gs.player.questlineProgress) gs.player.questlineProgress = {};

// Bounty hunter tracking
if (!gs.player.huntersDefeated) gs.player.huntersDefeated = [];
if (!gs.player.stats.chasesEscaped) gs.player.stats.chasesEscaped = 0;
if (!gs.player.stats.huntersDefeated) gs.player.stats.huntersDefeated = 0;

// Meta Pressure system migration
if (!gs.player.meta) {
    gs.player.meta = {
        recentRoutes: [],
        recentGoods: [],
        recentPorts: [],
        recentFactions: [],
        routeCounts: {},
        goodCounts: {},
        portCounts: {},
        factionCounts: {},
        pressure: { route: 0, good: 0, port: 0, faction: 0, total: 0 },
        lastPort: null,
        lastMilestones: { route: 0, good: 0, port: 0, faction: 0 },
        lastUpdateDay: 0
    };
}
// Ensure all meta pressure sub-fields exist (for partial migrations)
if (!gs.player.meta.pressure) gs.player.meta.pressure = { route: 0, good: 0, port: 0, faction: 0, total: 0 };
if (!gs.player.meta.lastMilestones) gs.player.meta.lastMilestones = { route: 0, good: 0, port: 0, faction: 0 };
if (!gs.player.meta.recentRoutes) gs.player.meta.recentRoutes = [];
if (!gs.player.meta.recentGoods) gs.player.meta.recentGoods = [];
if (!gs.player.meta.recentPorts) gs.player.meta.recentPorts = [];
if (!gs.player.meta.recentFactions) gs.player.meta.recentFactions = [];
if (!gs.player.meta.routeCounts) gs.player.meta.routeCounts = {};
if (!gs.player.meta.goodCounts) gs.player.meta.goodCounts = {};
if (!gs.player.meta.portCounts) gs.player.meta.portCounts = {};
if (!gs.player.meta.factionCounts) gs.player.meta.factionCounts = {};

// World war fronts
if (!gs.world.islandInfluence) gs.world.islandInfluence = {};
if (!gs.world.activeBlockades) gs.world.activeBlockades = [];
if (!gs.world.activeWarZones) gs.world.activeWarZones = [];

// Update save version
gs.saveVersion = CONFIG.saveVersion;

return gs;
}

// ==================== THREE.JS (ENHANCED GRAPHICS) ====================
class SceneManager {
constructor(canvas) {
    this.canvas = canvas;
    this.scene = new THREE.Scene();
    this.clock = new THREE.Clock();
    this.isDarkMode = document.documentElement.dataset.theme === 'dark';
    this.weatherState = 'clear'; // clear, storm, fog, rain
    this.timeOfDay = 0.5; // 0=midnight, 0.5=noon, 1=midnight

    // Enhanced renderer with shadows
    this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    this.renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
    this.renderer.toneMappingExposure = 1.0;
    this.updateSkyColor();

    // Enhanced camera with slight tilt for dynamic feel
    this.camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 1, 1500);
    this.camera.position.set(0, 90, 110);
    this.cameraShake = { x: 0, y: 0, intensity: 0 };

    // Enhanced lighting system
    this.setupLighting();

    // Create scene elements
    this.createSkyDome();
    this.createOcean();
    this.createIslands();
    this.createClouds();

    // Ship with wake effect
    this.ship = this.createShip();
    this.scene.add(this.ship);
    this.shipHeading = 0;
    this.shipSpeed = 0;
    this.wakeParticles = this.createWakeSystem();

    // Navigation course line on water
    this.navigationLine = this.createNavigationLine();
    this.currentDestination = null;

    // Ambient particles (sea spray, etc)
    this.ambientParticles = this.createAmbientParticles();

    addEventListener('resize', () => this.onResize());
    this.onResize();
}

setupLighting() {
    // Hemisphere light for sky/ground color blending
    this.hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x2d5a6a, 0.4);
    this.scene.add(this.hemiLight);

    // Main sun light with shadows
    this.sunLight = new THREE.DirectionalLight(0xfff5e0, 1.0);
    this.sunLight.position.set(80, 150, 60);
    this.sunLight.castShadow = true;
    this.sunLight.shadow.mapSize.width = 1024;
    this.sunLight.shadow.mapSize.height = 1024;
    this.sunLight.shadow.camera.near = 10;
    this.sunLight.shadow.camera.far = 400;
    this.sunLight.shadow.camera.left = -150;
    this.sunLight.shadow.camera.right = 150;
    this.sunLight.shadow.camera.top = 150;
    this.sunLight.shadow.camera.bottom = -150;
    this.sunLight.shadow.bias = -0.001;
    this.scene.add(this.sunLight);

    // Soft ambient for fill
    this.ambientLight = new THREE.AmbientLight(0xffeedd, 0.35);
    this.scene.add(this.ambientLight);

    // Rim light for dramatic effect
    this.rimLight = new THREE.DirectionalLight(0xffe0c0, 0.3);
    this.rimLight.position.set(-50, 50, -80);
    this.scene.add(this.rimLight);
}

createSkyDome() {
    const skyGeo = new THREE.SphereGeometry(800, 32, 16);
    const skyMat = new THREE.ShaderMaterial({
        uniforms: {
            topColor: { value: new THREE.Color(0x4a90c2) },
            bottomColor: { value: new THREE.Color(0x87ceeb) },
            offset: { value: 20 },
            exponent: { value: 0.6 }
        },
        vertexShader: `
            varying vec3 vWorldPosition;
            void main() {
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vWorldPosition = worldPosition.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            uniform float offset;
            uniform float exponent;
            varying vec3 vWorldPosition;
            void main() {
                float h = normalize(vWorldPosition + offset).y;
                gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
            }
        `,
        side: THREE.BackSide
    });
    this.skyDome = new THREE.Mesh(skyGeo, skyMat);
    this.scene.add(this.skyDome);
}

createClouds() {
    this.clouds = new THREE.Group();
    const cloudMat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });

    for (let i = 0; i < 15; i++) {
        const cloud = new THREE.Group();
        const numPuffs = 3 + Math.floor(Math.random() * 4);
        for (let j = 0; j < numPuffs; j++) {
            const puff = new THREE.Mesh(
                new THREE.SphereGeometry(8 + Math.random() * 12, 8, 6),
                cloudMat
            );
            puff.position.set(
                (Math.random() - 0.5) * 25,
                (Math.random() - 0.5) * 6,
                (Math.random() - 0.5) * 15
            );
            puff.scale.y = 0.6;
            cloud.add(puff);
        }
        cloud.position.set(
            (Math.random() - 0.5) * 1200,
            80 + Math.random() * 40,
            (Math.random() - 0.5) * 1200
        );
        cloud.userData.speed = 0.5 + Math.random() * 1.5;
        cloud.userData.baseY = cloud.position.y;
        this.clouds.add(cloud);
    }
    this.scene.add(this.clouds);
}

createOcean() {
    // Higher resolution ocean for better waves
    const geo = new THREE.PlaneGeometry(2500, 2500, 80, 80);
    this.oceanPos = geo.getAttribute('position').array.slice();

    // Enhanced ocean material with better reflections
    const oceanMat = new THREE.MeshPhongMaterial({
        color: 0x1e4d6b,
        specular: 0x5599aa,
        shininess: 150,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.92,
        flatShading: false
    });

    this.ocean = new THREE.Mesh(geo, oceanMat);
    this.ocean.rotation.x = -Math.PI / 2;
    this.ocean.position.y = -2;
    this.ocean.receiveShadow = true;
    this.scene.add(this.ocean);

    // Add foam layer
    this.createFoamLayer();
}

createFoamLayer() {
    const foamGeo = new THREE.PlaneGeometry(2500, 2500, 40, 40);
    this.foamPos = foamGeo.getAttribute('position').array.slice();

    const foamMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.15,
        side: THREE.DoubleSide,
        depthWrite: false
    });

    this.foam = new THREE.Mesh(foamGeo, foamMat);
    this.foam.rotation.x = -Math.PI / 2;
    this.foam.position.y = -1.5;
    this.scene.add(this.foam);
}

createWakeSystem() {
    const wakeGroup = new THREE.Group();
    this.wakeLines = [];

    for (let i = 0; i < 20; i++) {
        const geo = new THREE.SphereGeometry(0.5, 6, 4);
        const mat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0
        });
        const wake = new THREE.Mesh(geo, mat);
        wake.userData = { age: 1, active: false };
        wakeGroup.add(wake);
        this.wakeLines.push(wake);
    }

    this.scene.add(wakeGroup);
    return wakeGroup;
}

createAmbientParticles() {
    const particles = new THREE.Group();
    const particleMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.6
    });

    for (let i = 0; i < 50; i++) {
        const size = 0.2 + Math.random() * 0.3;
        const particle = new THREE.Mesh(
            new THREE.SphereGeometry(size, 4, 4),
            particleMat.clone()
        );
        particle.position.set(
            (Math.random() - 0.5) * 200,
            Math.random() * 30,
            (Math.random() - 0.5) * 200
        );
        particle.userData = {
            speedY: 0.02 + Math.random() * 0.05,
            speedX: (Math.random() - 0.5) * 0.1,
            baseOpacity: 0.3 + Math.random() * 0.4
        };
        particles.add(particle);
    }

    this.scene.add(particles);
    return particles;
}

createIslands() {
    const factionColors = { english: 0xc41e3a, eitc: 0x1e4d2b, pirates: 0x2c2c2c, neutral: 0x808080 };
    this.islands = [];

    Object.entries(CONFIG.islands).forEach(([id, cfg]) => {
        const island = new THREE.Group();
        island.position.set(cfg.position.x, 0, cfg.position.z);
        const r = 15 + Math.random() * 5;

        // Island base with better geometry
        const baseGeo = new THREE.CylinderGeometry(r, r * 1.3, 10, 12);
        const baseMat = new THREE.MeshLambertMaterial({ color: cfg.color });
        const base = new THREE.Mesh(baseGeo, baseMat);
        base.position.y = 3;
        base.castShadow = true;
        base.receiveShadow = true;
        island.add(base);

        // Rocky details
        for (let i = 0; i < 3; i++) {
            const rock = new THREE.Mesh(
                new THREE.DodecahedronGeometry(2 + Math.random() * 2, 0),
                new THREE.MeshLambertMaterial({ color: 0x666666 })
            );
            const angle = Math.random() * Math.PI * 2;
            rock.position.set(Math.cos(angle) * (r - 3), 6 + Math.random() * 2, Math.sin(angle) * (r - 3));
            rock.rotation.set(Math.random(), Math.random(), Math.random());
            rock.castShadow = true;
            island.add(rock);
        }

        // Beach ring
        const beach = new THREE.Mesh(
            new THREE.TorusGeometry(r * 1.15, 2.5, 8, 20),
            new THREE.MeshLambertMaterial({ color: 0xf4e4c1 })
        );
        beach.rotation.x = Math.PI / 2;
        beach.position.y = -0.3;
        beach.receiveShadow = true;
        island.add(beach);

        // Enhanced trees
        for (let i = 0; i < 5 + Math.floor(Math.random() * 3); i++) {
            const tree = this.createPalmTree();
            const a = i * 1.2 + Math.random() * 0.5;
            const d = 4 + Math.random() * (r - 6);
            tree.position.set(Math.cos(a) * d, 5, Math.sin(a) * d);
            tree.rotation.y = Math.random() * Math.PI * 2;
            tree.scale.setScalar(0.8 + Math.random() * 0.4);
            island.add(tree);
        }

        // Flag pole and flag
        const pole = new THREE.Mesh(
            new THREE.CylinderGeometry(0.25, 0.3, 14, 8),
            new THREE.MeshLambertMaterial({ color: 0x8b4513 })
        );
        pole.position.y = 14;
        pole.castShadow = true;
        island.add(pole);

        const flag = new THREE.Mesh(
            new THREE.PlaneGeometry(5, 3),
            new THREE.MeshLambertMaterial({
                color: factionColors[cfg.faction],
                side: THREE.DoubleSide
            })
        );
        flag.position.set(3, 19, 0);
        flag.userData.waveOffset = Math.random() * Math.PI * 2;
        island.add(flag);
        this.flagMeshes = this.flagMeshes || [];
        this.flagMeshes.push(flag);

        // Dock
        const dock = new THREE.Mesh(
            new THREE.BoxGeometry(4, 0.5, 12),
            new THREE.MeshLambertMaterial({ color: 0x6b4423 })
        );
        dock.position.set(r + 4, 0, 0);
        dock.castShadow = true;
        dock.receiveShadow = true;
        island.add(dock);

        this.islands.push(island);
        this.scene.add(island);
    });
}

createPalmTree() {
    const tree = new THREE.Group();

    // Trunk with slight curve
    const trunkGeo = new THREE.CylinderGeometry(0.4, 0.6, 8, 8);
    const trunk = new THREE.Mesh(trunkGeo, new THREE.MeshLambertMaterial({ color: 0x8b6914 }));
    trunk.castShadow = true;
    tree.add(trunk);

    // Palm fronds
    const frondMat = new THREE.MeshLambertMaterial({ color: 0x228b22, side: THREE.DoubleSide });
    for (let i = 0; i < 7; i++) {
        const frond = new THREE.Mesh(
            new THREE.ConeGeometry(1.5, 5, 4),
            frondMat
        );
        frond.position.y = 5;
        frond.rotation.z = Math.PI / 3;
        frond.rotation.y = (i / 7) * Math.PI * 2;
        frond.position.x = Math.cos(frond.rotation.y) * 1;
        frond.position.z = Math.sin(frond.rotation.y) * 1;
        tree.add(frond);
    }

    // Coconuts
    for (let i = 0; i < 2; i++) {
        const coconut = new THREE.Mesh(
            new THREE.SphereGeometry(0.4, 6, 6),
            new THREE.MeshLambertMaterial({ color: 0x8b4513 })
        );
        coconut.position.set(Math.random() - 0.5, 4, Math.random() - 0.5);
        tree.add(coconut);
    }

    return tree;
}

createShip() {
    const ship = new THREE.Group();

    // Hull - using simple box geometry (more reliable)
    const hull = new THREE.Mesh(
        new THREE.BoxGeometry(4, 2.5, 11),
        new THREE.MeshLambertMaterial({ color: 0x8b4513 })
    );
    hull.position.y = 1;
    hull.castShadow = true;
    ship.add(hull);

    // Hull bottom taper
    const hullBottom = new THREE.Mesh(
        new THREE.BoxGeometry(3, 1, 10),
        new THREE.MeshLambertMaterial({ color: 0x6b3010 })
    );
    hullBottom.position.y = -0.3;
    ship.add(hullBottom);

    // Deck
    const deck = new THREE.Mesh(
        new THREE.BoxGeometry(3.8, 0.3, 10),
        new THREE.MeshLambertMaterial({ color: 0xdeb887 })
    );
    deck.position.y = 2.4;
    deck.castShadow = true;
    deck.receiveShadow = true;
    ship.add(deck);

    // Cabin at stern
    const cabin = new THREE.Mesh(
        new THREE.BoxGeometry(2.8, 1.8, 3),
        new THREE.MeshLambertMaterial({ color: 0x6b4423 })
    );
    cabin.position.set(0, 3.5, -3);
    cabin.castShadow = true;
    ship.add(cabin);

    // Main mast
    const mast = new THREE.Mesh(
        new THREE.CylinderGeometry(0.3, 0.4, 14, 8),
        new THREE.MeshLambertMaterial({ color: 0x4a3728 })
    );
    mast.position.y = 9;
    mast.castShadow = true;
    ship.add(mast);

    // Crow's nest
    const crowsNest = new THREE.Mesh(
        new THREE.CylinderGeometry(0.9, 0.7, 0.6, 8),
        new THREE.MeshLambertMaterial({ color: 0x6b4423 })
    );
    crowsNest.position.y = 14.5;
    ship.add(crowsNest);

    // Main sail
    const sailMat = new THREE.MeshLambertMaterial({ color: 0xf5f0e1, side: THREE.DoubleSide });
    const mainSail = new THREE.Mesh(new THREE.PlaneGeometry(6, 8), sailMat);
    mainSail.position.set(0, 10, 0.5);
    mainSail.rotation.y = Math.PI / 2;
    mainSail.userData.isSail = true;
    ship.add(mainSail);
    this.mainSail = mainSail;

    // Forward sail
    const foreSail = new THREE.Mesh(new THREE.PlaneGeometry(4, 5), sailMat);
    foreSail.position.set(0, 6, 3.5);
    foreSail.rotation.y = Math.PI / 2;
    ship.add(foreSail);

    // Bow (pointed front)
    const bow = new THREE.Mesh(
        new THREE.ConeGeometry(1.2, 3.5, 6),
        new THREE.MeshLambertMaterial({ color: 0xc9a227 })
    );
    bow.position.set(0, 1, 7);
    bow.rotation.x = Math.PI / 2;
    bow.castShadow = true;
    ship.add(bow);

    // Railing posts
    for (let i = 0; i < 4; i++) {
        const post = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.08, 1, 6),
            new THREE.MeshLambertMaterial({ color: 0x6b4423 })
        );
        post.position.set(1.7, 3, -3 + i * 2.5);
        ship.add(post);
        const post2 = post.clone();
        post2.position.x = -1.7;
        ship.add(post2);
    }

    // Lantern at stern
    const lantern = new THREE.Mesh(
        new THREE.SphereGeometry(0.35, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xffdd88 })
    );
    lantern.position.set(0, 4.8, -4.5);
    ship.add(lantern);
    this.lantern = lantern;

    // Point light from lantern (for night mode)
    this.lanternLight = new THREE.PointLight(0xffdd66, 0, 25);
    this.lanternLight.position.copy(lantern.position);
    ship.add(this.lanternLight);

    return ship;
}

updateSkyColor() {
    const darkMode = document.documentElement.dataset.theme === 'dark';
    if (darkMode) {
        // Golden hour/dusk colors - warm and visible
        this.renderer.setClearColor(0x2a3a4a);
        if (this.skyDome) {
            this.skyDome.material.uniforms.topColor.value.setHex(0x2a3550);
            this.skyDome.material.uniforms.bottomColor.value.setHex(0x4a5a70);
        }
        // Bright enough for gameplay while still feeling like evening
        if (this.hemiLight) this.hemiLight.intensity = 0.5;
        if (this.sunLight) {
            this.sunLight.intensity = 0.85;
            this.sunLight.color.setHex(0xffcc88); // Warm sunset tint
        }
        if (this.ambientLight) this.ambientLight.intensity = 0.55;
        if (this.lanternLight) this.lanternLight.intensity = 1.5;
        this.renderer.toneMappingExposure = 1.1;
    } else {
        this.renderer.setClearColor(0x1a3a4a);
        if (this.skyDome) {
            this.skyDome.material.uniforms.topColor.value.setHex(0x4a90c2);
            this.skyDome.material.uniforms.bottomColor.value.setHex(0x87ceeb);
        }
        if (this.hemiLight) this.hemiLight.intensity = 0.4;
        if (this.sunLight) {
            this.sunLight.intensity = 1.0;
            this.sunLight.color.setHex(0xfff5e0); // Warm sunlight
        }
        if (this.ambientLight) this.ambientLight.intensity = 0.35;
        if (this.lanternLight) this.lanternLight.intensity = 0;
        this.renderer.toneMappingExposure = 1.0;
    }
    this.isDarkMode = darkMode;
}

setWeather(state) {
    this.weatherState = state;
    const overlay = document.getElementById('weather-overlay');
    if (!overlay) return;

    overlay.className = '';
    if (state === 'storm') {
        overlay.classList.add('active', 'storm', 'rain');
        this.cameraShake.intensity = 0.5;
    } else if (state === 'rain') {
        overlay.classList.add('active', 'rain');
        this.cameraShake.intensity = 0.1;
    } else if (state === 'fog') {
        overlay.classList.add('active', 'fog');
        this.cameraShake.intensity = 0;
    } else {
        this.cameraShake.intensity = 0;
    }
}

updateShip(pos, heading, speed = 0) {
    const t = this.clock.getElapsedTime();
    this.shipSpeed = speed;

    // Enhanced ship bobbing based on wave height
    const waveHeight = Math.sin(t * 2) * 0.8 + Math.sin(t * 1.3) * 0.4;
    this.ship.position.set(pos.x, waveHeight, pos.z);

    // Roll and pitch
    this.ship.rotation.z = Math.sin(t * 1.5 + pos.x * 0.01) * 0.06;
    this.ship.rotation.x = Math.sin(t * 1.8 + pos.z * 0.01) * 0.03;

    // Smooth heading
    if (heading !== null) {
        const diff = heading - this.shipHeading;
        const wrappedDiff = Math.atan2(Math.sin(diff), Math.cos(diff));
        this.shipHeading += wrappedDiff * 0.08;
    }
    this.ship.rotation.y = this.shipHeading;

    // Sail billowing
    if (this.mainSail) {
        this.mainSail.rotation.z = Math.sin(t * 2) * 0.1;
        this.mainSail.scale.x = 1 + Math.sin(t * 3) * 0.05;
    }

    // Update wake particles
    this.updateWake(pos, speed);
}

updateWake(pos, speed) {
    if (speed < 0.1) return;

    const wakeIndex = Math.floor(this.clock.getElapsedTime() * 5) % this.wakeLines.length;
    const wake = this.wakeLines[wakeIndex];

    if (wake && !wake.userData.active) {
        wake.position.set(
            pos.x - Math.sin(this.shipHeading) * 6,
            -0.5,
            pos.z - Math.cos(this.shipHeading) * 6
        );
        wake.userData.active = true;
        wake.userData.age = 0;
        wake.material.opacity = 0.6 * speed;
        wake.scale.setScalar(1);
    }

    // Age wake particles
    this.wakeLines.forEach(w => {
        if (w.userData.active) {
            w.userData.age += 0.016;
            w.material.opacity *= 0.98;
            w.scale.multiplyScalar(1.02);
            if (w.userData.age > 3) {
                w.userData.active = false;
                w.material.opacity = 0;
            }
        }
    });
}

updateCamera(shipPos) {
    const t = this.clock.getElapsedTime();

    // Base camera follow
    const targetX = shipPos.x + Math.sin(this.shipHeading) * 10;
    const targetZ = shipPos.z + 85 + Math.cos(this.shipHeading) * 10;

    this.camera.position.x += (targetX - this.camera.position.x) * 0.04;
    this.camera.position.z += (targetZ - this.camera.position.z) * 0.04;

    // Camera shake (weather effects)
    if (this.cameraShake.intensity > 0) {
        this.camera.position.x += (Math.random() - 0.5) * this.cameraShake.intensity;
        this.camera.position.y = 90 + (Math.random() - 0.5) * this.cameraShake.intensity * 2;
    }

    // Subtle breathing effect
    this.camera.position.y = 90 + Math.sin(t * 0.5) * 2;

    this.camera.lookAt(shipPos.x, 0, shipPos.z);
}

createNavigationLine() {
    const lineGroup = new THREE.Group();

    // Create dashed navigation line - additive blending for glow effect over dark sea
    const lineMat = new THREE.MeshBasicMaterial({
        color: 0xffaa00,
        transparent: true,
        opacity: 0.7,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    // Create 25 dash segments - moderate size
    this.navDashes = [];
    for (let i = 0; i < 25; i++) {
        const dash = new THREE.Mesh(
            new THREE.BoxGeometry(3, 0.8, 8),
            lineMat.clone()
        );
        dash.visible = false;
        lineGroup.add(dash);
        this.navDashes.push(dash);
    }

    // Destination marker (glowing ring) - additive for glow
    const markerGeo = new THREE.TorusGeometry(10, 1.5, 8, 24);
    const markerMat = new THREE.MeshBasicMaterial({
        color: 0xffcc00,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });
    this.navMarker = new THREE.Mesh(markerGeo, markerMat);
    this.navMarker.rotation.x = -Math.PI / 2;
    this.navMarker.position.y = 1;
    this.navMarker.visible = false;
    lineGroup.add(this.navMarker);

    // Inner pulsing ring
    const innerGeo = new THREE.TorusGeometry(6, 1, 8, 24);
    this.navMarkerInner = new THREE.Mesh(innerGeo, markerMat.clone());
    this.navMarkerInner.rotation.x = -Math.PI / 2;
    this.navMarkerInner.position.y = 1;
    this.navMarkerInner.visible = false;
    lineGroup.add(this.navMarkerInner);

    this.scene.add(lineGroup);
    return lineGroup;
}

updateNavigation(shipPos, destPos) {
    const t = this.clock.getElapsedTime();

    if (!destPos) {
        // Hide navigation when no destination
        this.navDashes.forEach(d => d.visible = false);
        this.navMarker.visible = false;
        this.navMarkerInner.visible = false;
        this.currentDestination = null;
        return;
    }

    this.currentDestination = destPos;

    // Calculate direction and distance
    const dx = destPos.x - shipPos.x;
    const dz = destPos.z - shipPos.z;
    const distance = Math.sqrt(dx * dx + dz * dz);
    const angle = Math.atan2(dx, dz);

    // Position dashes along the path
    const dashSpacing = Math.min(distance / 25, 22);
    const numDashes = Math.min(25, Math.floor(distance / dashSpacing));

    this.navDashes.forEach((dash, i) => {
        if (i < numDashes && distance > 30) {
            const progress = (i + 1) / (numDashes + 1);
            // Animated offset for "moving" dashes effect
            const animOffset = ((t * 0.5) % 1) / (numDashes + 1);
            const adjustedProgress = Math.min(progress + animOffset, 0.95);

            dash.position.x = shipPos.x + dx * adjustedProgress;
            dash.position.z = shipPos.z + dz * adjustedProgress;
            dash.position.y = 0.8 + Math.sin(t * 2 + i * 0.5) * 0.3;
            dash.rotation.y = angle;

            // Fade dashes near ship and destination
            const fadeStart = 0.12;
            const fadeEnd = 0.88;
            let opacity = 0.7;
            if (adjustedProgress < fadeStart) {
                opacity = 0.7 * (adjustedProgress / fadeStart);
            } else if (adjustedProgress > fadeEnd) {
                opacity = 0.7 * (1 - (adjustedProgress - fadeEnd) / (1 - fadeEnd));
            }
            dash.material.opacity = opacity;
            dash.visible = true;
        } else {
            dash.visible = false;
        }
    });

    // Position and animate destination marker
    this.navMarker.position.x = destPos.x;
    this.navMarker.position.z = destPos.z;
    this.navMarker.position.y = 1 + Math.sin(t * 1.5) * 0.5;
    this.navMarker.rotation.z = t * 0.5;
    this.navMarker.visible = distance > 30;

    this.navMarkerInner.position.x = destPos.x;
    this.navMarkerInner.position.z = destPos.z;
    this.navMarkerInner.position.y = 1 + Math.sin(t * 1.5) * 0.5;
    this.navMarkerInner.rotation.z = -t * 0.8;
    const pulse = 0.7 + Math.sin(t * 3) * 0.25;
    this.navMarkerInner.scale.set(pulse, pulse, 1);
    this.navMarkerInner.material.opacity = 0.5 + Math.sin(t * 3) * 0.2;
    this.navMarkerInner.visible = distance > 30;
}

onResize() {
    this.camera.aspect = innerWidth / innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(innerWidth, innerHeight);
}

render() {
    const t = this.clock.getElapsedTime();

    // Check theme changes
    if (this.isDarkMode !== (document.documentElement.dataset.theme === 'dark')) {
        this.updateSkyColor();
    }

    // Animate ocean waves
    const oceanPos = this.ocean.geometry.getAttribute('position').array;
    for (let i = 0; i < oceanPos.length; i += 3) {
        const x = this.oceanPos[i], y = this.oceanPos[i + 1];
        oceanPos[i + 2] = Math.sin(x * 0.015 + t * 0.8) * 2.0 +
                         Math.sin(y * 0.02 + t * 0.6) * 1.5 +
                         Math.sin((x + y) * 0.01 + t * 1.2) * 0.8;
    }
    this.ocean.geometry.getAttribute('position').needsUpdate = true;
    this.ocean.geometry.computeVertexNormals();

    // Animate foam
    if (this.foam) {
        const foamPos = this.foam.geometry.getAttribute('position').array;
        for (let i = 0; i < foamPos.length; i += 3) {
            foamPos[i + 2] = Math.sin(this.foamPos[i] * 0.02 + t * 1.2) * 0.5;
        }
        this.foam.geometry.getAttribute('position').needsUpdate = true;
        this.foam.material.opacity = 0.1 + Math.sin(t * 0.5) * 0.05;
    }

    // Animate clouds
    this.clouds.children.forEach(cloud => {
        cloud.position.x += cloud.userData.speed * 0.02;
        cloud.position.y = cloud.userData.baseY + Math.sin(t * 0.3 + cloud.position.x * 0.01) * 3;
        if (cloud.position.x > 700) cloud.position.x = -700;
    });

    // Animate flags
    if (this.flagMeshes) {
        this.flagMeshes.forEach(flag => {
            flag.rotation.y = Math.sin(t * 3 + flag.userData.waveOffset) * 0.2;
            flag.position.x = 3 + Math.sin(t * 2.5 + flag.userData.waveOffset) * 0.3;
        });
    }

    // Animate ambient particles
    this.ambientParticles.children.forEach(p => {
        p.position.y += p.userData.speedY;
        p.position.x += p.userData.speedX + Math.sin(t + p.position.y * 0.1) * 0.02;
        p.material.opacity = p.userData.baseOpacity * (0.5 + Math.sin(t * 2 + p.position.x) * 0.5);

        if (p.position.y > 35) {
            p.position.y = 0;
            p.position.x = this.ship.position.x + (Math.random() - 0.5) * 150;
            p.position.z = this.ship.position.z + (Math.random() - 0.5) * 150;
        }
    });

    // Lantern flicker in dark mode
    if (this.isDarkMode && this.lantern) {
        this.lantern.material.color.setHex(
            0xffdd88 + Math.floor(Math.sin(t * 10) * 20)
        );
        this.lanternLight.intensity = 1.5 + Math.sin(t * 8) * 0.3;
    }

    this.renderer.render(this.scene, this.camera);
}
}

// ==================== JOYSTICK ====================
class Joystick {
constructor() {
this.base = document.getElementById('joystick-base'); this.stick = document.getElementById('joystick-stick'); this.zone = document.getElementById('joystick-zone');
this.active = false; this.value = { x: 0, y: 0 }; this.magnitude = 0; this.angle = 0; this.maxDist = 35;
this.zone.addEventListener('touchstart', e => this.start(e.touches[0]), { passive: false });
document.addEventListener('touchmove', e => { if (this.active) { e.preventDefault(); this.move(e.touches[0]); } }, { passive: false });
document.addEventListener('touchend', () => this.end()); document.addEventListener('touchcancel', () => this.end());
this.zone.addEventListener('mousedown', e => this.start(e)); document.addEventListener('mousemove', e => { if (this.active) this.move(e); }); document.addEventListener('mouseup', () => this.end());
}
start(e) { this.active = true; this.stick.classList.add('active'); this.rect = this.base.getBoundingClientRect(); this.move(e); }
move(e) {
if (!this.active || !this.rect) return;
let dx = e.clientX - (this.rect.left + this.rect.width / 2), dy = e.clientY - (this.rect.top + this.rect.height / 2);
const dist = Math.sqrt(dx * dx + dy * dy), cd = Math.min(dist, this.maxDist);
if (dist > 0) { dx = dx / dist * cd; dy = dy / dist * cd; }
this.stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
this.value = { x: dx / this.maxDist, y: dy / this.maxDist }; this.magnitude = cd / this.maxDist; this.angle = Math.atan2(-dx, -dy);
}
end() { this.active = false; this.stick.classList.remove('active'); this.stick.style.transform = 'translate(-50%, -50%)'; this.value = { x: 0, y: 0 }; this.magnitude = 0; }
}

// ==================== UI ====================
class UI {
constructor(game) { this.game = game; this.el = {}; this.cache(); this.bind(); }
cache() {
['loading-screen','faction-screen','game-container','gold-value','day-value','supplies-value','faction-badge','faction-icon','faction-name','cargo-count','cargo-preview','compass-needle','compass-dest-marker','destination-info','dest-name','dest-distance','event-toast','event-title','event-desc','trade-modal','trade-island-name','trade-island-faction','trade-tariff','trade-port-state','buy-panel','sell-panel','logbook-panel','shipyard-panel','contracts-panel','tavern-panel','buy-goods-list','sell-goods-list','trade-gold','trade-cargo','close-trade','leave-port-btn','menu-modal','close-menu','save-btn','new-game-btn','rep-english','rep-eitc','rep-pirates','rep-english-val','rep-eitc-val','rep-pirates-val','ship-speed','ship-cargo-cap','ship-supply-rate','ship-upgrades','pirate-modal','pay-tribute','fight-pirates','pirate-pass','tribute-cost','warning-modal','warning-icon','warning-title','warning-text','warning-dismiss','continue-btn','btn-dock','btn-map','btn-menu','speed-fill','wind-effect','island-indicator','nearby-island-name','nearby-island-faction','nearby-island-dist','map-modal','map-container','map-info','close-map','clear-course-btn','wind-indicator','wind-arrow','wind-strength','menu-wind-dir','menu-wind-change','menu-route-risk','menu-heat','buy-best-btn','sell-best-btn','logbook-island-select','logbook-prices','spotlight-list','upgrades-list','encounter-modal','encounter-icon','encounter-title','encounter-desc','encounter-result','encounter-options','heat-indicator','heat-fill','heat-label','bounty-indicator','bounty-level','notoriety-indicator','notoriety-fill','notoriety-label','contract-tracker','tracker-title','tracker-meta','world-indicator','world-icon','world-status','available-contracts','active-contracts','active-count','contracts-badge','titles-list','menu-season','menu-crackdown','menu-regional','title-modal','title-icon','title-earned-name','title-earned-desc','title-dismiss','contract-complete-modal','contract-complete-icon','contract-complete-title','contract-complete-desc','contract-complete-rewards','contract-complete-dismiss','ship-condition','ship-class-icon','ship-class-label','hull-fill','hull-value','rigging-fill','rigging-value','morale-fill','morale-value','chase-modal','chase-desc','chase-player','chase-pirate','chase-chance','chase-timer','chase-trim','chase-jettison','chase-risky','chase-result','officer-count','current-officers','available-officers','tavern-rumors','questline-section','questline-content','chart-fragments','fragments-count','cove-modal','cove-icon','cove-name','cove-desc','cove-services','close-cove','invert-joystick-toggle','help-toggle','help-content'].forEach(id => this.el[id] = document.getElementById(id));
this.el.tradeTabs = document.querySelectorAll('.trade-tab'); this.el.factionCards = document.querySelectorAll('.faction-card');
}
bind() {
this.el.factionCards.forEach(c => c.addEventListener('click', () => { this.el.factionCards.forEach(x => x.classList.remove('selected')); c.classList.add('selected'); this.el['continue-btn']?.classList.remove('hidden'); this.game.selectedFaction = c.dataset.faction; console.log('Selected faction:', c.dataset.faction); }));
this.el['continue-btn']?.addEventListener('click', () => { if (this.game.selectedFaction) this.game.startGame(this.game.selectedFaction); });
this.el.tradeTabs.forEach(tab => tab.addEventListener('click', () => { this.el.tradeTabs.forEach(t => t.classList.remove('active')); tab.classList.add('active'); ['buy','sell','contracts','tavern','logbook','shipyard'].forEach(p => this.el[p+'-panel'].classList.toggle('hidden', p !== tab.dataset.tab)); if (tab.dataset.tab === 'logbook') this.renderLogbook(); if (tab.dataset.tab === 'shipyard') this.renderShipyard(); if (tab.dataset.tab === 'contracts') this.renderContracts(); if (tab.dataset.tab === 'tavern') this.renderTavern(); }));
this.el['close-trade']?.addEventListener('click', () => this.closeTrade());
this.el['leave-port-btn']?.addEventListener('click', () => { this.closeTrade(); this.game.undock(); });
this.el['btn-dock']?.addEventListener('click', () => this.game.dock());
this.el['btn-menu']?.addEventListener('click', () => this.showMenu());
this.el['btn-map']?.addEventListener('click', () => this.showMap());
this.el['close-menu']?.addEventListener('click', () => this.el['menu-modal'].classList.add('hidden'));
this.el['close-map']?.addEventListener('click', () => this.el['map-modal'].classList.add('hidden'));
this.el['close-cove']?.addEventListener('click', () => this.closeCove());
this.el['clear-course-btn']?.addEventListener('click', () => { this.game.gameState.player.destinationIslandId = null; this.game.gameState.player.destinationCoveId = null; this.toast('Cleared', 'No course'); this.el['map-modal'].classList.add('hidden'); });
this.el['save-btn']?.addEventListener('click', () => { this.game.save(); this.toast('Saved', 'Progress saved'); });
this.el['new-game-btn']?.addEventListener('click', () => { if (confirm('New game?')) { localStorage.removeItem('merchantSeasSave'); location.reload(); } });
this.el['pay-tribute']?.addEventListener('click', () => this.game.payTribute());
this.el['fight-pirates']?.addEventListener('click', () => this.game.fight());
this.el['pirate-pass']?.addEventListener('click', () => { this.el['pirate-modal'].classList.add('hidden'); this.toast('Parley', 'Safe passage'); });
this.el['warning-dismiss']?.addEventListener('click', () => this.el['warning-modal'].classList.add('hidden'));
this.el['title-dismiss']?.addEventListener('click', () => this.el['title-modal'].classList.add('hidden'));
this.el['contract-complete-dismiss']?.addEventListener('click', () => this.el['contract-complete-modal'].classList.add('hidden'));
this.el['buy-best-btn']?.addEventListener('click', () => this.game.buyBest());
this.el['sell-best-btn']?.addEventListener('click', () => this.game.sellBest());
this.el['logbook-island-select']?.addEventListener('change', e => this.renderLogPrices(e.target.value));
this.el['contract-tracker']?.addEventListener('click', () => { if (this.game.gameState?.isDocked) { this.el.tradeTabs.forEach(t => t.classList.toggle('active', t.dataset.tab === 'contracts')); ['buy','sell','contracts','logbook','shipyard'].forEach(p => this.el[p+'-panel'].classList.toggle('hidden', p !== 'contracts')); this.renderContracts(); } });
// Chase action bindings - Living Sea Update
this.el['chase-trim']?.addEventListener('click', () => this.game.chaseAction('trim'));
this.el['chase-jettison']?.addEventListener('click', () => this.game.chaseAction('jettison'));
this.el['chase-risky']?.addEventListener('click', () => this.game.chaseAction('risky'));
// Help toggle binding
this.el['help-toggle']?.addEventListener('click', () => {
    this.el['help-toggle'].classList.toggle('collapsed');
    this.el['help-content'].classList.toggle('collapsed');
});
// Joystick inversion toggle binding
this.el['invert-joystick-toggle']?.addEventListener('click', () => {
    const isInverted = localStorage.getItem('havenvoy-invert-joystick') === 'true';
    localStorage.setItem('havenvoy-invert-joystick', !isInverted);
    this.el['invert-joystick-toggle'].classList.toggle('active', !isInverted);
});
// Initialize joystick inversion toggle state from localStorage
if (this.el['invert-joystick-toggle']) {
    const isInverted = localStorage.getItem('havenvoy-invert-joystick') === 'true';
    this.el['invert-joystick-toggle'].classList.toggle('active', isInverted);
}
}
showLoading(p) { document.querySelector('.loading-progress').style.width = p + '%'; }
hideLoading() { this.el['loading-screen'].classList.add('hidden'); }
showFaction() { this.el['faction-screen'].classList.remove('hidden'); }
hideFaction() { this.el['faction-screen'].classList.add('hidden'); }
showGame() { this.el['game-container'].classList.remove('hidden'); }
updateHUD(gs) {
    this.el['gold-value'].textContent = gs.player.gold.toLocaleString();
    this.el['day-value'].textContent = gs.player.days;
    this.el['supplies-value'].textContent = gs.player.supplies;
    const f = CONFIG.factions[gs.player.faction];
    this.el['faction-icon'].textContent = f.icon;
    this.el['faction-name'].textContent = f.name;
    this.el['faction-badge'].className = gs.player.faction;
    this.el['cargo-count'].textContent = `${getCargoUsed(gs)}/${getCargoCapacity(gs)}`;

    // Cargo preview with smart high-margin glow
    const prev = this.el['cargo-preview']; prev.innerHTML = '';
    const highMargin = getHighMarginGoods(gs);
    Object.entries(gs.player.cargo).forEach(([gid, qty]) => {
        const g = CONFIG.goods[gid];
        const isContraband = g.category === 'contraband';
        const isHM = highMargin.has(gid);
        for (let i = 0; i < Math.min(qty, 8); i++) {
            const d = document.createElement('span');
            d.className = 'cargo-dot' + (isContraband ? ' contraband' : isHM ? ' high-margin' : '');
            prev.appendChild(d);
        }
    });

    // Wind
    if (gs.wind) {
        const wd = WIND_DIRS[gs.wind.direction], ws = WIND_STR[gs.wind.strength];
        this.el['wind-arrow'].style.transform = `rotate(${wd.angle}deg)`;
        this.el['wind-strength'].textContent = `${ws.name} ${wd.name}`;
    }

    // Heat indicator
    const heat = gs.player.heat || 0;
    this.el['heat-fill'].style.width = heat + '%';
    this.el['heat-label'].textContent = heat;
    this.el['heat-indicator'].className = heat < 30 ? 'low' : heat < 60 ? 'med' : 'high';

    // Bounty indicator - Living Sea Update
    const bountyLevel = getBountyLevel(gs);
    const bountyLabels = { clean: 'Clean', wanted: 'Wanted', hunted: 'Hunted!', infamous: 'INFAMOUS' };
    this.el['bounty-level'].textContent = bountyLabels[bountyLevel];
    this.el['bounty-indicator'].className = bountyLevel;

    // Notoriety indicator - Meta Pressure System
    this.updateNotorietyIndicator(gs);

    // Ship condition - Living Sea Update
    this.updateShipCondition(gs);

    // Contract tracker
    this.updateContractTracker(gs);

    // World indicator
    this.updateWorldIndicator(gs);

    // Chart fragments indicator
    this.updateChartFragments(gs);
}

updateChartFragments(gs) {
    const fragments = gs.player.chartFragments || 0;
    const el = this.el['chart-fragments'];
    if (!el) return;
    if (fragments > 0) {
        el.classList.remove('hidden');
        if (this.el['fragments-count']) this.el['fragments-count'].textContent = fragments;
        el.classList.toggle('can-reveal', fragments >= 3);
    } else {
        el.classList.add('hidden');
    }
}

updateContractTracker(gs) {
    const tracked = getTrackedContract(gs);
    if (tracked) {
        this.el['contract-tracker'].classList.remove('hidden');
        this.el['tracker-title'].textContent = tracked.title.substring(0, 15) + (tracked.title.length > 15 ? '...' : '');
        const daysLeft = tracked.deadline - (gs.player.days - tracked.dayAccepted);
        const dest = CONFIG.islands[tracked.toIsland];
        const dist = getIslandDistance(gs.player.position, dest.position);
        this.el['tracker-meta'].textContent = `${daysLeft}d left  ~${Math.ceil(dist/30)}d`;
    } else {
        this.el['contract-tracker'].classList.add('hidden');
    }
}

updateNotorietyIndicator(gs) {
    const ind = this.el['notoriety-indicator'];
    const fill = this.el['notoriety-fill'];
    const label = this.el['notoriety-label'];
    if (!ind || !fill || !label) return;

    // Get meta pressure summary
    const summary = typeof metaGetSummary === 'function' ? metaGetSummary(gs) : null;
    if (!summary || !CONFIG.metaPressure?.enabled) {
        ind.classList.remove('visible');
        return;
    }

    const total = summary.totalPressure || 0;
    // Only show indicator if there's some notoriety
    if (total < 0.1) {
        ind.classList.remove('visible');
        return;
    }

    ind.classList.add('visible');
    fill.style.width = Math.round(total * 100) + '%';

    // Determine level and label
    let level = 'low';
    let labelText = 'Watched';
    if (total >= 0.7) {
        level = 'notorious';
        labelText = 'Notorious';
    } else if (total >= 0.5) {
        level = 'high';
        labelText = 'Known';
    } else if (total >= 0.3) {
        level = 'rising';
        labelText = 'Noted';
    }

    label.textContent = labelText;
    ind.className = 'visible ' + level;

    // Build tooltip with flavor text
    const tips = [];
    if (summary.routeBias > 0.2) tips.push('Routes predictable');
    if (summary.goodBias > 0.2) tips.push('Trading patterns noticed');
    if (summary.portBias > 0.2) tips.push('Port habits known');
    if (summary.factionBias > 0.2) tips.push('Affiliations watched');
    ind.title = tips.length > 0 ? tips.join('  ') : 'How predictable your trading patterns have become';
}

updateShipCondition(gs) {
    // Ship class display
    const shipClass = CONFIG.shipClasses?.[gs.player.shipClass] || CONFIG.shipClasses?.brigantine;
    const shipIcons = { sloop: '', brigantine: '', galleon: '' };
    this.el['ship-class-icon'].textContent = shipIcons[gs.player.shipClass] || '';
    this.el['ship-class-label'].textContent = shipClass?.name || 'Brigantine';

    // Get condition values
    const hull = getShipHull(gs);
    const rigging = getShipRigging(gs);
    const morale = getShipMorale(gs);
    const maxHull = getMaxHull(gs);
    const maxRigging = getMaxRigging(gs);
    const maxMorale = getMaxMorale(gs);
    const critThreshold = CONFIG.shipCondition?.criticalThreshold || 30;

    // Update hull bar
    const hullPct = Math.round((hull / maxHull) * 100);
    this.el['hull-fill'].style.width = hullPct + '%';
    this.el['hull-value'].textContent = Math.round(hull);
    this.el['hull-fill'].classList.toggle('critical', hull < critThreshold);

    // Update rigging bar
    const riggingPct = Math.round((rigging / maxRigging) * 100);
    this.el['rigging-fill'].style.width = riggingPct + '%';
    this.el['rigging-value'].textContent = Math.round(rigging);
    this.el['rigging-fill'].classList.toggle('critical', rigging < critThreshold);

    // Update morale bar
    const moralePct = Math.round((morale / maxMorale) * 100);
    this.el['morale-fill'].style.width = moralePct + '%';
    this.el['morale-value'].textContent = Math.round(morale);
    this.el['morale-fill'].classList.toggle('critical', morale < critThreshold);

    // Critical state styling for whole widget
    const isCritical = isShipCritical(gs);
    this.el['ship-condition'].classList.toggle('critical', isCritical);
}

updateWorldIndicator(gs) {
    const season = getSeasonLabel(gs);
    const crackdown = getCrackdownLevel(gs);
    const seasonalEvent = gs.world?.seasonalEvent;

    this.el['world-icon'].textContent = season.icon;

    if (crackdown > 50) {
        this.el['world-status'].textContent = 'Crackdown!';
        this.el['world-indicator'].className = 'crackdown';
    } else if (seasonalEvent) {
        // Show active seasonal event
        const eventConfig = CONFIG.seasonalEvents.find(e => e.id === seasonalEvent.id);
        if (eventConfig) {
            this.el['world-icon'].textContent = eventConfig.icon || season.icon;
            this.el['world-status'].textContent = eventConfig.name;
            this.el['world-indicator'].className = eventConfig.severity === 'major' ? 'storm-season' : '';
            this.el['world-indicator'].title = eventConfig.desc;
        }
    } else if (season.class === 'storm-season') {
        this.el['world-status'].textContent = season.label;
        this.el['world-indicator'].className = season.class;
        this.el['world-indicator'].title = season.desc;
    } else {
        this.el['world-status'].textContent = season.label;
        this.el['world-indicator'].className = '';
        this.el['world-indicator'].title = season.desc;
    }
}

updateCompass(h, gs) {
    // Check for tracked contract destination first
    const tracked = getTrackedContract(gs);
    const destId = tracked?.toIsland || gs?.player?.destinationIslandId;
    const coveId = gs?.player?.destinationCoveId;

    if (destId) {
        const d = CONFIG.islands[destId], dx = d.position.x - gs.player.position.x, dz = d.position.z - gs.player.position.z, a = Math.atan2(dx, -dz);
        this.el['compass-needle'].style.transform = `translate(-50%, -100%) rotate(${a * 180 / Math.PI}deg)`;
        this.el['compass-dest-marker'].classList.remove('hidden');
        this.el['destination-info'].classList.remove('hidden');
        this.el['dest-name'].textContent = d.name;
        this.el['dest-distance'].textContent = `~${Math.ceil(Math.sqrt(dx*dx+dz*dz)/30)}d`;
    } else if (coveId) {
        // Point to hidden cove destination
        const cove = CONFIG.hiddenCoves[coveId];
        if (cove) {
            const dx = cove.position.x - gs.player.position.x, dz = cove.position.z - gs.player.position.z, a = Math.atan2(dx, -dz);
            this.el['compass-needle'].style.transform = `translate(-50%, -100%) rotate(${a * 180 / Math.PI}deg)`;
            this.el['compass-dest-marker'].classList.remove('hidden');
            this.el['destination-info'].classList.remove('hidden');
            this.el['dest-name'].textContent = cove.name;
            this.el['dest-distance'].textContent = `~${Math.ceil(Math.sqrt(dx*dx+dz*dz)/30)}d`;
        }
    } else {
        // No destination - compass points north (traditional behavior)
        this.el['compass-needle'].style.transform = `translate(-50%, -100%) rotate(0deg)`;
        this.el['compass-dest-marker'].classList.add('hidden');
        this.el['destination-info'].classList.add('hidden');
    }
}

updateSpeed(s, we) {
    this.el['speed-fill'].style.width = s * 100 + '%';
    this.el['wind-effect'].textContent = we?.label || '';
    this.el['wind-effect'].className = we?.mult > 1 ? 'wind-boost' : we?.mult < 1 ? 'wind-penalty' : '';
}

updateNearby(isl, dist) {
    if (isl) {
        this.el['island-indicator'].classList.add('visible');
        this.el['nearby-island-name'].textContent = isl.name;
        // Handle coves vs islands
        if (isl.type === 'cove') {
            this.el['nearby-island-faction'].textContent = 'Hidden Cove';
        } else {
            this.el['nearby-island-faction'].textContent = CONFIG.factions[isl.faction]?.name || 'Neutral';
        }
        this.el['nearby-island-dist'].textContent = dist < CONFIG.settings.dockDistance ? ' Dock' : Math.round(dist) + 'm';
        this.el['btn-dock'].classList.toggle('available', dist < CONFIG.settings.dockDistance);
    }
    else { this.el['island-indicator'].classList.remove('visible'); this.el['btn-dock'].classList.remove('available'); }
}

showTrade(iid, gs) {
    const isl = gs.islands[iid];
    this.el['trade-island-name'].textContent = isl.name;
    this.el['trade-island-faction'].textContent = CONFIG.factions[isl.faction]?.name || 'Neutral';
    this.el['trade-island-faction'].className = 'faction-tag ' + isl.faction;
    const t = calcTariff(gs.player.faction, isl.faction, gs), tp = Math.round((t - 1) * 100);
    this.el['trade-tariff'].textContent = tp > 0 ? '+' + tp + '%' : 'No Tariff';

    // Show port state
    const portStateConfig = getPortStateConfig(gs, iid);
    const portStateId = getPortState(gs, iid);
    if (portStateConfig && portStateId !== 'prosperous') {
        this.el['trade-port-state'].textContent = `${portStateConfig.icon} ${portStateConfig.name}`;
        this.el['trade-port-state'].className = 'port-state-tag ' + portStateId;
        this.el['trade-port-state'].title = portStateConfig.desc;
        this.el['trade-port-state'].classList.remove('hidden');
    } else {
        this.el['trade-port-state'].classList.add('hidden');
    }

    recordAllPrices(iid, gs);
    this.renderBuy(iid, gs);
    this.renderSell(iid, gs);
    this.updateFooter(gs);

    // Update contracts badge
    const board = gs.world.boards[iid];
    const availableCount = board?.contracts?.length || 0;
    if (availableCount > 0) {
        this.el['contracts-badge'].textContent = availableCount;
        this.el['contracts-badge'].classList.remove('hidden');
    } else {
        this.el['contracts-badge'].classList.add('hidden');
    }

    this.el.tradeTabs.forEach(t => t.classList.toggle('active', t.dataset.tab === 'buy'));
    ['buy','sell','contracts','logbook','shipyard'].forEach(p => this.el[p+'-panel'].classList.toggle('hidden', p !== 'buy'));
    this.el['trade-modal'].classList.remove('hidden');
}

renderBuy(iid, gs) {
    const list = this.el['buy-goods-list']; list.innerHTML = '';
    Object.entries(CONFIG.goods).forEach(([gid, g]) => {
        const m = gs.islands[iid].markets[gid];
        // Show actual price including anti-spam penalty
        const antiSpamMult = getAntiSpamBuyMult(gs, iid, 1);
        const price = Math.max(1, Math.round(calcBuyPrice(gid, iid, gs) * antiSpamMult));
        const trend = getPriceTrend(gid, iid, price, gs);
        const check = canCarryMore(gid, 1, gs);
        const canBuy = m.supply > 0 && price <= gs.player.gold && check.canCarry;

        const item = document.createElement('div');
        item.className = 'good-item' + (!canBuy && check.reason ? ' blocked' : '');
        item.innerHTML = `
            <div class="good-info">
                <span class="good-icon">${g.icon}</span>
                <span class="good-name">${g.name}</span>
                <span class="good-price">${price}g<span class="price-trend ${trend}">${trend === 'up' ? '' : trend === 'down' ? '' : ''}</span></span>
            </div>
            <div class="good-details">Stock:${m.supply} Wt:${g.weight} ${check.reason && !canBuy ? `<span class="block-reason">${check.reason}</span>` : ''}</div>
            <div class="good-actions"><button class="qty-btn buy" ${!canBuy ? 'disabled' : ''}>+</button></div>
        `;
        item.querySelector('.qty-btn').addEventListener('click', () => {
            if (buyGood(gid, 1, iid, gs).success) {
                this.renderBuy(iid, gs); this.renderSell(iid, gs); this.updateFooter(gs); this.game.save();
            }
        });
        list.appendChild(item);
    });
}

renderSell(iid, gs) {
    const list = this.el['sell-goods-list']; list.innerHTML = '';
    if (!Object.keys(gs.player.cargo).length) { list.innerHTML = '<p style="text-align:center;color:var(--ink-light);padding:20px">Empty</p>'; return; }
    Object.entries(gs.player.cargo).forEach(([gid, qty]) => {
        const g = CONFIG.goods[gid];
        // Show actual price including saturation and anti-spam penalties
        const satPenalty = getSaturationPenalty(gs, iid, gid);
        const antiSpamMult = getAntiSpamSellMult(gs, iid, 1);
        const price = Math.max(1, Math.round(calcSellPrice(gid, iid, gs) * satPenalty * antiSpamMult));
        const trend = getPriceTrend(gid, iid, price, gs);
        const pp = gs.player.purchaseHistory[gid];
        const item = document.createElement('div'); item.className = 'good-item';
        item.innerHTML = `<div class="good-info"><span class="good-icon">${g.icon}</span><span class="good-name">${g.name}</span><span class="good-price">${price}g${pp ? (price > pp ? '' : '') : ''}<span class="price-trend ${trend}">${trend === 'up' ? '' : trend === 'down' ? '' : ''}</span></span></div><div class="good-details">Have:${qty}${pp ? ' @' + pp + 'g' : ''}</div><div class="good-actions"><button class="qty-btn sell"></button></div>`;
        item.querySelector('.qty-btn').addEventListener('click', () => { if (sellGood(gid, 1, iid, gs).success) { this.renderBuy(iid, gs); this.renderSell(iid, gs); this.updateFooter(gs); this.game.save(); } });
        list.appendChild(item);
    });
}

renderContracts() {
    const gs = this.game.gameState;
    const iid = gs.currentIsland;
    if (!iid) return;

    // Render questlines section
    this.renderQuestlines();

    // Refresh board if needed
    refreshContractBoard(gs, iid);
    const board = gs.world.boards[iid];

    // Render available contracts
    const availEl = this.el['available-contracts'];
    if (board.contracts.length === 0) {
        availEl.innerHTML = '<div class="contract-empty">No contracts available. Check back later!</div>';
    } else {
        availEl.innerHTML = board.contracts.map(c => this.renderContractCard(c, gs, 'available')).join('');
        availEl.querySelectorAll('.accept-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const result = acceptContract(gs, btn.dataset.id);
                if (result.success) {
                    this.renderContracts();
                    this.updateContractTracker(gs);
                    this.updateHUD(gs);
                    this.toast('Contract Accepted', 'Check your active contracts');
                    this.game.save();
                } else {
                    this.toast('Cannot Accept', result.reason || 'Unknown error');
                }
            });
        });
    }

    // Render active contracts
    const activeEl = this.el['active-contracts'];
    this.el['active-count'].textContent = gs.player.contracts.active.length;

    if (gs.player.contracts.active.length === 0) {
        activeEl.innerHTML = '<div class="contract-empty">No active contracts</div>';
    } else {
        activeEl.innerHTML = gs.player.contracts.active.map(c => this.renderContractCard(c, gs, 'active')).join('');
        activeEl.querySelectorAll('.track-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                gs.player.trackedContractId = gs.player.trackedContractId === btn.dataset.id ? null : btn.dataset.id;
                this.renderContracts();
                this.updateContractTracker(gs);
                this.game.save();
            });
        });
        activeEl.querySelectorAll('.abandon-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (confirm('Abandon this contract? You will lose reputation.')) {
                    abandonContract(gs, btn.dataset.id);
                    this.renderContracts();
                    this.updateContractTracker(gs);
                    this.toast('Contract Abandoned', '-3 reputation');
                    this.game.save();
                }
            });
        });
    }
}

renderContractCard(contract, gs, mode) {
    const type = CONFIG.contractTypes[contract.typeId];
    const dest = CONFIG.islands[contract.toIsland];
    if (!type || !dest) return ''; // Safety check

    const isTracked = gs.player.trackedContractId === contract.id;

    let daysLeft = contract.deadline;
    let progress = '';

    if (mode === 'active') {
        daysLeft = contract.deadline - (gs.player.days - contract.dayAccepted);
        if (contract.requirement?.type === 'deliver' && contract.requirement.goodId) {
            const good = CONFIG.goods[contract.requirement.goodId];
            if (good) {
                const have = gs.player.cargo[contract.requirement.goodId] || 0;
                const need = contract.requirement.qty;
                progress = `<div class="contract-details"> ${good.icon} ${have}/${need}</div>`;
            }
        }
    }

    const deadlineClass = daysLeft <= 2 ? 'urgent' : '';
    const cardClass = mode === 'active' ? 'active' : '';
    const trackedClass = isTracked ? 'tracked' : '';

    let actions = '';
    if (mode === 'available') {
        const canAccept = gs.player.contracts.active.length < CONFIG.settings.maxActiveContracts;
        actions = `<button class="btn-small ${canAccept ? 'btn-primary' : 'btn-secondary'} accept-btn" data-id="${contract.id}" ${canAccept ? '' : 'disabled'}>Accept</button>`;
    } else {
        actions = `
            <button class="btn-small ${isTracked ? 'btn-primary' : 'btn-secondary'} track-btn" data-id="${contract.id}">${isTracked ? ' Tracked' : 'Track'}</button>
            <button class="btn-small btn-secondary abandon-btn" data-id="${contract.id}"></button>
        `;
    }

    let requirementText = '';
    if (contract.requirement?.type === 'deliver' && contract.requirement.goodId) {
        const good = CONFIG.goods[contract.requirement.goodId];
        if (good) {
            requirementText = `Deliver ${contract.requirement.qty}x ${good.icon} ${good.name}`;
        } else {
            requirementText = `Deliver ${contract.requirement.qty}x goods`;
        }
    } else if (contract.requirement?.type === 'reach') {
        requirementText = contract.requirement.noInspection ? 'Reach without inspection' : 'Reach destination';
    } else if (contract.requirement?.type === 'supplies') {
        requirementText = `Arrive with ${contract.requirement.minSupplies}+ supplies`;
    }

    // === BALANCE: Show contract costs ===
    let costText = '';
    if (mode === 'available') {
        const costs = [];
        if (type.depositPct) {
            const deposit = Math.floor(contract.rewards.gold * type.depositPct);
            costs.push(`${deposit}g deposit`);
        }
        if (type.supplyCost) {
            costs.push(`${type.supplyCost} supplies`);
        }
        if (costs.length > 0) {
            costText = `<div class="contract-cost"> Cost: ${costs.join(', ')}</div>`;
        }
    }

    return `
        <div class="contract-card ${cardClass} ${trackedClass}">
            <div class="contract-header">
                <span class="contract-title">${contract.title}</span>
                <span class="contract-type ${contract.typeId}">${type.icon} ${type.name}</span>
            </div>
            <div class="contract-details"> ${dest.name}  ${requirementText}</div>
            ${progress}
            <div class="contract-deadline ${deadlineClass}"> ${daysLeft} days left</div>
            <div class="contract-rewards">
                <span class="contract-reward gold"> ${contract.rewards.gold}g</span>
                <span class="contract-reward rep">${contract.rewards.rep > 0 ? '+' : ''}${contract.rewards.rep} ${contract.rewards.repFaction} rep</span>
            </div>
            ${costText}
            <div class="contract-actions">${actions}</div>
        </div>
    `;
}

// === LIVING SEA: Questline UI ===
renderQuestlines() {
    const gs = this.game.gameState;
    const contentEl = this.el['questline-content'];
    if (!contentEl) return;

    const activeProgress = getQuestlineProgress(gs);

    if (activeProgress) {
        // Show active questline
        const { questline, currentStep, stepIndex, totalSteps, daysRemaining } = activeProgress;
        const qProgress = gs.player.questlineProgress[activeProgress.questlineId] || {};
        const stepsHtml = questline.steps.map((step, i) => {
            let status = 'pending';
            let icon = '';
            let progressText = '';
            if (i < stepIndex) { status = 'completed'; icon = ''; }
            else if (i === stepIndex) {
                status = 'current';
                icon = '';
                // Show delivery progress for deliver_count steps
                if (step.type === 'deliver_count' && step.count > 1) {
                    const delivered = qProgress.stepProgress?.delivered || 0;
                    progressText = ` <span style="color:var(--gold)">(${delivered}/${step.count})</span>`;
                }
            }
            const destText = step.to ? `  ${CONFIG.islands[step.to]?.name || step.to}` : (step.at ? ` @ ${CONFIG.islands[step.at]?.name || step.at}` : '');
            let goodsText = '';
            if (step.goods && i === stepIndex) {
                const goodsList = Object.entries(step.goods).map(([gid, qty]) => `${qty}x ${CONFIG.goods[gid]?.name || gid}`).join(', ');
                goodsText = ` <span style="font-size:0.65rem;color:var(--ink-light)">[${goodsList}]</span>`;
            }
            const rewardText = step.reward && i === stepIndex ? ` <span style="color:var(--gold);font-size:0.65rem">+${step.reward}g ea</span>` : '';
            return `<div class="questline-step ${status}"><span class="step-icon">${icon}</span><span>${step.desc}${destText}${goodsText}${progressText}${rewardText}</span></div>`;
        }).join('');

        const rewardsHtml = [];
        if (questline.rewards.gold) rewardsHtml.push(`<span> ${questline.rewards.gold}g</span>`);
        if (questline.rewards.reputation) {
            Object.entries(questline.rewards.reputation).forEach(([fid, amt]) => {
                rewardsHtml.push(`<span>${amt > 0 ? '+' : ''}${amt} ${fid}</span>`);
            });
        }
        if (questline.rewards.title) rewardsHtml.push(`<span> "${questline.rewards.title}"</span>`);
        if (questline.rewards.pardon) rewardsHtml.push(`<span> Pardon</span>`);

        contentEl.innerHTML = `
            <div class="questline-card active">
                <div class="questline-header">
                    <span class="questline-title">${questline.icon} ${questline.name}</span>
                    <span class="questline-deadline">${daysRemaining} days left</span>
                </div>
                <p class="questline-desc">${questline.desc}</p>
                <div class="questline-steps">${stepsHtml}</div>
                <div class="questline-rewards">${rewardsHtml.join('')}</div>
                <div class="questline-actions">
                    <button class="btn-small btn-danger abandon-quest-btn">Abandon Quest</button>
                </div>
            </div>
        `;

        contentEl.querySelector('.abandon-quest-btn')?.addEventListener('click', () => {
            if (confirm('Abandon this questline? All progress will be lost.')) {
                this.game.abandonQuestline();
                this.renderQuestlines();
            }
        });
    } else {
        // Show available questlines with tier filtering (per-faction progression)
        // Calculate highest completed tier PER FACTION
        const completedTiersByFaction = {};
        Object.entries(gs.player.questlineProgress || {}).forEach(([qid, prog]) => {
            if (prog.completed) {
                const q = CONFIG.questlines[qid];
                if (q?.tier && q?.faction) {
                    const faction = q.faction;
                    completedTiersByFaction[faction] = Math.max(completedTiersByFaction[faction] || 0, q.tier);
                }
            }
        });

        const availableQuests = Object.entries(CONFIG.questlines).filter(([id, q]) => {
            // Already completed - can't repeat
            if (gs.player.questlineProgress[id]?.completed) return false;
            // Check tier requirements - must have completed previous tier OF SAME FACTION
            const requiredTier = q.requires || 0;
            if (requiredTier > 0) {
                const factionProgress = completedTiersByFaction[q.faction] || 0;
                if (requiredTier > factionProgress) return false;
            }
            return true;
        });

        if (availableQuests.length === 0) {
            contentEl.innerHTML = '<div class="questline-empty">No questlines available. Complete quests to unlock more!</div>';
        } else {
            contentEl.innerHTML = availableQuests.map(([id, q]) => {
                const rewardsHtml = [];
                if (q.rewards.gold) rewardsHtml.push(`<span> ${q.rewards.gold}g</span>`);
                if (q.rewards.reputation) {
                    Object.entries(q.rewards.reputation).forEach(([fid, amt]) => {
                        rewardsHtml.push(`<span>${amt > 0 ? '+' : ''}${amt} ${fid}</span>`);
                    });
                }
                if (q.rewards.title) rewardsHtml.push(`<span> "${q.rewards.title}"</span>`);
                if (q.rewards.pardon) rewardsHtml.push(`<span> Pardon</span>`);

                const tierLabel = q.tier ? `<span class="questline-tier">Tier ${q.tier}</span>` : '';

                return `
                    <div class="questline-card">
                        <div class="questline-header">
                            <span class="questline-title">${q.icon} ${q.name} ${tierLabel}</span>
                            <span class="questline-deadline">${q.deadline} day limit</span>
                        </div>
                        <p class="questline-desc">${q.desc}</p>
                        <div class="questline-rewards">${rewardsHtml.join('')}</div>
                        <div class="questline-actions">
                            <button class="btn-small btn-primary start-quest-btn" data-id="${id}">Start Quest</button>
                        </div>
                    </div>
                `;
            }).join('');

            contentEl.querySelectorAll('.start-quest-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const result = this.game.startQuestline(btn.dataset.id);
                    if (result.success) {
                        this.toast('Quest Started', result.questline.name);
                        this.renderQuestlines();
                    } else {
                        this.toast('Cannot Start', result.reason);
                    }
                });
            });
        }
    }
}

renderLogbook() {
    const gs = this.game.gameState, iid = gs.currentIsland, deals = calcDeals(gs, iid);
    this.el['spotlight-list'].innerHTML = deals.length ? deals.map(d => `<div class="spotlight-card" data-dest="${d.sellIsland}"><div class="spotlight-header"><span class="spotlight-good">${d.good.icon} ${d.good.name}</span><span class="spotlight-profit">+${d.profit}g</span></div><div class="spotlight-route">Buy @${d.buyPrice}g  ${CONFIG.islands[d.sellIsland].name} @${d.sellPrice}g <span class="confidence-tag confidence-${d.confidence.level}">${d.confidence.label}</span></div></div>`).join('') : '<div class="spotlight-empty">Visit more ports!</div>';
    this.el['spotlight-list'].querySelectorAll('.spotlight-card').forEach(c => c.addEventListener('click', () => { this.game.gameState.player.destinationIslandId = c.dataset.dest; this.toast('Course Set', CONFIG.islands[c.dataset.dest].name); }));
    const sel = this.el['logbook-island-select']; sel.innerHTML = '';
    Object.entries(CONFIG.islands).forEach(([id, isl]) => { const v = gs.player.visitedIslands[id]; const o = document.createElement('option'); o.value = id; o.textContent = isl.name + (v ? ` (D${v.lastVisitDay})` : ''); if (id === iid) o.selected = true; sel.appendChild(o); });
    this.renderLogPrices(iid);
}

renderLogPrices(iid) {
    const gs = this.game.gameState, v = gs.player.visitedIslands[iid];
    if (!v?.lastPrices) { this.el['logbook-prices'].innerHTML = '<p style="text-align:center;color:var(--ink-light)">No data</p>'; return; }
    this.el['logbook-prices'].innerHTML = Object.entries(CONFIG.goods).map(([gid, g]) => {
        const lp = v.lastPrices[gid]; if (!lp) return '';
        let cmp = ''; if (iid !== gs.currentIsland) { const cp = calcPrice(gid, gs.currentIsland, gs), diff = lp - cp; if (Math.abs(diff) > 2) cmp = diff > 0 ? `<span style="color:#1e7d34">+${diff}</span>` : `<span style="color:var(--blood-red)">${diff}</span>`; }
        return `<div class="logbook-item"><div class="good-info"><span>${g.icon}</span><span>${g.name}</span></div><div>${lp}g ${cmp}</div></div>`;
    }).join('');
}

renderShipyard() {
    const gs = this.game.gameState;

    // === LIVING SEA: Ship Repairs Section ===
    const hull = getShipHull(gs), rigging = getShipRigging(gs), morale = getShipMorale(gs);
    const maxHull = getMaxHull(gs), maxRigging = getMaxRigging(gs), maxMorale = getMaxMorale(gs);
    const hullDmg = maxHull - hull, riggingDmg = maxRigging - rigging, moraleDmg = maxMorale - morale;
    const hullCost = hullDmg > 0 ? getRepairCost(gs, 'hull', hullDmg) : 0;
    const riggingCost = riggingDmg > 0 ? getRepairCost(gs, 'rigging', riggingDmg) : 0;
    const moraleCost = moraleDmg > 0 ? getRepairCost(gs, 'rest', moraleDmg) : 0;
    const canAffordHull = gs.player.gold >= hullCost && hullDmg > 0;
    const canAffordRigging = gs.player.gold >= riggingCost && riggingDmg > 0;
    const canAffordMorale = gs.player.gold >= moraleCost && moraleDmg > 0;
    const shipClass = CONFIG.shipClasses?.[gs.player.shipClass] || CONFIG.shipClasses?.brigantine;

    const repairsHtml = `
        <div class="shipyard-section">
            <h4> Ship Repairs - ${shipClass?.name || 'Brigantine'}</h4>
            <div class="repair-grid">
                <div class="repair-card ${hullDmg <= 0 ? 'full' : ''}">
                    <div class="repair-header"><span> Hull</span><span>${Math.round(hull)}/${maxHull}</span></div>
                    <div class="repair-bar"><div class="repair-fill hull" style="width: ${(hull/maxHull)*100}%"></div></div>
                    ${hullDmg > 0 ? `<button class="btn-secondary btn-small repair-btn" data-type="hull" ${canAffordHull ? '' : 'disabled'}>Repair ${hullCost}g</button>` : '<span class="repair-full">Full</span>'}
                </div>
                <div class="repair-card ${riggingDmg <= 0 ? 'full' : ''}">
                    <div class="repair-header"><span> Rigging</span><span>${Math.round(rigging)}/${maxRigging}</span></div>
                    <div class="repair-bar"><div class="repair-fill rigging" style="width: ${(rigging/maxRigging)*100}%"></div></div>
                    ${riggingDmg > 0 ? `<button class="btn-secondary btn-small repair-btn" data-type="rigging" ${canAffordRigging ? '' : 'disabled'}>Repair ${riggingCost}g</button>` : '<span class="repair-full">Full</span>'}
                </div>
                <div class="repair-card ${moraleDmg <= 0 ? 'full' : ''}">
                    <div class="repair-header"><span> Morale</span><span>${Math.round(morale)}/${maxMorale}</span></div>
                    <div class="repair-bar"><div class="repair-fill morale" style="width: ${(morale/maxMorale)*100}%"></div></div>
                    ${moraleDmg > 0 ? `<button class="btn-secondary btn-small repair-btn" data-type="morale" ${canAffordMorale ? '' : 'disabled'}>Rest & Resupply ${moraleCost}g</button>` : '<span class="repair-full">High Spirits</span>'}
                </div>
            </div>
        </div>
        <div class="shipyard-section">
            <h4> Ships for Sale</h4>
            <div class="ship-grid" id="ships-for-sale"></div>
        </div>
        <div class="shipyard-section">
            <h4> Ship Upgrades</h4>
        </div>
    `;

    // Ship classes for sale
    const currentShip = gs.player.shipClass || 'brigantine';
    const shipsHtml = Object.entries(CONFIG.shipClasses || {}).map(([id, ship]) => {
        const isOwned = currentShip === id;
        const canAfford = gs.player.gold >= ship.cost;
        return `
            <div class="ship-card ${isOwned ? 'owned' : ''}">
                <div class="ship-header">
                    <span class="ship-name">${ship.icon || ''} ${ship.name}</span>
                    <span class="ship-cost">${isOwned ? 'Current' : ship.cost + 'g'}</span>
                </div>
                <div class="ship-stats">
                    <div class="ship-stat"><span>Speed:</span><span>${ship.baseSpeed}x</span></div>
                    <div class="ship-stat"><span>Cargo:</span><span>${ship.cargoCapacity}</span></div>
                    <div class="ship-stat"><span>Hull:</span><span>${ship.hullMax}</span></div>
                    <div class="ship-stat"><span>Rigging:</span><span>${ship.riggingMax}</span></div>
                </div>
                <p class="ship-desc">${ship.desc || ''}</p>
                ${!isOwned ? `<button class="btn-primary btn-small buy-ship-btn" data-id="${id}" ${canAfford ? '' : 'disabled'}>${canAfford ? 'Purchase' : 'Need Gold'}</button>` : ''}
            </div>
        `;
    }).join('');

    // Upgrades section
    const upgradesHtml = Object.entries(CONFIG.upgrades).map(([id, u]) => {
        // === BALANCE: Use scaled upgrade cost ===
        const scaledCost = this.game.getUpgradeCost(id);
        const owned = gs.player.upgrades[id], afford = gs.player.gold >= scaledCost;
        const prosHtml = u.pros.map(p => `<span class="upgrade-stat positive">${p}</span>`).join('');
        const consHtml = u.cons.map(c => `<span class="upgrade-stat negative">${c}</span>`).join('');
        return `<div class="upgrade-card ${owned ? 'owned' : ''}">
            <div class="upgrade-header"><span class="upgrade-name">${u.icon} ${u.name}</span><span class="upgrade-cost">${owned ? '' : scaledCost + 'g'}</span></div>
            <div class="upgrade-desc">${u.desc}</div>
            <div class="upgrade-stats">${prosHtml}${consHtml}</div>
            ${!owned ? `<button class="btn-secondary btn-small upg-btn" data-id="${id}" ${afford ? '' : 'disabled'}>${afford ? 'Buy' : 'Need gold'}</button>` : ''}
        </div>`;
    }).join('');

    // === LIVING SEA: Pardon section ===
    const bountyLevel = getBountyLevel(gs);
    const bounty = getBounty(gs);
    const pardonCost = getPardonCost(gs, gs.currentIsland);
    const canPardon = pardonCost !== null && bounty > 0 && gs.player.gold >= pardonCost;
    const bountyColors = { clean: '#4a9', wanted: '#da4', hunted: '#e83', infamous: '#c33' };
    const bountyIcons = { clean: '', wanted: '', hunted: '', infamous: '' };

    let pardonHtml = '';
    if (bounty > 0) {
        pardonHtml = `
            <div class="shipyard-section">
                <h4> Legal Status</h4>
                <div class="pardon-card">
                    <div class="pardon-status">
                        <span class="bounty-icon">${bountyIcons[bountyLevel]}</span>
                        <span class="bounty-level" style="color: ${bountyColors[bountyLevel]}; text-transform: capitalize;">${bountyLevel}</span>
                        <span class="bounty-amount">(${bounty} bounty)</span>
                    </div>
                    ${pardonCost !== null ? `
                        <p class="pardon-desc">The authorities here can clear your record... for a price.</p>
                        <button class="btn-primary btn-small pardon-btn" ${canPardon ? '' : 'disabled'}>
                            ${canPardon ? `Buy Pardon (${pardonCost}g)` : (gs.player.gold < pardonCost ? `Need ${pardonCost}g` : 'Unavailable')}
                        </button>
                    ` : `
                        <p class="pardon-desc">This port doesn't offer pardons. Try an English, EITC, or neutral port.</p>
                    `}
                </div>
            </div>
        `;
    }

    this.el['upgrades-list'].innerHTML = repairsHtml + `<div class="ship-grid">${shipsHtml}</div>` + upgradesHtml + pardonHtml;

    // Bind repair buttons
    this.el['upgrades-list'].querySelectorAll('.repair-btn').forEach(b => b.addEventListener('click', () => {
        const type = b.dataset.type;
        if (this.game.repairShip(type)) {
            this.renderShipyard();
            this.updateFooter(gs);
            this.updateHUD(gs);
        }
    }));

    // Bind ship purchase buttons
    this.el['upgrades-list'].querySelectorAll('.buy-ship-btn').forEach(b => b.addEventListener('click', () => {
        if (this.game.buyShip(b.dataset.id)) {
            this.renderShipyard();
            this.updateFooter(gs);
            this.updateHUD(gs);
        }
    }));

    // Bind upgrade buttons
    this.el['upgrades-list'].querySelectorAll('.upg-btn').forEach(b => b.addEventListener('click', () => { if (this.game.buyUpgrade(b.dataset.id)) { this.renderShipyard(); this.updateFooter(gs); } }));

    // Bind pardon button
    const pardonBtn = this.el['upgrades-list'].querySelector('.pardon-btn');
    if (pardonBtn) {
        pardonBtn.addEventListener('click', () => {
            if (this.game.buyPardon()) {
                this.renderShipyard();
                this.updateFooter(gs);
                this.updateHUD(gs);
            }
        });
    }
}

// === LIVING SEA: Tavern / Officers Panel ===
renderTavern() {
    const gs = this.game.gameState;
    const officers = gs.player.officers || [];
    const islandId = gs.currentIsland;

    // Update officer count
    this.el['officer-count'].textContent = officers.length;

    // Render current officers
    if (officers.length === 0) {
        this.el['current-officers'].innerHTML = '<div class="officers-empty">No officers hired. Visit the tavern to recruit!</div>';
    } else {
        this.el['current-officers'].innerHTML = officers.map(off => {
            const cfg = CONFIG.officers?.[off.id] || {};
            return `
                <div class="officer-card hired">
                    <div class="officer-header">
                        <span class="officer-name">${cfg.icon || ''} ${off.name}</span>
                        <span class="officer-wage">${off.wage || cfg.baseWage || 5}g/day</span>
                    </div>
                    <span class="officer-type">${cfg.name || off.role}</span>
                    <div class="officer-traits">
                        ${cfg.perk ? `<span class="officer-trait positive"> ${cfg.perk}</span>` : ''}
                        ${cfg.drawback ? `<span class="officer-trait negative"> ${cfg.drawback}</span>` : ''}
                    </div>
                    <div class="officer-actions">
                        <button class="btn-danger btn-small fire-officer-btn" data-id="${off.id}">Dismiss</button>
                    </div>
                </div>
            `;
        }).join('');

        // Bind fire buttons
        this.el['current-officers'].querySelectorAll('.fire-officer-btn').forEach(b => {
            b.addEventListener('click', () => {
                if (this.game.fireOfficer(b.dataset.id)) {
                    this.renderTavern();
                    this.updateFooter(gs);
                }
            });
        });
    }

    // Render available officers at this port
    const available = getAvailableOfficersAtPort(gs, islandId);
    if (available.length === 0) {
        this.el['available-officers'].innerHTML = '<div class="officers-empty">No officers looking for work here. Try another port.</div>';
    } else {
        this.el['available-officers'].innerHTML = available.map(off => {
            const cfg = CONFIG.officers?.[off.type] || {};
            const hireCost = cfg.hireCost || 100;
            const canHire = officers.length < 3 && gs.player.gold >= hireCost;
            return `
                <div class="officer-card">
                    <div class="officer-header">
                        <span class="officer-name">${cfg.icon || ''} ${off.name}</span>
                        <span class="officer-wage">${cfg.baseWage || 5}g/day</span>
                    </div>
                    <span class="officer-type">${cfg.name || off.type}</span>
                    <div class="officer-traits">
                        ${cfg.perk ? `<span class="officer-trait positive"> ${cfg.perk}</span>` : ''}
                        ${cfg.drawback ? `<span class="officer-trait negative"> ${cfg.drawback}</span>` : ''}
                    </div>
                    <div class="officer-actions">
                        <button class="btn-primary btn-small hire-officer-btn" data-type="${off.type}" data-name="${off.name}" ${canHire ? '' : 'disabled'}>
                            ${canHire ? `Hire (${hireCost}g)` : officers.length >= 3 ? 'Crew Full' : 'Need Gold'}
                        </button>
                    </div>
                </div>
            `;
        }).join('');

        // Bind hire buttons
        this.el['available-officers'].querySelectorAll('.hire-officer-btn').forEach(b => {
            b.addEventListener('click', () => {
                if (this.game.hireOfficer(b.dataset.type, b.dataset.name)) {
                    this.renderTavern();
                    this.updateFooter(gs);
                    this.updateHUD(gs);
                }
            });
        });
    }

    // Render port rumors
    this.renderRumors(islandId, gs);
}

renderRumors(islandId, gs) {
    const rumorsEl = this.el['tavern-rumors'];
    if (!rumorsEl) return;

    const rumors = getRumorsForPort(gs, islandId);
    if (!rumors || rumors.length === 0) {
        rumorsEl.innerHTML = '<div class="officers-empty">The tavern is quiet. No interesting news.</div>';
        return;
    }

    const rumorIcons = {
        convoy: '',
        shortage: '',
        surplus: '',
        danger: '',
        opportunity: '',
        weather: '',
        political: ''
    };

    rumorsEl.innerHTML = rumors.map(r => {
        const icon = rumorIcons[r.type] || '';
        const truthClass = r.truth ? 'rumor-true' : 'rumor-false';
        const freshness = gs.player.days - r.createdDay;
        const freshnessLabel = freshness <= 1 ? 'Fresh' : freshness <= 3 ? 'Recent' : 'Old';
        return `
            <div class="rumor-card ${truthClass}">
                <span class="rumor-icon">${icon}</span>
                <span class="rumor-text">"${r.text}"</span>
                <span class="rumor-age">${freshnessLabel}</span>
            </div>
        `;
    }).join('');
}

updateFooter(gs) { this.el['trade-gold'].textContent = gs.player.gold.toLocaleString(); this.el['trade-cargo'].textContent = getCargoUsed(gs) + '/' + getCargoCapacity(gs); }
closeTrade() { this.el['trade-modal'].classList.add('hidden'); }

// ==================== LIVING SEA: Cove UI ====================
showCove(coveId, gs) {
    const cove = CONFIG.hiddenCoves[coveId];
    if (!cove || !cove.services || !Array.isArray(cove.services)) return;

    this.el['cove-icon'].textContent = cove.icon || '';
    this.el['cove-name'].textContent = cove.name || 'Hidden Cove';
    this.el['cove-desc'].textContent = cove.desc || '';

    // Build service buttons
    const servicesEl = this.el['cove-services'];
    if (!servicesEl) return;
    servicesEl.innerHTML = '';

    const serviceLabels = {
        fence: { icon: '', label: 'Fence Contraband', desc: 'Sell at 150%, no heat' },
        salvage: { icon: '', label: 'Buy Salvage (50g)', desc: 'Random goods cheap' },
        repair: { icon: '', label: 'Cheap Repairs', desc: '50% off repairs' },
        rest: { icon: '', label: 'Rest Crew (25g)', desc: 'Restore morale' },
        treasure: { icon: '', label: 'Search Treasure', desc: 'One-time gold find' },
        charts: { icon: '', label: 'Buy Charts (75g)', desc: 'Get chart fragment' },
        rumors: { icon: '', label: 'Hear Rumors', desc: 'Learn cove locations' }
    };

    for (const service of cove.services) {
        const info = serviceLabels[service];
        if (!info) continue;

        const btn = document.createElement('button');
        btn.className = 'btn-secondary cove-service-btn';
        btn.innerHTML = `${info.icon} ${info.label} <small style="opacity:0.7">(${info.desc})</small>`;
        btn.addEventListener('click', () => {
            this.game.useCoveService(coveId, service);
        });
        servicesEl.appendChild(btn);
    }

    this.el['cove-modal'].classList.remove('hidden');
}

closeCove() {
    this.el['cove-modal'].classList.add('hidden');
    this.game.undockCove();
}

showMenu() {
    const gs = this.game.gameState;
    ['english','eitc','pirates'].forEach(f => { const r = gs.player.reputation[f] || 0; this.el['rep-' + f].style.width = (r + 100) / 2 + '%'; this.el['rep-' + f].className = 'rep-fill' + (r < -30 ? ' hostile' : r > 30 ? ' friendly' : ''); this.el['rep-' + f + '-val'].textContent = r; });
    this.el['ship-speed'].textContent = getShipSpeed(gs).toFixed(2) + 'x';
    this.el['ship-cargo-cap'].textContent = getCargoCapacity(gs);
    this.el['ship-supply-rate'].textContent = getSupplyRate(gs).toFixed(1);
    const upgs = Object.keys(gs.player.upgrades).filter(k => gs.player.upgrades[k]).map(k => CONFIG.upgrades[k]?.name);
    this.el['ship-upgrades'].textContent = upgs.length ? upgs.join(', ') : 'None';
    if (gs.wind) {
        this.el['menu-wind-dir'].textContent = WIND_DIRS[gs.wind.direction].name + ' ' + WIND_STR[gs.wind.strength].name;
        this.el['menu-wind-change'].textContent = gs.wind.daysUntilChange + 'd';
    }
    // Risk
    const risk = getRouteRisk(gs), rl = getRiskLabel(risk);
    this.el['menu-route-risk'].textContent = rl.label;
    this.el['menu-route-risk'].className = rl.class;
    this.el['menu-heat'].textContent = (gs.player.heat || 0) + '/100';

    // Titles
    this.renderTitles(gs);

    // World status
    const season = getSeasonLabel(gs);
    this.el['menu-season'].textContent = `${season.icon} ${season.label} (Day ${gs.world?.seasonDay || 1}/${CONFIG.settings.seasonCycleDays})`;

    const crackdown = getCrackdownLevel(gs);
    this.el['menu-crackdown'].textContent = crackdown > 0 ? `Level ${crackdown}` : 'None';
    this.el['menu-crackdown'].className = crackdown > 50 ? 'risk-high' : crackdown > 25 ? 'risk-med' : '';

    const regional = gs.world?.regionalEvent;
    this.el['menu-regional'].textContent = regional ? `${regional.name} (${regional.daysRemaining}d)` : 'None';

    this.el['menu-modal'].classList.remove('hidden');
}

renderTitles(gs) {
    const titlesEl = this.el['titles-list'];
    titlesEl.innerHTML = Object.entries(CONFIG.titles).map(([trackId, track]) => {
        const tier = getTitleTier(trackId, gs);
        const name = getTitleName(trackId, tier);
        const value = getTitleTrackValue(trackId, gs);
        const nextThreshold = getNextThreshold(trackId, gs);
        const tierClass = `tier-${Math.min(tier, 5)}`;

        return `
            <div class="title-item">
                <div>
                    <span class="title-name">${track.icon} ${track.name}</span>
                    <span class="title-tier ${tierClass}">${name}</span>
                </div>
                <span class="title-progress">${Math.floor(value)}/${nextThreshold}</span>
            </div>
        `;
    }).join('');
}

showMap() {
    const c = this.el['map-container'], gs = this.game.gameState; c.innerHTML = '';
    const minX = -220, maxX = 240, minZ = -180, maxZ = 160, toP = (v, mn, mx) => (v - mn) / (mx - mn) * 100;

    // Show course to tracked contract or manual destination
    const tracked = getTrackedContract(gs);
    const destId = tracked?.toIsland || gs.player.destinationIslandId;

    if (destId) {
        const d = CONFIG.islands[destId];
        const px = toP(gs.player.position.x, minX, maxX), py = toP(gs.player.position.z, minZ, maxZ);
        const dx = toP(d.position.x, minX, maxX), dy = toP(d.position.z, minZ, maxZ);

        // Account for aspect ratio - container is not square
        const containerWidth = c.offsetWidth || 300;
        const containerHeight = c.offsetHeight || 250;
        const aspectRatio = containerHeight / containerWidth;

        // Calculate pixel-space delta (scale Y by aspect ratio)
        const deltaXPx = (dx - px);
        const deltaYPx = (dy - py) * aspectRatio;

        // Length in percentage of width (since line width is % of container width)
        const len = Math.sqrt(deltaXPx**2 + deltaYPx**2);
        // Angle calculated with aspect-corrected Y
        const ang = Math.atan2(deltaYPx, deltaXPx) * 180 / Math.PI;

        const line = document.createElement('div');
        line.className = 'map-course-line';
        line.style.cssText = `left:${px}%;top:${py}%;width:${len}%;transform:rotate(${ang}deg)`;
        c.appendChild(line);
    }

    // Show faction influence zones (behind everything)
    Object.entries(CONFIG.islands).forEach(([id, isl]) => {
        const inf = getIslandInfluence(gs, id);
        const dominant = getDominantFaction(gs, id);
        const zoneSize = 60 + (inf.stability / 100) * 40; // 60-100px based on stability

        const zone = document.createElement('div');
        zone.className = 'map-influence-zone ' + dominant;
        zone.style.cssText = `left:${toP(isl.position.x, minX, maxX)}%;top:${toP(isl.position.z, minZ, maxZ)}%;width:${zoneSize}px;height:${zoneSize}px`;
        c.appendChild(zone);
    });

    // Show drift entities (storms, fleets, markets)
    if (gs.world?.driftEntities) {
        for (const entity of gs.world.driftEntities) {
            const config = CONFIG.driftEntities[entity.typeId];
            if (config) {
                const de = document.createElement('div');
                de.className = 'map-drift-entity';
                de.style.cssText = `left:${toP(entity.position.x, minX, maxX)}%;top:${toP(entity.position.z, minZ, maxZ)}%;background:${config.color}`;
                de.textContent = config.icon;
                de.title = config.name;
                c.appendChild(de);
            }
        }
    }

    // Show blockade lines from blockading fleets to blocked islands
    const blockades = getActiveBlockades(gs);
    for (const b of blockades) {
        const isl = CONFIG.islands[b.islandId];
        if (!isl) continue;
        // Draw blockade indicator line
        const ix = toP(isl.position.x, minX, maxX);
        const iy = toP(isl.position.z, minZ, maxZ);
        // Small blockade ring
        const ring = document.createElement('div');
        ring.className = 'map-blockade-line';
        ring.style.cssText = `left:${ix - 3}%;top:${iy}%;width:6%;transform:rotate(0deg)`;
        ring.title = `Blockaded by ${b.blockadingFaction} (${b.daysRemaining}d)`;
        c.appendChild(ring);
    }

    Object.entries(CONFIG.islands).forEach(([id, isl]) => {
        const isBlockaded = isIslandBlockaded(gs, id);
        const isWarzone = isIslandWarZone(gs, id);
        const inf = getIslandInfluence(gs, id);
        const dominant = getDominantFaction(gs, id);

        // Use dominant faction color if contested
        const factionClass = dominant === 'contested' ? 'neutral' : (dominant || isl.faction);
        let classes = 'map-island ' + factionClass + (id === destId ? ' selected' : '');
        if (isBlockaded) classes += ' blockaded';
        if (isWarzone) classes += ' warzone';

        const dot = document.createElement('div');
        dot.className = classes;
        dot.style.cssText = `left:${toP(isl.position.x, minX, maxX)}%;top:${toP(isl.position.z, minZ, maxZ)}%`;
        dot.textContent = isl.name[0];

        // Enhanced tooltip with influence info
        let tooltip = isl.name;
        if (isBlockaded) {
            const bInfo = getBlockadeInfo(gs, id);
            tooltip += ` [BLOCKADED by ${bInfo.blockadingFaction}]`;
        }
        if (isWarzone) {
            const wInfo = getWarZoneInfo(gs, id);
            tooltip += ` [WAR: ${wInfo.factions.join(' vs ')}]`;
        }
        if (dominant === 'contested') {
            tooltip += ` (Contested: E${Math.round(inf.english)}% C${Math.round(inf.eitc)}% P${Math.round(inf.pirates)}%)`;
        }
        dot.title = tooltip;

        dot.addEventListener('click', () => { gs.player.destinationIslandId = id; this.showMap(); this.toast('Course', isl.name); });
        c.appendChild(dot);
    });

    // Show discovered hidden coves
    const discoveredCoves = getDiscoveredCoves(gs);
    for (const coveId of discoveredCoves) {
        const cove = CONFIG.hiddenCoves[coveId];
        if (!cove) continue;
        const coveDot = document.createElement('div');
        coveDot.className = 'map-cove' + (gs.player.destinationCoveId === coveId ? ' selected' : '');
        coveDot.style.cssText = `left:${toP(cove.position.x, minX, maxX)}%;top:${toP(cove.position.z, minZ, maxZ)}%`;
        coveDot.textContent = cove.icon;
        coveDot.title = cove.name + ' - ' + cove.desc;
        coveDot.addEventListener('click', () => {
            gs.player.destinationCoveId = coveId;
            gs.player.destinationIslandId = null;
            this.showMap();
            this.toast('Course', cove.name);
        });
        c.appendChild(coveDot);
    }

    const p = document.createElement('div'); p.className = 'map-player'; p.style.cssText = `left:${toP(gs.player.position.x, minX, maxX)}%;top:${toP(gs.player.position.z, minZ, maxZ)}%`; c.appendChild(p);

    // Enhanced map info with blockade/warzone warnings
    let mapInfo = 'Click island';
    if (destId) {
        mapInfo = 'Course: ' + CONFIG.islands[destId].name;
        if (isIslandBlockaded(gs, destId)) mapInfo += '  BLOCKADED';
        if (isIslandWarZone(gs, destId)) mapInfo += '  WAR ZONE';
    } else if (gs.player.destinationCoveId) {
        const destCove = CONFIG.hiddenCoves[gs.player.destinationCoveId];
        if (destCove) mapInfo = 'Course: ' + destCove.name + ' (Hidden)';
    }
    this.el['map-info'].textContent = mapInfo;
    this.el['map-modal'].classList.remove('hidden');
}

showPirate(cost, parley) { this.el['tribute-cost'].textContent = cost + 'g'; this.el['pirate-pass'].classList.toggle('hidden', !parley); this.el['pirate-modal'].classList.remove('hidden'); }
closePirate() { this.el['pirate-modal'].classList.add('hidden'); }

// === LIVING SEA: Chase UI Methods ===
showChase(escapeChance, duration) {
    this.el['chase-chance'].textContent = Math.round(escapeChance * 100) + '%';
    this.el['chase-timer'].textContent = Math.ceil(duration / 1000) + 's';
    this.el['chase-player'].style.left = '20%';
    this.el['chase-result'].classList.add('hidden');
    this.el['chase-result'].className = 'chase-result hidden';
    // Enable all action buttons
    this.el['chase-trim'].disabled = false;
    this.el['chase-jettison'].disabled = false;
    this.el['chase-risky'].disabled = false;
    this.el['chase-modal'].classList.remove('hidden');
}

updateChase(escapeChance, timeLeft, playerProgress) {
    this.el['chase-chance'].textContent = Math.round(escapeChance * 100) + '%';
    this.el['chase-timer'].textContent = Math.ceil(timeLeft / 1000) + 's';
    // Player position: 20% (start) to 5% (escaped) based on progress
    const pos = 20 - (playerProgress * 15);
    this.el['chase-player'].style.left = pos + '%';
}

showChaseResult(escaped, message) {
    this.el['chase-result'].textContent = message;
    this.el['chase-result'].className = 'chase-result ' + (escaped ? 'escaped' : 'caught');
    this.el['chase-result'].classList.remove('hidden');
    // Disable action buttons
    this.el['chase-trim'].disabled = true;
    this.el['chase-jettison'].disabled = true;
    this.el['chase-risky'].disabled = true;
}

closeChase() { this.el['chase-modal'].classList.add('hidden'); }

showTitleEarned(icon, name, desc) {
    this.el['title-icon'].textContent = icon;
    this.el['title-earned-name'].textContent = name;
    this.el['title-earned-desc'].textContent = desc;
    this.el['title-modal'].classList.remove('hidden');
}

showContractComplete(contracts) {
    if (!contracts || contracts.length === 0) return;

    const totalGold = contracts.reduce((sum, c) => sum + c.rewards.gold, 0);
    const repChanges = {};
    for (const c of contracts) {
        const faction = c.rewards.repFaction;
        repChanges[faction] = (repChanges[faction] || 0) + c.rewards.rep;
    }

    const contractNames = contracts.map(c => c.title).join(', ');
    const repText = Object.entries(repChanges)
        .map(([f, r]) => `${r > 0 ? '+' : ''}${r} ${f}`)
        .join(', ');

    this.el['contract-complete-icon'].textContent = contracts.length > 1 ? '' : '';
    this.el['contract-complete-title'].textContent = contracts.length > 1 ? `${contracts.length} Contracts Complete!` : 'Contract Complete!';
    this.el['contract-complete-desc'].textContent = contractNames;
    this.el['contract-complete-rewards'].innerHTML = `
        <div style="margin-top:10px;text-align:center">
            <div style="font-size:1.2rem;color:var(--gold-dark);font-weight:bold"> +${totalGold}g</div>
            <div style="font-size:0.9rem;color:var(--ink-light);margin-top:4px">${repText} reputation</div>
        </div>
    `;
    this.el['contract-complete-modal'].classList.remove('hidden');
}

// === LIVING SEA: Quest Complete Modal ===
showQuestComplete(rewards) {
    if (!rewards) return;

    const rewardLines = [];
    if (rewards.gold) rewardLines.push(`<div style="font-size:1.2rem;color:var(--gold-dark);font-weight:bold"> +${rewards.gold}g</div>`);
    if (rewards.reputation) {
        const repText = Object.entries(rewards.reputation)
            .map(([f, r]) => `${r > 0 ? '+' : ''}${r} ${f}`)
            .join(', ');
        rewardLines.push(`<div style="font-size:0.9rem;color:var(--ink-light);margin-top:4px">${repText} reputation</div>`);
    }
    if (rewards.title) rewardLines.push(`<div style="font-size:0.9rem;margin-top:4px"> Title earned: "${rewards.title}"</div>`);
    if (rewards.pardon) rewardLines.push(`<div style="font-size:0.9rem;color:#1e7d34;margin-top:4px"> Royal Pardon granted!</div>`);

    this.el['contract-complete-icon'].textContent = '';
    this.el['contract-complete-title'].textContent = 'Questline Complete!';
    this.el['contract-complete-desc'].textContent = 'You have completed an epic questline!';
    this.el['contract-complete-rewards'].innerHTML = `
        <div style="margin-top:10px;text-align:center">
            ${rewardLines.join('')}
        </div>
    `;
    this.el['contract-complete-modal'].classList.remove('hidden');
}

showEncounter(enc, opts, result) {
    this.el['encounter-icon'].textContent = enc.icon; this.el['encounter-title'].textContent = enc.name; this.el['encounter-desc'].textContent = enc.desc;
    if (result) {
        this.el['encounter-result'].innerHTML = `<div class="encounter-${result.positive ? 'reward' : 'penalty'}">${result.text}</div>`;
        this.el['encounter-options'].innerHTML = '<button class="btn-primary" id="enc-close">OK</button>';
        document.getElementById('enc-close').addEventListener('click', () => this.el['encounter-modal'].classList.add('hidden'));
    }
    else {
        this.el['encounter-result'].innerHTML = '';
        this.el['encounter-options'].innerHTML = opts.map((o, i) => `<button class="btn-${o.style || 'secondary'}" data-i="${i}">${o.label}</button>`).join('');
        this.el['encounter-options'].querySelectorAll('button').forEach(b => b.addEventListener('click', () => opts[b.dataset.i].action()));
    }
    this.el['encounter-modal'].classList.remove('hidden');
}
closeEncounter() { this.el['encounter-modal'].classList.add('hidden'); }
showWarning(icon, title, text) { this.el['warning-icon'].textContent = icon; this.el['warning-title'].textContent = title; this.el['warning-text'].textContent = text; this.el['warning-modal'].classList.remove('hidden'); }
toast(title, desc) { this.el['event-title'].textContent = title; this.el['event-desc'].textContent = desc; this.el['event-toast'].classList.remove('hidden'); setTimeout(() => this.el['event-toast'].classList.add('hidden'), 3000); }

}

// ==================== GAME ====================
class Game {
constructor() { this.gameState = null; this.scene = null; this.ui = null; this.joystick = null; this.selectedFaction = null; this.nearbyIsland = null; this.nearbyCove = null; this.lastDayTick = 0; this.init(); }
async init() {
    try {
        this.ui = new UI(this);
        for (let i = 0; i <= 100; i += 20) { this.ui.showLoading(i); await new Promise(r => setTimeout(r, 80)); }
        const save = localStorage.getItem('merchantSeasSave');
        setTimeout(() => {
            try {
                this.ui.hideLoading();
                if (save && confirm('Continue saved game?')) {
                    if (!this.load()) {
                        // Load failed, start fresh
                        localStorage.removeItem('merchantSeasSave');
                        this.ui.showFaction();
                    } else {
                        this.start();
                    }
                } else {
                    this.ui.showFaction();
                }
            } catch (e) {
                console.error('Init error:', e);
                this.ui.hideLoading();
                this.ui.showFaction();
            }
        }, 300);
    } catch (e) {
        console.error('Game initialization error:', e);
        document.getElementById('loading-screen')?.classList.add('hidden');
        document.getElementById('faction-screen')?.classList.remove('hidden');
    }
}

startGame(faction) {
    this.gameState = createState(faction); this.ui.hideFaction(); this.ui.showGame();
    this.scene = new SceneManager(document.getElementById('game-canvas')); this.joystick = new Joystick();
    this.ui.updateHUD(this.gameState); this.save(); this.start(); this.ui.toast('Welcome!', 'Sail to Port Royal!');
}

update(dt) {
    if (!this.gameState) return; this.checkNearby();
    if (this.gameState.isDocked) { this.ui.updateSpeed(0, null); return; }
    const gs = this.gameState;
    if (this.joystick?.magnitude > 0.1) {
        const inv = localStorage.getItem('havenvoy-invert-joystick') === 'true' ? -1 : 1;
        const md = { x: inv * this.joystick.value.x, z: inv * this.joystick.value.y }, len = Math.sqrt(md.x**2 + md.z**2); if (len) { md.x /= len; md.z /= len; }
        const we = getWindEffect(gs, md), spd = getShipSpeed(gs) * this.joystick.magnitude * 0.8 * we.mult;
        gs.player.position.x = Math.max(-250, Math.min(250, gs.player.position.x + md.x * spd));
        gs.player.position.z = Math.max(-200, Math.min(200, gs.player.position.z + md.z * spd));
        this.ui.updateSpeed(this.joystick.magnitude * we.mult, we); this.ui.updateCompass(this.joystick.angle, gs);
        this.lastDayTick += dt * 1000;
        if (this.lastDayTick > 5000) { this.advanceDay(); this.lastDayTick = 0; this.checkEncounters(); }
    } else { this.ui.updateSpeed(0, null); this.ui.updateCompass(0, gs); }
}

checkNearby() {
    const gs = this.gameState;
    const pp = gs.player.position; let closest = null, cd = Infinity;
    Object.entries(CONFIG.islands).forEach(([id, isl]) => { const d = Math.sqrt((isl.position.x - pp.x)**2 + (isl.position.z - pp.z)**2); if (d < 80 && d < cd) { cd = d; closest = { id, ...isl, dist: d, type: 'island' }; } });

    // Also check for discovered coves
    const discoveredCoves = getDiscoveredCoves(gs);
    for (const coveId of discoveredCoves) {
        const cove = CONFIG.hiddenCoves[coveId];
        if (!cove) continue;
        const d = Math.sqrt((cove.position.x - pp.x)**2 + (cove.position.z - pp.z)**2);
        if (d < 60 && d < cd) { cd = d; closest = { id: coveId, ...cove, dist: d, type: 'cove' }; }
    }

    this.nearbyIsland = closest?.type === 'island' ? closest.id : null;
    this.nearbyCove = closest?.type === 'cove' ? closest.id : null;
    this.ui.updateNearby(closest, cd);
}

advanceDay() {
    const gs = this.gameState;
    gs.player.days++;
    gs.player.daysSinceDock = (gs.player.daysSinceDock || 0) + 1;

    // Update season day counter (cycles within season)
    gs.world.seasonDay = ((gs.world.seasonDay || 1) % CONFIG.settings.seasonCycleDays) + 1;

    // Consume supplies (with upgrade modifiers)
    const supplyRate = getSupplyRate(gs);
    gs.player.supplies -= Math.floor(supplyRate);
    // Handle fractional supply cost via RNG
    if (Math.random() < (supplyRate % 1)) gs.player.supplies--;

    // === BALANCE: Daily upkeep costs ===
    const upkeep = calculateDailyUpkeep(gs);
    if (upkeep > 0) {
        gs.player.gold = Math.max(0, gs.player.gold - upkeep);
        // Track total upkeep for stats
        if (!gs.player.stats.totalUpkeep) gs.player.stats.totalUpkeep = 0;
        gs.player.stats.totalUpkeep += upkeep;
    }

    // === LIVING SEA: Ship condition wear ===
    const windStrength = gs.wind?.strength || 0;
    applyDailyWear(gs, false, windStrength);

    // Check for mutiny at low morale
    if (checkMutinyRisk(gs)) {
        // Mutiny event - lose some gold and supplies
        const goldLoss = Math.floor(gs.player.gold * 0.1);
        const supplyLoss = Math.floor(gs.player.supplies * 0.2);
        gs.player.gold = Math.max(0, gs.player.gold - goldLoss);
        gs.player.supplies = Math.max(0, gs.player.supplies - supplyLoss);
        this.ui.showWarning('', 'Mutiny!', `Crew unrest! Lost ${goldLoss}g and ${supplyLoss} supplies.`);
        restoreMorale(gs, 20); // Situation calms after confrontation
    }

    // Ship condition warnings
    if (getShipHull(gs) < CONFIG.shipCondition.criticalThreshold) {
        this.ui.showWarning('', 'Hull Critical!', 'Repair at port or risk sinking!');
    } else if (getShipRigging(gs) < CONFIG.shipCondition.criticalThreshold) {
        this.ui.showWarning('', 'Rigging Failing!', 'Speed reduced. Repair soon!');
    }

    // Check questline deadline
    if (checkQuestlineDeadline(gs)) {
        this.ui.showWarning('', 'Quest Failed!', 'You ran out of time.');
    }

    // Check for bounty hunter encounter
    const bountyLevel = getBountyLevel(gs);
    const hunterChance = CONFIG.bountyHunters.encounterChance[bountyLevel] || 0;
    if (hunterChance > 0 && Math.random() < hunterChance) {
        const hunter = spawnBountyHunter(gs);
        if (hunter) {
            this.triggerBountyHunter(hunter);
            return; // Skip normal day processing
        }
    }

    // === BALANCE: Decay systems ===
    // Heat decays slower at sea
    decayHeatBalanced(gs, false);

    // Bounty decays
    decayBounty(gs, false, false);

    // Market saturation recovers
    decayMarketSaturation(gs);

    // Meta pressure daily decay and milestone checks
    metaUpdateDaily(gs, (title, msg) => this.ui.toast(title, msg));

    simMarketDay(gs);

    // Tick world state
    tickWorldStatePerDay(gs);

    // Check contract expirations
    const expired = expireContracts(gs);
    if (expired.length > 0) {
        this.ui.toast('Contract Failed', `${expired.length} contract(s) expired!`);
    }

    // Update titles
    const oldTitles = { ...gs.player.titles };
    updateTitles(gs, (icon, name, desc) => {
        this.ui.showTitleEarned(icon, name, desc);
    });

    // Wind changes
    if (gs.wind) {
        gs.wind.daysUntilChange--;
        if (gs.wind.daysUntilChange <= 0) {
            gs.wind.direction = Math.floor(Math.random() * 8);
            gs.wind.strength = Math.floor(Math.random() * 4);
            gs.wind.daysUntilChange = CONFIG.settings.windChangeDays;
            this.ui.toast('Wind', WIND_STR[gs.wind.strength].name + ' ' + WIND_DIRS[gs.wind.direction].name);
        }
    }

    this.ui.updateHUD(gs);
    if (gs.player.supplies <= 5 && gs.player.supplies > 0) this.ui.showWarning('', 'Low Supplies!', 'Dock soon!');
    else if (gs.player.supplies <= 0) { gs.player.supplies = 0; this.ui.showWarning('', 'Stranded!', 'Find port fast!'); }
}

checkEncounters() {
    const gs = this.gameState, fc = CONFIG.factions[gs.player.faction];
    const risk = getRouteRisk(gs);
    const cargoVal = estimateCargoValue(gs);
    const mods = getTitleModifiers(gs);
    const seasonMods = getSeasonModifiers(gs);

    // === META PRESSURE: Calculate route-based modifiers ===
    const meta = metaInit(gs);
    const currentRouteKey = meta.lastPort && this.nearbyIsland
        ? [meta.lastPort, this.nearbyIsland].sort().join('>')
        : null;
    const metaMods = metaGetModifiers(gs, {
        route: currentRouteKey,
        port: this.nearbyIsland,
        faction: this.nearbyIsland ? CONFIG.islands[this.nearbyIsland]?.faction : null
    });

    // === LIVING SEA: Check for blockade encounters when near blockaded islands ===
    const nearestBlockaded = this.getNearbyBlockadedIsland(gs);
    if (nearestBlockaded && Math.random() < 0.15) {
        this.triggerBlockadeEncounter(nearestBlockaded);
        return;
    }

    // === LIVING SEA: Check for drift entity encounters first ===
    const nearbyEntities = getNearbyDriftEntities(gs, 60);
    for (const entity of nearbyEntities) {
        if (entity.distance < (entity.config.dangerRadius || entity.config.inspectRadius || entity.config.interactRadius || 30)) {
            // Mark entity as encountered to prevent repeated triggers
            if (entity.lastEncounterDay === gs.player.days) continue;
            entity.lastEncounterDay = gs.player.days;

            switch (entity.typeId) {
                case 'pirateFleet':
                    // Skip if player has convoy protection
                    if (gs.player.convoyProtection && gs.player.convoyProtection >= gs.player.days) continue;
                    this.triggerPirateFleetEncounter(entity);
                    return;
                case 'navyConvoy':
                    this.triggerConvoyEncounter(entity);
                    return;
                case 'floatingMarket':
                    this.triggerDriftingMarket(entity);
                    return;
                case 'stormFront':
                    // Storm front triggers storm encounter with chance for Storm's Eye
                    if (Math.random() < 0.25) {
                        this.triggerStormsEye();
                    } else {
                        this.triggerStorm();
                    }
                    return;
                case 'merchantFleet':
                    this.triggerMerchantFleet(entity);
                    return;
            }
        }
    }

    // Pirate encounters scale with cargo value, faction, and season
    const pirateBase = CONFIG.settings.pirateEncounterChance * (fc.pirateChanceMult || 1) * (seasonMods.piratesMult || 1);
    let pirateChance = pirateBase * (1 + risk * 0.5); // +50% at max risk
    // === META PRESSURE: Route bias increases pirate chance (they've learned your patterns) ===
    pirateChance *= metaMods.pirateChanceMult;
    // Convoy protection reduces pirate encounters
    if (gs.player.convoyProtection && gs.player.convoyProtection >= gs.player.days) pirateChance *= 0.1;
    if (Math.random() < pirateChance) { this.triggerPirate(); return; }

    // Inspection encounter - scales with heat, crackdown, bounty, port state, and proximity to English/EITC waters
    const bountyLevel = getBountyLevel(gs);
    // Bounty level increases base chance of being inspected
    const bountyInspectMult = { clean: 1.0, wanted: 1.5, hunted: 2.5, infamous: 4.0 }[bountyLevel] || 1.0;
    if (isNearHostileWaters(gs) || gs.player.heat > 30 || bountyLevel !== 'clean') {
        let inspectChance = CONFIG.encounters.inspection.baseChance * (1 + gs.player.heat / 100);
        // === BALANCE: Bounty increases inspection chance significantly ===
        inspectChance *= bountyInspectMult;
        // Crackdown increases inspection chance
        inspectChance *= (1 + getCrackdownLevel(gs) / 100);
        // Seasonal event effects
        if (gs.world?.seasonalEvent?.effects?.inspectMult) {
            inspectChance *= gs.world.seasonalEvent.effects.inspectMult;
        }
        // Port state inspection multiplier (from nearest island)
        if (this.nearbyIsland) {
            const portState = getPortStateConfig(gs, this.nearbyIsland);
            inspectChance *= (portState.inspectMult ?? 1);
        }
        // Smuggler compartments reduce chance (less effective at higher bounty)
        if (gs.player.upgrades?.smugglerCompartments) {
            const compartmentReduction = CONFIG.upgrades.smugglerCompartments.effects.inspectionReduction;
            // Effectiveness reduces with bounty level
            const bountyPenalty = { clean: 0, wanted: 0.25, hunted: 0.5, infamous: 0.75 }[bountyLevel] || 0;
            inspectChance *= (1 - compartmentReduction * (1 - bountyPenalty));
        }
        // Title modifiers
        inspectChance *= (1 - mods.inspectionReduction);
        // === META PRESSURE: Port/faction bias increases inspection chance (they're watching you) ===
        inspectChance *= metaMods.inspectionChanceMult;
        if (Math.random() < inspectChance) { this.triggerInspection(); return; }
    }

    // Storm - scales with season, days at sea
    let stormChance = CONFIG.encounters.storm.baseChance * (1 + gs.player.daysSinceDock / 30) * (seasonMods.stormMult || 1);
    // Seasonal event storm multiplier
    if (gs.world?.seasonalEvent?.effects?.stormMult) {
        stormChance *= gs.world.seasonalEvent.effects.stormMult;
    }
    // === META PRESSURE: Route bias increases storm chance (the sea conspires against predictability) ===
    stormChance *= metaMods.stormChanceMult;
    if (Math.random() < stormChance) {
        // During heavy storms, chance for Storm's Eye encounter
        if (seasonMods.stormMult >= 2 && Math.random() < 0.2) {
            this.triggerStormsEye();
        } else {
            this.triggerStorm();
        }
        return;
    }

    // === LIVING SEA ENCOUNTERS ===

    // Desperate Merchant - more common in harsh seasons
    const desperateChance = CONFIG.encounters.desperateMerchant.baseChance * (seasonMods.stormMult || 1);
    if (Math.random() < desperateChance) { this.triggerDesperateMerchant(); return; }

    // Blockade Runner - near blockaded ports
    for (const iid of Object.keys(CONFIG.islands)) {
        const portState = getPortState(gs, iid);
        if (portState === 'blockaded') {
            const isl = CONFIG.islands[iid];
            const dist = Math.sqrt((isl.position.x - gs.player.position.x)**2 + (isl.position.z - gs.player.position.z)**2);
            if (dist < 100 && Math.random() < CONFIG.encounters.blockadeRunner.baseChance * 2) {
                this.triggerBlockadeRunner();
                return;
            }
        }
    }

    // Merchant/wreck - slightly more common when risk is low (reward safe play)
    const safeBonus = 1 + (1 - risk) * 0.3;
    if (Math.random() < CONFIG.encounters.adriftMerchant.baseChance * safeBonus) { this.triggerMerchant(); return; }
    if (Math.random() < CONFIG.encounters.wreckSalvage.baseChance * safeBonus) { this.triggerWreck(); return; }
}

triggerPirate() {
    const gs = this.gameState;
    // === LIVING SEA: Start chase sequence before pirate confrontation ===
    // Pirates with parley skip the chase
    if (gs.player.faction === 'pirates') {
        this._showPirateEncounter();
        return;
    }
    this.startChase('pirate');
}

// === LIVING SEA: Bounty Hunter Encounters ===
_pendingHunter = null;

triggerBountyHunter(hunter) {
    // Store the hunter for use after chase resolves
    this._pendingHunter = hunter;
    // Start chase with bounty hunter - they're faster than regular pirates
    this.startChase('bounty_hunter');
}

// === LIVING SEA: Chase System ===
_chaseState = null;
_chaseInterval = null;

startChase(type = 'pirate') {
    const gs = this.gameState;
    const escapeChance = calculateEscapeChance(gs);
    const duration = getChaseDuration(gs);

    this._chaseState = {
        type,
        startTime: Date.now(),
        duration,
        escapeChance,
        progress: 0,
        actionsUsed: { trim: false, jettison: false, risky: false },
        cargoJettisoned: 0
    };

    this.ui.showChase(escapeChance, duration);

    // Start chase timer
    this._chaseInterval = setInterval(() => this._updateChase(), 100);
}

_updateChase() {
    if (!this._chaseState) return;

    const elapsed = Date.now() - this._chaseState.startTime;
    const remaining = Math.max(0, this._chaseState.duration - elapsed);
    const progress = Math.min(1, elapsed / this._chaseState.duration);

    this._chaseState.progress = progress;
    this.ui.updateChase(this._chaseState.escapeChance, remaining, progress);

    // Chase resolution
    if (remaining <= 0) {
        this._resolveChase();
    }
}

chaseAction(action) {
    if (!this._chaseState || this._chaseState.actionsUsed[action]) return;

    const gs = this.gameState;
    this._chaseState.actionsUsed[action] = true;

    if (action === 'trim') {
        // Trim sails: +10% escape chance, slight rigging wear
        this._chaseState.escapeChance = Math.min(0.95, this._chaseState.escapeChance + 0.10);
        damageRigging(gs, 5);
        this.ui.toast('Trim Sails', '+10% escape, rigging strain');
    } else if (action === 'jettison') {
        // Jettison cargo: +15% escape chance, lose 20% cargo
        const cargoLost = this.loseCargo(calcCargoLoss(gs, 0.2));
        this._chaseState.cargoJettisoned += cargoLost;
        this._chaseState.escapeChance = Math.min(0.95, this._chaseState.escapeChance + 0.15);
        this.ui.toast('Jettison!', `+15% escape, lost ${cargoLost} cargo`);
    } else if (action === 'risky') {
        // Risky maneuver: 50% chance +25% escape, 50% chance -20% and hull damage
        if (Math.random() < 0.5) {
            this._chaseState.escapeChance = Math.min(0.95, this._chaseState.escapeChance + 0.25);
            this.ui.toast('Daring Move!', '+25% escape chance!');
        } else {
            this._chaseState.escapeChance = Math.max(0.1, this._chaseState.escapeChance - 0.20);
            damageHull(gs, 15);
            this.ui.toast('Risky Failed!', '-20% escape, hull damage');
        }
    }

    // Disable used action button
    this.ui.el['chase-' + action].disabled = true;
    this.ui.updateChase(this._chaseState.escapeChance, this._chaseState.duration - (Date.now() - this._chaseState.startTime), this._chaseState.progress);
    this.ui.updateHUD(gs);
}

_resolveChase() {
    clearInterval(this._chaseInterval);
    this._chaseInterval = null;

    const gs = this.gameState;
    const escaped = Math.random() < this._chaseState.escapeChance;
    const type = this._chaseState.type;

    if (escaped) {
        // Successfully escaped!
        const escapeMsg = type === 'bounty_hunter'
            ? 'You escaped! The bounty hunter loses your trail.'
            : 'You escaped! The pirates fall behind.';
        this.ui.showChaseResult(true, escapeMsg);
        // Small morale boost for exciting escape
        restoreMorale(gs, 5);

        // Escaping bounty hunter doesn't defeat them - they'll be back
        if (type === 'bounty_hunter' && this._pendingHunter) {
            // Small bounty increase for evading justice
            gs.player.bounty = (gs.player.bounty || 0) + 10;
        }

        // === LIVING SEA: Check questline for survive_chase step ===
        const questResult = checkQuestlineStep(gs, 'escape_chase', { type });
        if (questResult.advanced) {
            if (questResult.completed) {
                setTimeout(() => this.ui.showQuestComplete(questResult.rewards), 2100);
            } else {
                setTimeout(() => this.ui.toast('Quest Progress', 'Survived the chase!'), 2100);
            }
        }

        setTimeout(() => {
            this.ui.closeChase();
            this.ui.toast('Escaped!', type === 'bounty_hunter' ? 'Lost the hunter' : 'Lost the pirates');
            this._pendingHunter = null; // Clear pending hunter
        }, 2000);
    } else {
        // Caught! Show appropriate encounter
        const caughtMsg = type === 'bounty_hunter'
            ? 'Caught! The bounty hunter boards your ship.'
            : 'Caught! The pirates board your ship.';
        this.ui.showChaseResult(false, caughtMsg);
        setTimeout(() => {
            this.ui.closeChase();
            if (type === 'pirate') {
                this._showPirateEncounter();
            } else if (type === 'bounty_hunter') {
                this._showBountyHunterEncounter();
            }
        }, 2000);
    }

    this._chaseState = null;
    this.ui.updateHUD(gs);
    this.save();
}

_showPirateEncounter() {
    const gs = this.gameState;
    // Power-scaled tribute calculation
    const enc = CONFIG.balance.encounters;
    const power = getPlayerPower(gs);
    const bounty = getBounty(gs);

    // Base tribute scales with gold AND power
    let tributeRate = enc.pirateStrengthBase + (power * enc.pirateStrengthPower);
    // Bounty makes pirates demand more (they know you're valuable)
    tributeRate *= (1 + bounty * CONFIG.balance.bounty.tributeBountyMult);

    const baseCost = Math.max(enc.pirateMinTribute, Math.floor(gs.player.gold * tributeRate) + enc.pirateMinTribute);
    const cost = calcTributeCost(gs, baseCost);
    this.ui.showPirate(cost, gs.player.faction === 'pirates');
}

_showBountyHunterEncounter() {
    const gs = this.gameState;
    // Use pending hunter from triggerBountyHunter, or spawn new one
    const hunter = this._pendingHunter || spawnBountyHunter(gs);
    this._pendingHunter = null; // Clear for next time

    if (!hunter) {
        this.ui.toast('Close Call', 'The hunter lost your trail');
        return;
    }

    // Calculate bribe cost based on hunter strength and player bounty
    const bounty = getBounty(gs);
    const bribeCost = Math.floor(100 + (bounty * 0.5) + (hunter.strength * 100));

    // Show encounter modal with hunter options
    this.ui.showEncounter({
        icon: hunter.icon,
        title: `${hunter.name} Approaches!`,
        desc: `A notorious bounty hunter has caught up with you. They demand you surrender or pay for your freedom!`
    }, [
        { label: ` Pay Bribe (${bribeCost}g)`, style: 'secondary', action: () => this._bribeBountyHunter(hunter, bribeCost) },
        { label: ' Fight', style: 'danger', action: () => this._fightBountyHunter(hunter) }
    ]);
}

_bribeBountyHunter(hunter, bribeCost) {
    const gs = this.gameState;
    if (gs.player.gold >= bribeCost) {
        gs.player.gold -= bribeCost;
        this.ui.closeEncounter();
        this.ui.toast('Bribed', `${hunter.name} looks the other way`);
    } else {
        this.ui.toast('No Gold', 'Cannot afford the bribe!');
        this._fightBountyHunter(hunter);
    }
    this.ui.updateHUD(gs);
    this.save();
}

_fightBountyHunter(hunter) {
    const gs = this.gameState;
    this.ui.closeEncounter();

    // Fight mechanics - win chance decreases with hunter strength
    // strength: 1.2 (Blackwood) = 35%, 1.5 (Iron Maiden) = 25%, 2.0 (Graves) = 10%
    const winChance = Math.max(0.1, 0.5 - (hunter.strength * 0.2));

    if (Math.random() < winChance) {
        // Victory!
        defeatHunter(gs, hunter.index);
        const reward = hunter.reward || 200;
        gs.player.gold += reward;
        // Defeating hunter reduces bounty slightly
        gs.player.bounty = Math.max(0, (gs.player.bounty || 0) - 50);
        this.ui.toast('Victory!', `Defeated ${hunter.name}! +${reward}g`);
    } else {
        // Lost fight - hunter takes their bounty
        const loss = Math.floor(gs.player.gold * 0.4);
        gs.player.gold = Math.max(0, gs.player.gold - loss);
        this.loseCargo(calcCargoLoss(gs, 0.3));
        damageHull(gs, 25);
        // Increase bounty from escaping (but alive)
        gs.player.bounty = (gs.player.bounty || 0) + 30;
        this.ui.toast('Defeated', `${hunter.name} claims their prize!`);
    }
    this.ui.updateHUD(gs);
    this.save();
}

payTribute() {
    const gs = this.gameState;
    const enc = CONFIG.balance.encounters;
    const power = getPlayerPower(gs);
    const bounty = getBounty(gs);

    let tributeRate = enc.pirateStrengthBase + (power * enc.pirateStrengthPower);
    tributeRate *= (1 + bounty * CONFIG.balance.bounty.tributeBountyMult);

    const baseCost = Math.max(enc.pirateMinTribute, Math.floor(gs.player.gold * tributeRate) + enc.pirateMinTribute);
    const cost = calcTributeCost(gs, baseCost);

    if (gs.player.gold >= cost) {
        gs.player.gold -= cost;
        this.ui.closePirate();
        this.ui.toast('Paid', '-' + cost + 'g');
    } else {
        this.loseCargo(calcCargoLoss(gs, 0.3));
        this.ui.closePirate();
        this.ui.toast('Plundered!', 'Lost cargo');
    }
    this.ui.updateHUD(gs);
}

fight() {
    const gs = this.gameState;
    this.ui.closePirate();

    // Power-scaled fight mechanics
    const enc = CONFIG.balance.encounters;
    const power = getPlayerPower(gs);
    const phase = getGamePhase(gs);

    // Win chance decreases with power (pirates get tougher)
    let winChance = enc.pirateFightWinBase;
    if (phase === 'mid') winChance -= enc.pirateFightWinPenalty;
    else if (phase === 'late') winChance -= enc.pirateFightWinPenalty * 2;
    else if (phase === 'endgame') winChance -= enc.pirateFightWinPenalty * 3;
    winChance = Math.max(0.2, winChance); // Never below 20%

    if (Math.random() < winChance) {
        // Loot scales slightly with power (tougher pirates = better loot)
        const r = Math.floor(enc.pirateLootBase + (power * enc.pirateLootPowerMult) + Math.random() * 100);
        gs.player.gold += r;
        // Pirate reputation boost
        applyRepChange(gs, 'pirates', 5, 'fight_win');
        this.ui.toast('Victory!', '+' + r + 'g');
    } else {
        // Loss is more punishing at higher power
        let cargoLossFrac = 0.5;
        let goldLossFrac = 0.1;
        if (phase === 'late' || phase === 'endgame') {
            cargoLossFrac = 0.6;
            goldLossFrac = 0.15;
        }
        this.loseCargo(calcCargoLoss(gs, cargoLossFrac));
        const goldLoss = calcGoldLoss(gs, Math.floor(gs.player.gold * goldLossFrac));
        gs.player.gold = Math.max(0, gs.player.gold - goldLoss);
        this.ui.toast('Defeated', 'Lost cargo & gold');
    }
    this.ui.updateHUD(gs);
}

loseCargo(frac) {
    const gs = this.gameState;
    Object.keys(gs.player.cargo).forEach(gid => {
        gs.player.cargo[gid] -= Math.ceil(gs.player.cargo[gid] * frac);
        if (gs.player.cargo[gid] <= 0) delete gs.player.cargo[gid];
    });
}

// INSPECTION ENCOUNTER
triggerInspection() {
    const gs = this.gameState, enc = CONFIG.encounters.inspection;
    const contrabandQty = getContrabandCount(gs);
    const hasContraband = contrabandQty > 0;
    const bb = CONFIG.balance.bounty;

    // Mark inspection for active courier contracts with noInspection requirement (per-contract tracking)
    for (const contract of gs.player.contracts.active) {
        if (contract.requirement?.noInspection) {
            contract.wasInspected = true;
        }
    }

    // Crackdown increases
    gs.world.crackdown.level = Math.min(CONFIG.settings.crackdownMaxLevel, (gs.world.crackdown.level || 0) + 5);

    // If no contraband, just a warning
    if (!hasContraband) {
        this.ui.showEncounter(enc, [], { positive: true, text: 'Cargo is clean. You are free to go!' });
        return;
    }

    // Has contraband - calculate penalty (scales with player power)
    const power = getPlayerPower(gs);
    let fine = 50 + contrabandQty * 15 + Math.floor(power * 0.05);

    // Smuggler compartments can hide some (reduced from 40% to 25% with power scaling)
    const hideChance = gs.player.upgrades?.smugglerCompartments
        ? Math.max(0.15, 0.25 - (power * 0.00005))
        : 0;
    if (hideChance > 0 && Math.random() < hideChance) {
        this.ui.showEncounter(enc, [], { positive: true, text: 'Hidden compartments concealed your cargo. You pass inspection!' });
        return;
    }

    const bountyLevel = getBountyLevel(gs);
    const bountyWarning = bountyLevel !== 'clean' ? ` (Bounty: ${getBounty(gs)}g)` : '';

    this.ui.showEncounter(enc, [
        {
            label: ` Pay Fine (${fine}g)`, style: 'danger',
            action: () => {
                if (gs.player.gold >= fine) {
                    gs.player.gold -= fine;
                    addHeat(gs, 15);
                    // Add bounty for smuggling
                    addBounty(gs, bb.contrabandBounty * contrabandQty);
                    this.ui.showEncounter(enc, [], { positive: false, text: `Paid ${fine}g fine. Contraband confiscated! Bounty increased.` });
                } else {
                    // Can't pay - lose all contraband and reputation hit
                    this.confiscateContraband(gs);
                    applyRepChange(gs, 'english', -15, 'inspection_caught');
                    applyRepChange(gs, 'eitc', -15, 'inspection_caught');
                    addHeat(gs, 25);
                    addBounty(gs, bb.baseGainPerCrime + bb.contrabandBounty * contrabandQty);
                    this.ui.showEncounter(enc, [], { positive: false, text: 'No gold! All contraband seized. Reputation damaged. Major bounty added!' });
                }
                // Confiscate contraband regardless
                this.confiscateContraband(gs);
                // Increase crackdown
                gs.world.crackdown.level = Math.min(CONFIG.settings.crackdownMaxLevel, (gs.world.crackdown.level || 0) + 10);
                this.ui.updateHUD(gs);
            }
        },
        {
            label: ' Flee!',
            action: () => {
                // Flee chance decreases with bounty level
                let fleeChance = 0.4;
                if (bountyLevel === 'wanted') fleeChance = 0.3;
                else if (bountyLevel === 'hunted') fleeChance = 0.2;
                else if (bountyLevel === 'infamous') fleeChance = 0.1;

                if (Math.random() < fleeChance) {
                    // Escaped
                    addHeat(gs, 20);
                    addBounty(gs, bb.fleeingBounty);
                    this.ui.showEncounter(enc, [], { positive: true, text: 'You escaped the patrol! Heat and bounty increased.' });
                } else {
                    // Caught - worse penalty
                    this.confiscateContraband(gs);
                    const penalty = Math.floor(gs.player.gold * 0.2);
                    gs.player.gold = Math.max(0, gs.player.gold - penalty);
                    applyRepChange(gs, 'english', -20, 'inspection_fled');
                    applyRepChange(gs, 'eitc', -20, 'inspection_fled');
                    addHeat(gs, 30);
                    addBounty(gs, bb.baseGainPerCrime + bb.fleeingBounty + bb.contrabandBounty * contrabandQty);
                    gs.world.crackdown.level = Math.min(CONFIG.settings.crackdownMaxLevel, (gs.world.crackdown.level || 0) + 20);
                    this.ui.showEncounter(enc, [], { positive: false, text: `Caught fleeing! Lost ${penalty}g and all contraband. Major bounty placed on your head!` });
                }
                this.ui.updateHUD(gs);
            }
        }
    ]);
}

confiscateContraband(gs) {
    Object.keys(gs.player.cargo).forEach(gid => {
        if (CONFIG.goods[gid]?.category === 'contraband') {
            delete gs.player.cargo[gid];
        }
    });
}

triggerStorm() {
    const gs = this.gameState, enc = CONFIG.encounters.storm;
    this.ui.showEncounter(enc, [
        { label: ' Ride out', action: () => {
            const l = 2 + Math.floor(Math.random() * 3);
            gs.player.supplies = Math.max(0, gs.player.supplies - l);
            if (Math.random() < 0.3) {
                this.loseCargo(calcCargoLoss(gs, 0.15));
                this.ui.showEncounter(enc, [], { positive: false, text: `Lost ${l} supplies + cargo!` });
            } else
                this.ui.showEncounter(enc, [], { positive: false, text: `Lost ${l} supplies` });
            this.ui.updateHUD(gs);
        } },
        { label: ' Wait (safe)', style: 'primary', action: () => {
            gs.player.supplies--; gs.player.days++;
            this.ui.showEncounter(enc, [], { positive: true, text: 'Waited safely. Lost 1 day.' });
            this.ui.updateHUD(gs);
        } }
    ]);
}

triggerMerchant() {
    const gs = this.gameState, enc = CONFIG.encounters.adriftMerchant;
    const gids = Object.keys(CONFIG.goods), gid = gids[Math.floor(Math.random() * gids.length)], g = CONFIG.goods[gid];
    const qty = 3 + Math.floor(Math.random() * 5);

    // === BALANCE: Discount scales down with player power ===
    const balEnc = CONFIG.balance.encounters;
    const discountMult = getPowerScaling(gs, balEnc.merchantDiscountMax, -0.0001, balEnc.merchantDiscountMin, balEnc.merchantDiscountMax);
    const price = Math.floor(g.basePrice * (1 - discountMult)), total = price * qty;

    this.ui.showEncounter({ ...enc, desc: `Offers ${qty}x ${g.name} for ${price}g each (${total}g)` }, [
        { label: ` Buy (${total}g)`, style: 'primary', action: () => {
            const check = canCarryMore(gid, qty, gs);
            if (gs.player.gold >= total && check.canCarry) {
                gs.player.gold -= total;
                gs.player.cargo[gid] = (gs.player.cargo[gid] || 0) + qty;
                gs.player.purchaseHistory[gid] = price;
                if (g.category === 'contraband') addHeat(gs, CONFIG.settings.heatGainContraband);
                this.ui.showEncounter(enc, [], { positive: true, text: `Bought ${qty}x ${g.name}!` });
            } else
                this.ui.showEncounter(enc, [], { positive: false, text: check.reason || 'Not enough gold!' });
            this.ui.updateHUD(gs);
        } },
        { label: ' Pass', action: () => this.ui.closeEncounter() }
    ]);
}

triggerWreck() {
    const gs = this.gameState, enc = CONFIG.encounters.wreckSalvage;
    // === BALANCE: Positive outcome chance decreases with power ===
    const positiveChance = getPowerScaling(gs, CONFIG.balance.encounters.wreckPositiveChance, -0.0001, 0.5, 0.9);

    this.ui.showEncounter(enc, [
        { label: ' Investigate', style: 'primary', action: () => {
            const r = Math.random();
            if (r < positiveChance) {
                // Positive outcomes
                const outcomeRoll = Math.random();
                if (outcomeRoll < 0.15) {
                    // Chart fragment - rare find!
                    const result = addChartFragment(gs);
                    if (result.discovered) {
                        const cove = CONFIG.hiddenCoves[result.coveId];
                        this.ui.showEncounter(enc, [], { positive: true, text: `Found a chart fragment! You've discovered ${cove.name}!` });
                    } else {
                        this.ui.showEncounter(enc, [], { positive: true, text: `Found a chart fragment! (${gs.player.chartFragments}/3 to reveal a cove)` });
                    }
                    this.ui.updateChartFragments(gs);
                } else if (outcomeRoll < 0.45) {
                    const s = 3 + Math.floor(Math.random() * 5);
                    gs.player.supplies = Math.min(30, gs.player.supplies + s);
                    this.ui.showEncounter(enc, [], { positive: true, text: `Found ${s} supplies!` });
                } else if (outcomeRoll < 0.8) {
                    // Gold scales with power but not excessively
                    const baseGold = 20 + Math.floor(Math.random() * 50);
                    const g = Math.floor(baseGold * (1 + getPlayerPower(gs) * 0.0002));
                    gs.player.gold += g;
                    this.ui.showEncounter(enc, [], { positive: true, text: `Found ${g} gold!` });
                } else {
                    const gids = Object.keys(CONFIG.goods), gid = gids[Math.floor(Math.random() * gids.length)], good = CONFIG.goods[gid], q = 1 + Math.floor(Math.random() * 3);
                    const check = canCarryMore(gid, q, gs);
                    if (check.canCarry) {
                        gs.player.cargo[gid] = (gs.player.cargo[gid] || 0) + q;
                        if (good.category === 'contraband') addHeat(gs, CONFIG.settings.heatGainContraband / 2);
                        this.ui.showEncounter(enc, [], { positive: true, text: `Salvaged ${q}x ${good.name}!` });
                    } else
                        this.ui.showEncounter(enc, [], { positive: false, text: check.reason || 'No room!' });
                }
            } else {
                // Negative outcomes scale with power
                const negRoll = Math.random();
                if (negRoll < 0.5) {
                    this.ui.showEncounter(enc, [], { positive: false, text: 'Nothing useful...' });
                } else if (negRoll < 0.8) {
                    // Lost supplies while searching
                    const lost = 1 + Math.floor(Math.random() * 2);
                    gs.player.supplies = Math.max(0, gs.player.supplies - lost);
                    this.ui.showEncounter(enc, [], { positive: false, text: `Wasted time searching. Lost ${lost} supplies.` });
                } else {
                    // Minor damage - gold loss
                    const damage = 10 + Math.floor(Math.random() * 20);
                    gs.player.gold = Math.max(0, gs.player.gold - damage);
                    this.ui.showEncounter(enc, [], { positive: false, text: `Sharp debris! ${damage}g repair cost.` });
                }
            }
            this.ui.updateHUD(gs);
        } },
        { label: ' Sail on', action: () => this.ui.closeEncounter() }
    ]);
}

// ==================== LIVING SEA ENCOUNTERS ====================

triggerDesperateMerchant() {
    const gs = this.gameState, enc = CONFIG.encounters.desperateMerchant;
    const gids = Object.keys(CONFIG.goods).filter(g => CONFIG.goods[g].category !== 'contraband');
    const gid = gids[Math.floor(Math.random() * gids.length)];
    const good = CONFIG.goods[gid];
    const qty = 5 + Math.floor(Math.random() * 10);
    // === BALANCE: Desperate discount scales down with power ===
    const despDiscount = getPowerScaling(gs, 0.5, -0.0001, 0.3, 0.5);
    const price = Math.floor(good.basePrice * (1 - despDiscount));

    this.ui.showEncounter({ ...enc, desc: `${enc.desc} They offer ${qty}x ${good.name} for ${price}g each.` }, [
        { label: ` Take cargo (${price * qty}g)`, style: 'danger', action: () => {
            const check = canCarryMore(gid, qty, gs);
            if (gs.player.gold >= price * qty && check.canCarry) {
                gs.player.gold -= price * qty;
                gs.player.cargo[gid] = (gs.player.cargo[gid] || 0) + qty;
                gs.player.purchaseHistory[gid] = price;
                // Massive profit, but reputation hit
                applyRepChange(gs, 'english', -8, 'abandoned_merchant');
                applyRepChange(gs, 'eitc', -5, 'abandoned_merchant');
                this.ui.showEncounter(enc, [], { positive: false, text: `Took ${qty}x ${good.name}. Their fate is on your hands. (-8 Navy rep, -5 Company rep)` });
            } else {
                this.ui.showEncounter(enc, [], { positive: false, text: check.reason || 'Not enough gold!' });
            }
            this.ui.updateHUD(gs);
        } },
        { label: ' Share supplies', action: () => {
            if (gs.player.supplies >= 5) {
                gs.player.supplies -= 5;
                applyRepChange(gs, 'english', 10, 'helped_merchant');
                applyRepChange(gs, 'eitc', 8, 'helped_merchant');
                // They remember you
                gs.player.merchantFavor = (gs.player.merchantFavor || 0) + 1;
                this.ui.showEncounter(enc, [], { positive: true, text: 'Shared 5 supplies. They\'ll remember your kindness. (+10 Navy rep, +8 Company rep)' });
            } else {
                this.ui.showEncounter(enc, [], { positive: false, text: 'Not enough supplies to share!' });
            }
            this.ui.updateHUD(gs);
        } },
        { label: ' Trade fairly', action: () => {
            const fairPrice = Math.floor(good.basePrice * 0.8);
            const check = canCarryMore(gid, qty, gs);
            if (gs.player.gold >= fairPrice * qty && check.canCarry) {
                gs.player.gold -= fairPrice * qty;
                gs.player.cargo[gid] = (gs.player.cargo[gid] || 0) + qty;
                gs.player.purchaseHistory[gid] = fairPrice;
                this.ui.showEncounter(enc, [], { positive: true, text: `Fair trade: ${qty}x ${good.name} for ${fairPrice * qty}g. Honor intact.` });
            } else {
                this.ui.showEncounter(enc, [], { positive: false, text: check.reason || 'Not enough gold!' });
            }
            this.ui.updateHUD(gs);
        } },
        { label: ' Sail on', action: () => this.ui.closeEncounter() }
    ]);
}

triggerDriftingMarket(entity) {
    const gs = this.gameState, enc = CONFIG.encounters.driftingMarket;
    // Generate special market goods
    const marketGoods = [];
    const gids = Object.keys(CONFIG.goods);
    for (let i = 0; i < 3; i++) {
        const gid = gids[Math.floor(Math.random() * gids.length)];
        const good = CONFIG.goods[gid];
        marketGoods.push({
            gid,
            good,
            price: Math.floor(good.basePrice * (0.6 + Math.random() * 0.3)), // 60-90% of base
            qty: 3 + Math.floor(Math.random() * 8)
        });
    }

    this.ui.showEncounter(enc, [
        { label: ` Buy ${marketGoods[0].good.icon} ${marketGoods[0].good.name} (${marketGoods[0].price}g x${marketGoods[0].qty})`, style: 'primary', action: () => {
            const mg = marketGoods[0];
            const check = canCarryMore(mg.gid, mg.qty, gs);
            const total = mg.price * mg.qty;
            if (gs.player.gold >= total && check.canCarry) {
                gs.player.gold -= total;
                gs.player.cargo[mg.gid] = (gs.player.cargo[mg.gid] || 0) + mg.qty;
                gs.player.purchaseHistory[mg.gid] = mg.price;
                if (mg.good.category === 'contraband') addHeat(gs, CONFIG.settings.heatGainContraband);
                this.ui.showEncounter(enc, [], { positive: true, text: `Bought ${mg.qty}x ${mg.good.name}! No tariffs, no questions.` });
            } else {
                this.ui.showEncounter(enc, [], { positive: false, text: check.reason || 'Not enough gold!' });
            }
            this.ui.updateHUD(gs);
        } },
        { label: ' Ask for rumors', action: () => {
            // Get one verified piece of intel (same island for name and port state)
            const islands = Object.keys(CONFIG.islands);
            const randomIslandId = islands[Math.floor(Math.random() * islands.length)];
            const randomIsland = CONFIG.islands[randomIslandId];
            const portState = getPortState(gs, randomIslandId);
            const stateInfo = CONFIG.portStates[portState];
            this.ui.showEncounter(enc, [], { positive: true, text: `The merchants whisper: "${randomIsland.name} is ${stateInfo.name.toLowerCase()}. ${stateInfo.desc}"` });
        } },
        { label: ' Sail on', action: () => {
            this.ui.closeEncounter();
            // Market moves away faster
            if (entity) entity.daysRemaining = Math.max(1, entity.daysRemaining - 3);
        } }
    ]);
}

triggerMerchantFleet(entity) {
    const gs = this.gameState;
    const enc = { name: 'Merchant Fleet', icon: '', desc: 'A convoy of trading vessels crosses your path. They seem open to business.' };

    // Generate trade offers - bulk goods at decent prices
    const gids = Object.keys(CONFIG.goods).filter(g => CONFIG.goods[g].category !== 'contraband');
    const buyGid = gids[Math.floor(Math.random() * gids.length)];
    const buyGood = CONFIG.goods[buyGid];
    const buyPrice = Math.floor(buyGood.basePrice * (0.75 + Math.random() * 0.15)); // 75-90% base
    const buyQty = 5 + Math.floor(Math.random() * 6);

    // What they want to buy from player
    const playerCargo = Object.entries(gs.player.cargo).filter(([gid, qty]) => qty > 0 && CONFIG.goods[gid]?.category !== 'contraband');
    const hasCargo = playerCargo.length > 0;
    let sellGid, sellGood, sellPrice, sellQty;
    if (hasCargo) {
        [sellGid, sellQty] = playerCargo[Math.floor(Math.random() * playerCargo.length)];
        sellGood = CONFIG.goods[sellGid];
        sellPrice = Math.floor(sellGood.basePrice * (1.1 + Math.random() * 0.2)); // 110-130% base
        sellQty = Math.min(sellQty, 5);
    }

    const actions = [
        { label: ` Buy ${buyGood.icon} ${buyGood.name} (${buyPrice}g x${buyQty})`, style: 'primary', action: () => {
            const total = buyPrice * buyQty;
            const check = canCarryMore(buyGid, buyQty, gs);
            if (gs.player.gold >= total && check.canCarry) {
                gs.player.gold -= total;
                gs.player.cargo[buyGid] = (gs.player.cargo[buyGid] || 0) + buyQty;
                gs.player.purchaseHistory[buyGid] = buyPrice;
                gs.player.merchantFavor = (gs.player.merchantFavor || 0) + 1;
                this.ui.showEncounter(enc, [], { positive: true, text: `Bought ${buyQty}x ${buyGood.name}. The merchants appreciate your business.` });
            } else {
                this.ui.showEncounter(enc, [], { positive: false, text: check.reason || 'Not enough gold!' });
            }
            this.ui.updateHUD(gs);
        } }
    ];

    if (hasCargo) {
        actions.push({ label: ` Sell ${sellGood.icon} ${sellGood.name} (${sellPrice}g x${sellQty})`, action: () => {
            gs.player.cargo[sellGid] -= sellQty;
            if (gs.player.cargo[sellGid] <= 0) delete gs.player.cargo[sellGid];
            gs.player.gold += sellPrice * sellQty;
            gs.player.merchantFavor = (gs.player.merchantFavor || 0) + 1;
            this.ui.showEncounter(enc, [], { positive: true, text: `Sold ${sellQty}x ${sellGood.name} for ${sellPrice * sellQty}g. Good trade!` });
            this.ui.updateHUD(gs);
        } });
    }

    actions.push({ label: ' Sail on', action: () => {
        this.ui.closeEncounter();
        if (entity) entity.daysRemaining = Math.max(1, entity.daysRemaining - 2);
    } });

    this.ui.showEncounter(enc, actions);
}

triggerBlockadeRunner() {
    const gs = this.gameState, enc = CONFIG.encounters.blockadeRunner;
    const fee = 100 + Math.floor(Math.random() * 150);

    this.ui.showEncounter(enc, [
        { label: ` Pay the fee (${fee}g)`, style: 'primary', action: () => {
            if (gs.player.gold >= fee) {
                gs.player.gold -= fee;
                // Grant temporary blockade immunity
                gs.player.blockadePass = gs.player.days + 3; // 3 days of safe passage
                applyRepChange(gs, 'pirates', 5, 'used_smuggler');
                applyRepChange(gs, 'english', -3, 'used_smuggler');
                this.ui.showEncounter(enc, [], { positive: true, text: `Paid ${fee}g. You have safe passage through blockades for 3 days.` });
            } else {
                this.ui.showEncounter(enc, [], { positive: false, text: 'Not enough gold!' });
            }
            this.ui.updateHUD(gs);
        } },
        { label: ' Report them', action: () => {
            const reward = 50 + Math.floor(Math.random() * 50);
            gs.player.gold += reward;
            applyRepChange(gs, 'english', 10, 'reported_smuggler');
            applyRepChange(gs, 'pirates', -15, 'reported_smuggler');
            addHeat(gs, -10); // Reduces heat
            this.ui.showEncounter(enc, [], { positive: true, text: `Reported to Navy. +${reward}g reward, +10 Navy rep, -15 Pirate rep, reduced heat.` });
            this.ui.updateHUD(gs);
        } },
        { label: ' Refuse', action: () => this.ui.closeEncounter() }
    ]);
}

triggerStormsEye() {
    const gs = this.gameState, enc = CONFIG.encounters.stormsEye;

    this.ui.showEncounter(enc, [
        { label: ' Salvage quickly', style: 'primary', action: () => {
            // Quick salvage - random valuable cargo, storm resumes
            const r = Math.random();
            if (r < 0.6) {
                const gids = Object.keys(CONFIG.goods);
                const gid = gids[Math.floor(Math.random() * gids.length)];
                const good = CONFIG.goods[gid];
                const qty = 2 + Math.floor(Math.random() * 4);
                const check = canCarryMore(gid, qty, gs);
                if (check.canCarry) {
                    gs.player.cargo[gid] = (gs.player.cargo[gid] || 0) + qty;
                    if (good.category === 'contraband') addHeat(gs, CONFIG.settings.heatGainContraband / 2);
                    this.ui.showEncounter(enc, [], { positive: true, text: `Grabbed ${qty}x ${good.name} before the storm returned!` });
                } else {
                    this.ui.showEncounter(enc, [], { positive: false, text: 'No room for salvage!' });
                }
            } else {
                const gold = 30 + Math.floor(Math.random() * 70);
                gs.player.gold += gold;
                this.ui.showEncounter(enc, [], { positive: true, text: `Found ${gold}g in the wreckage!` });
            }
            this.ui.updateHUD(gs);
        } },
        { label: ' Search thoroughly', action: () => {
            // Better cargo but storm catches you
            const gids = Object.keys(CONFIG.goods).filter(g => CONFIG.goods[g].category === 'luxury');
            const gid = gids[Math.floor(Math.random() * gids.length)] || 'gold';
            const good = CONFIG.goods[gid];
            const qty = 3 + Math.floor(Math.random() * 5);
            const check = canCarryMore(gid, qty, gs);

            if (check.canCarry) {
                gs.player.cargo[gid] = (gs.player.cargo[gid] || 0) + qty;
                // But storm catches you
                const supplyLoss = 2 + Math.floor(Math.random() * 3);
                gs.player.supplies = Math.max(0, gs.player.supplies - supplyLoss);
                if (Math.random() < 0.4) {
                    this.loseCargo(calcCargoLoss(gs, 0.1));
                    this.ui.showEncounter(enc, [], { positive: false, text: `Found ${qty}x ${good.name}! But the storm caught you. Lost ${supplyLoss} supplies and some cargo.` });
                } else {
                    this.ui.showEncounter(enc, [], { positive: true, text: `Found ${qty}x ${good.name}! Lost ${supplyLoss} supplies escaping the storm.` });
                }
            } else {
                this.ui.showEncounter(enc, [], { positive: false, text: 'No room for salvage!' });
            }
            this.ui.updateHUD(gs);
        } },
        { label: ' Take survivors only', action: () => {
            // Crew bonus, karma, nothing material
            gs.player.supplies = Math.min(30, gs.player.supplies + 2); // They had some supplies
            applyRepChange(gs, 'english', 5, 'rescued_sailors');
            applyRepChange(gs, 'eitc', 5, 'rescued_sailors');
            gs.player.merchantFavor = (gs.player.merchantFavor || 0) + 2;
            this.ui.showEncounter(enc, [], { positive: true, text: 'Rescued the crew. They share stories and a bit of supplies. +5 rep with Navy and Company. The sea remembers.' });
            this.ui.updateHUD(gs);
        } }
    ]);
}

triggerPirateFleetEncounter(entity) {
    const gs = this.gameState, enc = CONFIG.encounters.pirateFleetEncounter;
    const baseCost = Math.floor(gs.player.gold * 0.25) + 200; // Higher than normal pirates
    const cost = calcTributeCost(gs, baseCost);

    this.ui.showEncounter(enc, [
        { label: ` Pay tribute (${cost}g)`, style: 'danger', action: () => {
            if (gs.player.gold >= cost) {
                gs.player.gold -= cost;
                applyRepChange(gs, 'pirates', 3, 'paid_fleet');
                this.ui.showEncounter(enc, [], { positive: false, text: `Paid ${cost}g to the fleet. They let you pass... this time.` });
            } else {
                this.loseCargo(calcCargoLoss(gs, 0.5));
                const goldLoss = calcGoldLoss(gs, Math.floor(gs.player.gold * 0.3));
                gs.player.gold = Math.max(0, gs.player.gold - goldLoss);
                applyRepChange(gs, 'pirates', -5, 'couldnt_pay_fleet');
                this.ui.showEncounter(enc, [], { positive: false, text: 'Couldn\'t pay! They took what they wanted.' });
            }
            this.ui.updateHUD(gs);
        } },
        { label: ' Fight the fleet', action: () => {
            // Very risky fight
            if (Math.random() < 0.25) { // 25% chance to win
                const reward = 200 + Math.floor(Math.random() * 300);
                gs.player.gold += reward;
                applyRepChange(gs, 'pirates', -20, 'defeated_fleet');
                applyRepChange(gs, 'english', 15, 'defeated_fleet');
                // Remove the fleet entity
                if (entity) entity.daysRemaining = 0;
                this.ui.showEncounter(enc, [], { positive: true, text: `Victory against the odds! +${reward}g, +15 Navy rep. The fleet is scattered.` });
            } else {
                this.loseCargo(calcCargoLoss(gs, 0.7));
                const goldLoss = calcGoldLoss(gs, Math.floor(gs.player.gold * 0.5));
                gs.player.gold = Math.max(0, gs.player.gold - goldLoss);
                gs.player.supplies = Math.max(0, gs.player.supplies - 5);
                this.ui.showEncounter(enc, [], { positive: false, text: 'Overwhelmed! Lost most cargo, gold, and supplies.' });
            }
            this.ui.updateHUD(gs);
        } },
        ...(gs.player.faction === 'pirates' ? [{ label: ' Invoke the Code', action: () => {
            // Pirates can invoke the Code
            applyRepChange(gs, 'pirates', -10, 'invoked_code');
            this.ui.showEncounter(enc, [], { positive: true, text: 'You invoke the Pirate\'s Code. They grumble but let you pass. -10 pirate rep for the insult.' });
            this.ui.updateHUD(gs);
        } }] : [])
    ]);
}

triggerConvoyEncounter(entity) {
    const gs = this.gameState, enc = CONFIG.encounters.convoyEncounter;
    const hasContraband = getContrabandCount(gs) > 0;

    this.ui.showEncounter(enc, [
        { label: ' Submit to inspection', style: hasContraband ? 'danger' : 'primary', action: () => {
            if (hasContraband) {
                // They find the contraband
                this.confiscateContraband(gs);
                const fine = 100 + getContrabandCount(gs) * 20;
                gs.player.gold = Math.max(0, gs.player.gold - fine);
                applyRepChange(gs, 'english', -15, 'caught_by_convoy');
                addHeat(gs, 20);
                this.ui.showEncounter(enc, [], { positive: false, text: `Contraband found! Confiscated, fined ${fine}g. -15 Navy rep.` });
            } else {
                // Clean - get convoy protection
                applyRepChange(gs, 'english', 5, 'passed_inspection');
                gs.player.convoyProtection = gs.player.days + 2; // 2 days safe from pirates
                this.ui.showEncounter(enc, [], { positive: true, text: 'Cargo clean. The convoy offers protection for 2 days. +5 Navy rep.' });
            }
            this.ui.updateHUD(gs);
        } },
        { label: ' Break away', action: () => {
            // Try to escape - risky
            if (Math.random() < 0.5) {
                addHeat(gs, 15);
                applyRepChange(gs, 'english', -10, 'fled_convoy');
                this.ui.showEncounter(enc, [], { positive: true, text: 'Escaped the convoy! Heat increased, -10 Navy rep.' });
            } else {
                // Caught - forced inspection
                if (hasContraband) {
                    this.confiscateContraband(gs);
                    const fine = 150 + getContrabandCount(gs) * 25;
                    gs.player.gold = Math.max(0, gs.player.gold - fine);
                    applyRepChange(gs, 'english', -25, 'caught_fleeing_convoy');
                    addHeat(gs, 30);
                    this.ui.showEncounter(enc, [], { positive: false, text: `Caught fleeing! Contraband confiscated, fined ${fine}g. -25 Navy rep.` });
                } else {
                    applyRepChange(gs, 'english', -15, 'fled_then_caught');
                    addHeat(gs, 15);
                    this.ui.showEncounter(enc, [], { positive: false, text: 'Caught! Cargo clean but -15 Navy rep for fleeing.' });
                }
            }
            this.ui.updateHUD(gs);
        } },
        { label: ' Shadow the convoy', action: () => {
            // Follow for protection but guaranteed inspection at destination
            gs.player.convoyProtection = gs.player.days + 3;
            gs.player.convoyInspection = true; // Will be inspected at next dock
            this.ui.showEncounter(enc, [], { positive: true, text: 'You shadow the convoy. Safe from pirates for 3 days, but expect inspection at your next port.' });
            this.ui.closeEncounter();
        } }
    ]);
}

// === LIVING SEA: Blockade Encounter System ===
getNearbyBlockadedIsland(gs) {
    const pp = gs.player.position;
    const blockades = getActiveBlockades(gs);
    const blockadedIds = blockades.map(b => b.islandId);

    for (const iid of blockadedIds) {
        const isl = CONFIG.islands[iid];
        if (!isl) continue;
        const dist = Math.sqrt((isl.position.x - pp.x) ** 2 + (isl.position.z - pp.z) ** 2);
        // Trigger within 80 units of blockaded island
        if (dist < 80 && dist > CONFIG.settings.dockDistance) {
            const blockade = getBlockadeInfo(gs, iid);
            // Don't trigger twice per day
            if (blockade.lastEncounterDay === gs.player.days) continue;
            return { iid, island: isl, blockade, distance: dist };
        }
    }
    return null;
}

triggerBlockadeEncounter(info) {
    const gs = this.gameState;
    const { iid, island, blockade } = info;
    blockade.lastEncounterDay = gs.player.days;

    const blockaderName = blockade.blockadingFaction === 'english' ? 'Royal Navy' :
                         blockade.blockadingFaction === 'pirates' ? 'Pirate Fleet' : 'Company Ships';

    const enc = {
        name: 'Blockade!',
        icon: '',
        desc: `${blockaderName} blockading ${island.name}! Their ships move to intercept.`
    };

    const bribeCost = 100 + Math.floor(blockade.strength * 2);
    const hasContraband = getContrabandCount(gs) > 0;

    this.ui.showEncounter(enc, [
        { label: ` Bribe passage (${bribeCost}g)`, style: gs.player.gold >= bribeCost ? 'primary' : 'secondary', action: () => {
            if (gs.player.gold < bribeCost) {
                this.ui.toast('Not enough gold', `Need ${bribeCost}g`);
                return;
            }
            gs.player.gold -= bribeCost;
            // Reduce influence of blockading faction
            modifyInfluence(gs, iid, blockade.blockadingFaction, -2);
            this.ui.showEncounter(enc, [], { positive: true, text: `Paid ${bribeCost}g. The blockade lets you pass.` });
            this.ui.updateHUD(gs);
        } },
        { label: ' Run the blockade', style: 'danger', action: () => {
            // Chase encounter!
            this.startChase('blockade');
        } },
        { label: ' Turn back', action: () => {
            // Safe escape but can't reach the island
            gs.player.destinationIslandId = null;
            this.ui.showEncounter(enc, [], { positive: true, text: 'You retreat to open waters. The blockade remains.' });
            this.ui.closeEncounter();
        } }
    ]);
}

dock() {
    // Check for cove first
    if (this.nearbyCove) {
        this.dockAtCove(this.nearbyCove);
        return;
    }
    if (!this.nearbyIsland) { this.ui.toast('Too Far', 'Get closer!'); return; }
    const gs = this.gameState, pp = gs.player.position, isl = CONFIG.islands[this.nearbyIsland];
    if (Math.sqrt((isl.position.x - pp.x)**2 + (isl.position.z - pp.z)**2) > CONFIG.settings.dockDistance) { this.ui.toast('Too Far', 'Get closer!'); return; }

    // === LIVING SEA: Check for blockade (requires blockadePass to dock) ===
    const portState = getPortState(gs, this.nearbyIsland);
    if (portState === 'blockaded') {
        const hasPass = gs.player.blockadePass && gs.player.blockadePass >= gs.player.days;
        if (!hasPass) {
            this.ui.toast('Blockaded!', 'Navy ships prevent docking. Find a blockade runner.');
            return;
        }
        this.ui.toast('Pass Used', 'Slipping through the blockade...');
    }

    gs.isDocked = true;
    gs.currentIsland = this.nearbyIsland;
    gs.player.daysSinceDock = 0; // Reset days since dock
    // Per-contract inspection tracking: wasInspected flag is on each contract, no global reset needed

    // === LIVING SEA: Check for convoy inspection (from shadowing navy convoy) ===
    if (gs.player.convoyInspection) {
        gs.player.convoyInspection = false; // Clear flag
        this.ui.toast('Convoy Report', 'Navy was alerted to your presence!');
        setTimeout(() => this.triggerInspection(), 500);
        return; // Don't proceed with normal docking until inspection resolves
    }

    // === BALANCE: Docking fee ===
    const dockFee = calculateDockingFee(gs, this.nearbyIsland);
    if (dockFee > 0) {
        gs.player.gold = Math.max(0, gs.player.gold - dockFee);
        this.ui.toast('Docking Fee', '-' + dockFee + 'g');
    }

    // === BALANCE: Record port visit for cooldown system ===
    recordPortVisit(gs, this.nearbyIsland);

    // === META PRESSURE: Record route if we have a previous port ===
    const meta = metaInit(gs);
    if (meta.lastPort && meta.lastPort !== this.nearbyIsland) {
        metaRecordRoute(gs, meta.lastPort, this.nearbyIsland);
    } else {
        // First dock or same port - just update lastPort and record port visit
        meta.lastPort = this.nearbyIsland;
        metaAddToWindow(meta.recentPorts, meta.portCounts, this.nearbyIsland, CONFIG.metaPressure.windowSize);
        metaAddToWindow(meta.recentFactions, meta.factionCounts, isl.faction, CONFIG.metaPressure.windowSize);
        metaRecalcPressure(gs);
    }

    // === BALANCE: Bounty decay at friendly ports ===
    const isFriendly = isl.faction === gs.player.faction || isl.faction === 'neutral';
    decayBounty(gs, true, isFriendly);
    // Heat also decays faster when docked at friendly
    decayHeatBalanced(gs, true, isFriendly);

    // Heat changes on dock
    const islFaction = isl.faction;
    if (islFaction === 'english' || islFaction === 'eitc') {
        // Heat increases if carrying contraband at English/EITC ports
        if (getContrabandCount(gs) > 0) {
            addHeat(gs, CONFIG.settings.heatGainDockEnglishEITC);
        }
    } else {
        // Heat decays faster at pirate/neutral ports
        gs.player.heat = Math.max(0, (gs.player.heat || 0) - 10);
    }

    // Evaluate contracts
    const completedContracts = evaluateContractsOnDock(gs, this.nearbyIsland);
    if (completedContracts.length > 0) {
        this.ui.showContractComplete(completedContracts);
    }

    // === LIVING SEA: Check questline progress ===
    const questResult = checkQuestlineStep(gs, 'dock', { islandId: this.nearbyIsland });
    if (questResult.completed) {
        // Full questline completed - show completion modal
        this.ui.showQuestComplete(questResult.rewards);
    } else if (questResult.stepDone) {
        // Step completed but questline continues
        const rewardText = questResult.reward ? ` +${questResult.reward}g` : '';
        this.ui.toast('Step Complete!', questResult.message + rewardText);
    } else if (questResult.progress) {
        // Partial progress on a delivery step
        const rewardText = questResult.reward ? ` +${questResult.reward}g` : '';
        this.ui.toast('Delivery Made!', `${questResult.message}${rewardText}`);
    } else if (questResult.blocked) {
        // Anti-cheese: goods were bought locally
        this.ui.toast('Quest Blocked', questResult.message);
    }

    // Refresh contract board
    refreshContractBoard(gs, this.nearbyIsland);

    // Update titles
    updateTitles(gs, (icon, name, desc) => {
        this.ui.showTitleEarned(icon, name, desc);
    });

    // Resupply
    const cost = 2, maxBuy = Math.min(30 - gs.player.supplies, Math.floor(gs.player.gold / cost));
    if (maxBuy > 0 && gs.player.supplies < 15) { const b = Math.min(maxBuy, 15); gs.player.gold -= b * cost; gs.player.supplies += b; this.ui.toast('Resupplied', '+' + b); }
    this.ui.updateHUD(gs); this.ui.showTrade(this.nearbyIsland, gs); this.save();
}

undock() {
    // === BALANCE: Reset trade fatigue when leaving port ===
    resetTradeFatigue(this.gameState);
    this.gameState.isDocked = false;
    this.ui.closeTrade();
}

// ==================== LIVING SEA: HIDDEN COVE DOCKING ====================
dockAtCove(coveId) {
    const gs = this.gameState;
    const cove = CONFIG.hiddenCoves[coveId];
    if (!cove) { this.ui.toast('Error', 'Unknown cove'); return; }

    const pp = gs.player.position;
    const dist = Math.sqrt((cove.position.x - pp.x)**2 + (cove.position.z - pp.z)**2);
    if (dist > CONFIG.settings.dockDistance) { this.ui.toast('Too Far', 'Get closer!'); return; }

    gs.isDocked = true;
    gs.currentCove = coveId;
    gs.player.daysSinceDock = 0;

    // Heat drops significantly at hidden coves
    gs.player.heat = Math.max(0, (gs.player.heat || 0) - 20);

    this.ui.showCove(coveId, gs);
    this.save();
}

undockCove() {
    this.gameState.isDocked = false;
    this.gameState.currentCove = null;
}

// Cove services
useCoveService(coveId, service) {
    try {
        const gs = this.gameState;
        const cove = CONFIG.hiddenCoves[coveId];
        if (!cove) return;

        switch(service) {
            case 'fence':
                this.coveFence(gs);
                break;
            case 'salvage':
                this.coveSalvage(gs);
                break;
            case 'repair':
                this.coveRepair(gs);
                break;
            case 'rest':
                this.coveRest(gs);
                break;
            case 'treasure':
                this.coveTreasure(gs, coveId);
                break;
            case 'charts':
                this.coveCharts(gs);
                break;
            case 'rumors':
                this.coveRumors(gs);
                break;
        }
        this.ui.updateHUD(gs);
        this.save();
    } catch (e) {
        console.error('Cove service error:', service, e);
        this.ui.toast('Error', e.message || 'Service failed');
    }
}

coveFence(gs) {
    const contraband = Object.entries(gs.player.cargo)
        .filter(([gid, qty]) => CONFIG.goods[gid]?.category === 'contraband' && qty > 0);
    if (contraband.length === 0) {
        this.ui.toast('No Contraband', 'Nothing to fence');
        return;
    }
    let total = 0;
    for (const [gid, qty] of contraband) {
        const price = Math.floor(CONFIG.goods[gid].basePrice * 1.5);
        total += price * qty;
        gs.player.cargo[gid] = 0;
    }
    gs.player.gold += total;
    this.ui.toast('Fenced!', '+' + total + 'g (no heat)');
}

coveSalvage(gs) {
    const cost = 50;
    if (gs.player.gold < cost) { this.ui.toast('No Gold', 'Need ' + cost + 'g'); return; }
    const gids = Object.keys(CONFIG.goods).filter(g => CONFIG.goods[g].category !== 'contraband');
    const gid = gids[Math.floor(Math.random() * gids.length)];
    const qty = 2 + Math.floor(Math.random() * 4);
    const check = canCarryMore(gid, qty, gs);
    if (!check.canCarry) { this.ui.toast('No Space', check.reason); return; }
    gs.player.gold -= cost;
    gs.player.cargo[gid] = (gs.player.cargo[gid] || 0) + qty;
    this.ui.toast('Salvage', qty + 'x ' + CONFIG.goods[gid].name);
}

coveRepair(gs) {
    const hullDmg = getMaxHull(gs) - getShipHull(gs);
    const riggingDmg = getMaxRigging(gs) - getShipRigging(gs);
    if (hullDmg <= 0 && riggingDmg <= 0) { this.ui.toast('No Damage', 'Ship is fine'); return; }
    const cost = Math.floor((hullDmg + riggingDmg) * 0.5); // Half price
    if (gs.player.gold < cost) { this.ui.toast('No Gold', 'Need ' + cost + 'g'); return; }
    gs.player.gold -= cost;
    if (gs.player.ship) {
        gs.player.ship.hull = getMaxHull(gs);
        gs.player.ship.rigging = getMaxRigging(gs);
    }
    this.ui.toast('Repaired', '-' + cost + 'g (cheap!)');
}

coveRest(gs) {
    const currentMorale = getShipMorale(gs);
    const maxMorale = getMaxMorale(gs);
    if (currentMorale >= maxMorale) { this.ui.toast('Crew Happy', 'Morale is full'); return; }
    const cost = 25;
    if (gs.player.gold < cost) { this.ui.toast('No Gold', 'Need ' + cost + 'g'); return; }
    gs.player.gold -= cost;
    if (gs.player.ship) gs.player.ship.morale = maxMorale;
    this.ui.toast('Rested', 'Crew morale restored');
}

coveTreasure(gs, coveId) {
    // One-time treasure per cove
    if (!gs.player.covesTreasured) gs.player.covesTreasured = [];
    if (gs.player.covesTreasured.includes(coveId)) {
        this.ui.toast('Already Looted', 'Treasure was claimed');
        return;
    }
    gs.player.covesTreasured.push(coveId);
    const gold = 200 + Math.floor(Math.random() * 300);
    gs.player.gold += gold;
    this.ui.toast('Treasure!', '+' + gold + 'g found!');
}

coveCharts(gs) {
    const cost = 75;
    if (gs.player.gold < cost) { this.ui.toast('No Gold', 'Need ' + cost + 'g'); return; }
    gs.player.gold -= cost;
    const result = addChartFragment(gs);
    if (result.discovered) {
        const cove = CONFIG.hiddenCoves[result.coveId];
        this.ui.toast('Discovery!', cove.name + ' revealed!');
    } else {
        this.ui.toast('Chart Fragment', gs.player.chartFragments + '/3');
    }
    this.ui.updateChartFragments(gs);
}

coveRumors(gs) {
    const rumor = getCoveRumor(gs);
    if (rumor) {
        this.ui.toast('Rumor', rumor.hint);
    } else {
        this.ui.toast('No News', 'All coves discovered');
    }
}

buyBest() {
    const gs = this.gameState, iid = gs.currentIsland; if (!iid) return;
    const deals = calcDeals(gs, iid);
    for (const d of deals) {
        const g = CONFIG.goods[d.gid], m = gs.islands[iid].markets[d.gid];
        const check = canCarryMore(d.gid, 1, gs);
        const max = Math.min(Math.floor(gs.player.gold / d.buyPrice), Math.floor((getCargoCapacity(gs) - getCargoUsed(gs)) / g.weight), m.supply);
        if (max > 0 && check.canCarry) {
            for (let i = 0; i < max; i++) if (!buyGood(d.gid, 1, iid, gs).success) break;
            this.ui.toast('Bought', g.name);
            this.ui.renderBuy(iid, gs); this.ui.renderSell(iid, gs); this.ui.updateFooter(gs); this.save();
            return;
        }
    }
    this.ui.toast('No Deals', 'Visit more ports');
}

sellBest() {
    const gs = this.gameState, iid = gs.currentIsland; if (!iid || !Object.keys(gs.player.cargo).length) { this.ui.toast('Empty', 'Nothing to sell'); return; }
    let best = null, bestScore = -Infinity;
    Object.entries(gs.player.cargo).forEach(([gid, qty]) => { const cp = calcSellPrice(gid, iid, gs), pp = gs.player.purchaseHistory[gid] || 0, score = (cp - pp) > 0 ? (cp - pp) * 1000 + cp : cp; if (score > bestScore) { bestScore = score; best = gid; } });
    if (best) { const g = CONFIG.goods[best], qty = gs.player.cargo[best]; for (let i = 0; i < qty; i++) if (!sellGood(best, 1, iid, gs).success) break; this.ui.toast('Sold', g.name); this.ui.renderBuy(iid, gs); this.ui.renderSell(iid, gs); this.ui.updateFooter(gs); this.save(); }
}

buyUpgrade(id) {
    const gs = this.gameState, u = CONFIG.upgrades[id];
    if (!u || gs.player.upgrades[id]) return false;

    // === BALANCE: Upgrade costs scale with player power ===
    const prog = CONFIG.balance.progression;
    const costMult = getPowerScaling(gs, 1.0, prog.upgradeCostPowerMult, 1.0, prog.upgradeCostMax);
    const scaledCost = Math.floor(u.cost * costMult);

    if (gs.player.gold < scaledCost) return false;
    gs.player.gold -= scaledCost;
    gs.player.upgrades[id] = true;
    this.ui.toast('Upgrade!', u.name);
    this.ui.updateHUD(gs);
    this.save();
    return true;
}

// Helper to get scaled upgrade cost for display
getUpgradeCost(id) {
    const gs = this.gameState, u = CONFIG.upgrades[id];
    if (!u) return 0;
    const prog = CONFIG.balance.progression;
    const costMult = getPowerScaling(gs, 1.0, prog.upgradeCostPowerMult, 1.0, prog.upgradeCostMax);
    return Math.floor(u.cost * costMult);
}

// === LIVING SEA: Buy Pardon ===
buyPardon() {
    const gs = this.gameState;
    if (!gs.isDocked || !gs.currentIsland) {
        this.ui.toast('Error', 'Must be docked');
        return false;
    }

    const bounty = getBounty(gs);
    if (bounty <= 0) {
        this.ui.toast('Clean Record', 'No bounty to clear');
        return false;
    }

    const cost = getPardonCost(gs, gs.currentIsland);
    if (cost === null) {
        this.ui.toast('Unavailable', 'No pardons here');
        return false;
    }

    if (gs.player.gold < cost) {
        this.ui.toast('No Gold', `Need ${cost}g`);
        return false;
    }

    gs.player.gold -= cost;
    grantPardon(gs);
    this.ui.toast('Pardoned!', 'Your record is clean');
    this.ui.updateHUD(gs);
    this.save();
    return true;
}

// === LIVING SEA: Questline Management ===
startQuestline(questlineId) {
    const gs = this.gameState;
    const result = startQuestline(gs, questlineId);
    if (result.success) {
        this.ui.updateHUD(gs);
        this.save();
    }
    return result;
}

abandonQuestline() {
    const gs = this.gameState;
    const result = failQuestline(gs);
    if (result.success) {
        this.ui.toast('Quest Abandoned', 'Progress lost');
        this.ui.updateHUD(gs);
        this.save();
    }
    return result;
}

// === LIVING SEA: Ship repairs at dock ===
repairShip(type) {
    const gs = this.gameState;

    // Calculate amount to repair
    let amount = 0;
    if (type === 'hull') {
        amount = getMaxHull(gs) - getShipHull(gs);
    } else if (type === 'rigging') {
        amount = getMaxRigging(gs) - getShipRigging(gs);
    } else if (type === 'morale') {
        amount = getMaxMorale(gs) - getShipMorale(gs);
    }

    if (amount <= 0) return false;

    const cost = getRepairCost(gs, type === 'morale' ? 'rest' : type, amount);
    if (gs.player.gold < cost) return false;

    let repaired = false;
    if (type === 'hull') {
        repairHull(gs, amount);
        repaired = true;
    } else if (type === 'rigging') {
        repairRigging(gs, amount);
        repaired = true;
    } else if (type === 'morale') {
        restoreMorale(gs, amount);
        repaired = true;
    }

    if (repaired) {
        gs.player.gold -= cost;
        const labels = { hull: 'Hull Repaired', rigging: 'Rigging Fixed', morale: 'Crew Rested' };
        this.ui.toast('Repairs', labels[type] || 'Ship Repaired');
        this.save();
    }
    return repaired;
}

// === LIVING SEA: Officer hiring/firing ===
hireOfficer(type, name) {
    const gs = this.gameState;
    const cfg = CONFIG.officers?.[type];
    if (!cfg) return false;

    const officers = gs.player.officers || [];
    if (officers.length >= 3) {
        this.ui.toast('Full Crew', 'Max 3 officers');
        return false;
    }

    const hireCost = cfg.hireCost || 100;
    if (gs.player.gold < hireCost) {
        this.ui.toast('No Gold', 'Not enough to hire');
        return false;
    }

    // Check if already have this type
    if (hasOfficer(gs, type)) {
        this.ui.toast('Duplicate', `Already have a ${cfg.name}`);
        return false;
    }

    gs.player.gold -= hireCost;
    hireOfficer(gs, type);
    // Set the name for the hired officer
    const hired = gs.player.officers[gs.player.officers.length - 1];
    if (hired) hired.name = name;

    this.ui.toast('Hired!', `${name} joins your crew`);
    this.save();
    return true;
}

fireOfficer(officerId) {
    const gs = this.gameState;
    const officer = gs.player.officers?.find(o => o.id === officerId);
    if (!officer) return false;

    fireOfficer(gs, officerId);
    this.ui.toast('Dismissed', `${officer.name} leaves your crew`);
    this.save();
    return true;
}

// === LIVING SEA: Ship purchase ===
buyShip(shipId) {
    const gs = this.gameState;
    const ship = CONFIG.shipClasses?.[shipId];
    if (!ship) return false;

    if (gs.player.shipClass === shipId) {
        this.ui.toast('Already Owned', 'This is your current ship');
        return false;
    }

    if (gs.player.gold < ship.cost) {
        this.ui.toast('No Gold', 'Not enough for this ship');
        return false;
    }

    // Check if cargo fits in new ship
    const currentCargo = getCargoUsed(gs);
    if (currentCargo > ship.cargoCapacity) {
        this.ui.toast('Too Much Cargo', `Sell ${currentCargo - ship.cargoCapacity} cargo first`);
        return false;
    }

    gs.player.gold -= ship.cost;
    gs.player.shipClass = shipId;

    // Reset ship condition to new ship's max values
    gs.player.ship = {
        hull: ship.hullMax,
        rigging: ship.riggingMax,
        morale: gs.player.ship?.morale || 100 // Keep crew morale
    };

    this.ui.toast('New Ship!', `You now captain a ${ship.name}`);
    this.save();
    return true;
}

// Save throttling with dirty flag - prevents excessive localStorage writes
_dirty = false;
_saveTimeout = null;
_lastSaveTime = 0;
_saveThrottleMs = 2000; // Minimum 2 seconds between saves

save() {
    this._dirty = true;
    const now = performance.now();
    const elapsed = now - this._lastSaveTime;

    // If enough time has passed, save immediately
    if (elapsed >= this._saveThrottleMs) {
        this._flushSave();
    } else if (!this._saveTimeout) {
        // Schedule a save for later
        this._saveTimeout = setTimeout(() => this._flushSave(), this._saveThrottleMs - elapsed);
    }
}

_flushSave() {
    if (this._saveTimeout) {
        clearTimeout(this._saveTimeout);
        this._saveTimeout = null;
    }
    if (this._dirty && this.gameState) {
        localStorage.setItem('merchantSeasSave', JSON.stringify(this.gameState));
        this._dirty = false;
        this._lastSaveTime = performance.now();
    }
}
load() {
    try {
        this.gameState = migrateState(JSON.parse(localStorage.getItem('merchantSeasSave')));
        this.ui.hideFaction(); this.ui.showGame();
        this.scene = new SceneManager(document.getElementById('game-canvas'));
        this.joystick = new Joystick();
        this.ui.updateHUD(this.gameState);
        return true;
    } catch { return false; }
}
start() { this.lastTime = performance.now(); this.animate(); }
animate() {
    requestAnimationFrame(() => this.animate());
    if (!this.scene || !this.gameState) return;
    const now = performance.now(), dt = (now - this.lastTime) / 1000;
    this.lastTime = now;
    this.update(dt);
    this.scene.updateShip(this.gameState.player.position, this.joystick?.active ? this.joystick.angle : null);
    this.scene.updateCamera(this.gameState.player.position);

    // Update navigation line to destination
    const tracked = getTrackedContract(this.gameState);
    const destId = tracked?.toIsland || this.gameState.player.destinationIslandId;
    const destPos = destId ? CONFIG.islands[destId]?.position : null;
    this.scene.updateNavigation(this.gameState.player.position, destPos);

    this.scene.render();
}

}

// ==================== THEME & VISUAL EFFECTS MANAGER ====================
class VisualEffectsManager {
    constructor() {
        this.currentTheme = localStorage.getItem('havenvoy-theme') || 'light';
        this.particleContainer = document.getElementById('particle-container');
        this.weatherOverlay = document.getElementById('weather-overlay');
        this.daytimeOverlay = document.getElementById('daytime-overlay');
        this.particles = [];
        this.maxParticles = 20;

        this.initTheme();
        this.bindThemeToggle();
        this.startParticleSystem();
    }

    initTheme() {
        document.documentElement.dataset.theme = this.currentTheme;
        this.updateDaytimeOverlay();
    }

    bindThemeToggle() {
        const toggle = document.getElementById('theme-toggle');
        if (toggle) {
            toggle.addEventListener('click', () => this.toggleTheme());
        }
    }

    toggleTheme() {
        this.currentTheme = this.currentTheme === 'light' ? 'dark' : 'light';
        document.documentElement.dataset.theme = this.currentTheme;
        localStorage.setItem('havenvoy-theme', this.currentTheme);
        this.updateDaytimeOverlay();

        // Trigger animation on toggle button
        const toggle = document.getElementById('theme-toggle');
        if (toggle) {
            toggle.style.animation = 'none';
            toggle.offsetHeight; // Trigger reflow
            toggle.style.animation = '';
        }

        // Update Three.js scene if game exists
        if (window.game?.scene) {
            window.game.scene.updateSkyColor();
        }
    }

    updateDaytimeOverlay() {
        if (!this.daytimeOverlay) return;
        this.daytimeOverlay.className = this.currentTheme === 'dark' ? 'night' : 'day';
    }

    startParticleSystem() {
        if (!this.particleContainer) return;

        // Create initial particles
        for (let i = 0; i < this.maxParticles; i++) {
            setTimeout(() => this.createParticle(), i * 400);
        }
    }

    createParticle() {
        if (!this.particleContainer) return;

        const particle = document.createElement('div');
        const isSparkle = Math.random() > 0.6;

        particle.className = `particle ${isSparkle ? 'sparkle' : 'bubble'}`;
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.animationDuration = `${6 + Math.random() * 6}s`;
        particle.style.animationDelay = `${Math.random() * 2}s`;

        this.particleContainer.appendChild(particle);

        // Remove and recreate after animation
        setTimeout(() => {
            particle.remove();
            this.createParticle();
        }, 12000);
    }

    setWeather(state) {
        if (!this.weatherOverlay) return;

        this.weatherOverlay.className = '';

        switch (state) {
            case 'storm':
                this.weatherOverlay.classList.add('active', 'storm', 'rain');
                break;
            case 'rain':
                this.weatherOverlay.classList.add('active', 'rain');
                break;
            case 'fog':
                this.weatherOverlay.classList.add('active', 'fog');
                break;
            default:
                // Clear weather
                break;
        }

        // Sync with Three.js scene
        if (window.game?.scene?.setWeather) {
            window.game.scene.setWeather(state);
        }
    }

    // Called when game day changes
    updateTimeOfDay(dayNumber) {
        if (!this.daytimeOverlay) return;

        // Cycle through times of day based on game day
        const cycle = dayNumber % 4;
        const timeClasses = ['dawn', 'day', 'dusk', 'night'];

        // Only apply time effects in light mode (dark mode is always night)
        if (this.currentTheme === 'light') {
            this.daytimeOverlay.className = timeClasses[cycle];
        }
    }
}

// Initialize visual effects manager
let visualEffects = null;

window.addEventListener('DOMContentLoaded', () => {
    // Initialize visual effects first
    visualEffects = new VisualEffectsManager();
    window.visualEffects = visualEffects;

    try {
        window.game = new Game();
    } catch (e) {
        console.error('Failed to create game:', e);
        document.getElementById('loading-screen')?.classList.add('hidden');
        document.getElementById('faction-screen')?.classList.remove('hidden');
    }
});

// Fallback: if still loading after 10 seconds, force show faction screen
setTimeout(() => {
    const loading = document.getElementById('loading-screen');
    if (loading && !loading.classList.contains('hidden')) {
        console.warn('Loading timeout - forcing faction screen');
        loading.classList.add('hidden');
        document.getElementById('faction-screen')?.classList.remove('hidden');
    }
}, 10000);

// Note: Global error handler is defined earlier in the file with showErrorOverlay support
</script>

</body>
</html>
