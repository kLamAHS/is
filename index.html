<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Merchant Seas</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <style>
        :root {
            --parchment: #f4e4c1; --parchment-dark: #d4c4a1; --ink: #2c1810; --ink-light: #5c4830;
            --gold: #c9a227; --gold-dark: #8b7019; --sea-dark: #1a3a4a; --sea-medium: #2d5a6a;
            --sea-light: #4a8a9a; --blood-red: #8b2500; --wood: #6b4423; --wood-dark: #3d2512;
            --sail-white: #f5f0e1; --english: #c41e3a; --eitc: #1e4d2b; --pirates: #2c2c2c;
            --neutral: #5a5a5a; --modal-bg: rgba(20, 15, 10, 0.95); --card-bg: rgba(244, 228, 193, 0.95);
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.5); --shadow-light: 0 2px 10px rgba(0, 0, 0, 0.3);
            --font-display: 'Cinzel', serif; --font-body: 'Crimson Text', Georgia, serif;
            --space-xs: 4px; --space-sm: 8px; --space-md: 16px; --space-lg: 24px; --space-xl: 32px;
            --touch-min: 48px; --ease-out: cubic-bezier(0.23, 1, 0.32, 1);
            --action-stack-h: 200px; --action-stack-bottom: 20px;
        }
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; overflow: hidden; touch-action: manipulation; -webkit-tap-highlight-color: transparent; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
        body { font-family: var(--font-body); font-size: 16px; line-height: 1.5; color: var(--ink); background: var(--sea-dark); }
        .hidden { display: none !important; }
    #loading-screen { position: fixed; inset: 0; background: linear-gradient(135deg, var(--sea-dark) 0%, #0d1f29 100%); display: flex; align-items: center; justify-content: center; z-index: 1000; }
    .loading-content { text-align: center; color: var(--parchment); }
    .loading-content h1 { font-family: var(--font-display); font-size: 2rem; font-weight: 700; letter-spacing: 0.1em; margin-bottom: var(--space-lg); text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); }
    .loading-ship { font-size: 3rem; animation: bob 2s ease-in-out infinite; margin-bottom: var(--space-lg); }
    @keyframes bob { 0%, 100% { transform: translateY(0) rotate(-5deg); } 50% { transform: translateY(-10px) rotate(5deg); } }
    .loading-bar { width: 200px; height: 6px; background: rgba(255, 255, 255, 0.2); border-radius: 3px; margin: 0 auto; overflow: hidden; }
    .loading-progress { height: 100%; width: 0%; background: linear-gradient(90deg, var(--gold), var(--gold-dark)); border-radius: 3px; transition: width 0.3s var(--ease-out); }

    .screen { position: fixed; inset: 0; background: linear-gradient(180deg, var(--sea-dark) 0%, #0d1f29 100%); overflow-y: auto; z-index: 900; }
    .screen-content { min-height: 100%; padding: var(--space-xl) var(--space-md); display: flex; flex-direction: column; align-items: center; }
    .screen-content h1 { font-family: var(--font-display); font-size: 1.5rem; color: var(--parchment); text-align: center; margin-bottom: var(--space-sm); }
    .subtitle { color: var(--parchment-dark); text-align: center; max-width: 300px; margin-bottom: var(--space-xl); font-style: italic; }
    .faction-cards { display: flex; flex-direction: column; gap: var(--space-md); width: 100%; max-width: 400px; }
    .faction-card { background: var(--card-bg); border: 3px solid transparent; border-radius: 12px; padding: var(--space-md); text-align: center; cursor: pointer; transition: all 0.3s var(--ease-out); }
    .faction-card:hover, .faction-card:active { transform: translateY(-2px); box-shadow: var(--shadow); }
    .faction-card.selected { border-color: var(--gold); box-shadow: 0 0 20px rgba(201, 162, 39, 0.4); }
    .faction-icon { font-size: 2.5rem; margin-bottom: var(--space-xs); }
    .faction-card h2 { font-family: var(--font-display); font-size: 1.1rem; color: var(--ink); margin-bottom: var(--space-xs); }
    .faction-desc { color: var(--ink-light); font-style: italic; margin-bottom: var(--space-sm); font-size: 0.85rem; }
    .faction-perks { list-style: none; text-align: left; font-size: 0.8rem; }
    .faction-perks li { padding: 2px 0; color: var(--ink-light); }
    .difficulty-tag { display: inline-block; font-size: 0.65rem; padding: 2px 6px; border-radius: 4px; margin-top: 4px; }
    .difficulty-easy { background: #1e7d34; color: white; }
    .difficulty-medium { background: var(--gold-dark); color: white; }
    .difficulty-hard { background: var(--blood-red); color: white; }

    .btn-primary, .btn-secondary, .btn-danger { font-family: var(--font-display); font-size: 0.95rem; padding: var(--space-md) var(--space-xl); border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s var(--ease-out); min-height: var(--touch-min); display: inline-flex; align-items: center; justify-content: center; gap: var(--space-sm); }
    .btn-primary { background: linear-gradient(180deg, var(--gold) 0%, var(--gold-dark) 100%); color: var(--ink); box-shadow: 0 3px 0 var(--wood-dark), var(--shadow-light); }
    .btn-primary:active { transform: translateY(2px); box-shadow: 0 1px 0 var(--wood-dark); }
    .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-secondary { background: var(--parchment); color: var(--ink); border: 2px solid var(--ink-light); }
    .btn-danger { background: linear-gradient(180deg, var(--blood-red) 0%, #5c1700 100%); color: var(--parchment); }
    .btn-small { font-size: 0.75rem; padding: var(--space-xs) var(--space-sm); min-height: 32px; }

    #game-container { position: fixed; inset: 0; overflow: hidden; }
    #game-canvas { position: absolute; inset: 0; width: 100%; height: 100%; touch-action: none; }

    #hud-top { position: fixed; top: 0; left: 0; right: 0; display: flex; justify-content: center; gap: var(--space-sm); padding: var(--space-sm); background: linear-gradient(180deg, rgba(0, 0, 0, 0.6) 0%, transparent 100%); pointer-events: none; z-index: 10; flex-wrap: wrap; }
    .hud-item { display: flex; align-items: center; gap: var(--space-xs); background: var(--card-bg); padding: 6px 12px; border-radius: 20px; font-family: var(--font-display); font-size: 0.8rem; box-shadow: var(--shadow-light); }
    .hud-icon { font-size: 1rem; }
    .hud-value { font-weight: 600; color: var(--ink); }

    #faction-badge { position: fixed; top: 50px; left: var(--space-sm); display: flex; align-items: center; gap: var(--space-xs); background: var(--card-bg); padding: 4px 10px; border-radius: 15px; font-family: var(--font-display); font-size: 0.7rem; box-shadow: var(--shadow-light); z-index: 10; }
    #faction-badge.english { border-left: 3px solid var(--english); }
    #faction-badge.eitc { border-left: 3px solid var(--eitc); }
    #faction-badge.pirates { border-left: 3px solid var(--pirates); }

    #cargo-summary { position: fixed; top: 80px; left: var(--space-sm); background: var(--card-bg); padding: 6px 10px; border-radius: 8px; font-size: 0.75rem; max-width: 120px; box-shadow: var(--shadow-light); z-index: 10; }
    .cargo-header { display: flex; justify-content: space-between; font-family: var(--font-display); font-size: 0.7rem; margin-bottom: 2px; color: var(--ink-light); }
    #cargo-preview { display: flex; flex-wrap: wrap; gap: 2px; }
    .cargo-dot { width: 6px; height: 6px; border-radius: 2px; background: var(--gold); }
    .cargo-dot.high-margin { animation: glow-dot 1.5s ease-in-out infinite; background: #1e7d34; }
    .cargo-dot.contraband { background: var(--blood-red); }
    @keyframes glow-dot { 0%, 100% { box-shadow: 0 0 2px #1e7d34; } 50% { box-shadow: 0 0 6px #1e7d34; } }

    #wind-indicator { position: fixed; top: 130px; left: var(--space-sm); background: var(--card-bg); padding: 4px 8px; border-radius: 8px; font-size: 0.7rem; box-shadow: var(--shadow-light); z-index: 10; display: flex; align-items: center; gap: 4px; }
    #wind-arrow { display: inline-block; transition: transform 0.5s ease; }

    /* Heat indicator - small bar below wind */
    #heat-indicator { position: fixed; top: 160px; left: var(--space-sm); background: var(--card-bg); padding: 4px 8px; border-radius: 8px; font-size: 0.65rem; box-shadow: var(--shadow-light); z-index: 10; display: flex; align-items: center; gap: 4px; }
    #heat-indicator .heat-bar { width: 40px; height: 4px; background: var(--parchment-dark); border-radius: 2px; overflow: hidden; }
    #heat-indicator .heat-fill { height: 100%; background: var(--blood-red); transition: width 0.3s; }
    #heat-indicator.low .heat-fill { background: #1e7d34; }
    #heat-indicator.med .heat-fill { background: var(--gold-dark); }
    #heat-indicator.high .heat-fill { background: var(--blood-red); }

    /* Contract tracker chip */
    #contract-tracker { position: fixed; top: 190px; left: var(--space-sm); background: var(--card-bg); padding: 4px 8px; border-radius: 8px; font-size: 0.65rem; box-shadow: var(--shadow-light); z-index: 10; display: flex; align-items: center; gap: 4px; cursor: pointer; pointer-events: auto; max-width: 130px; border-left: 3px solid var(--gold); }
    #contract-tracker.hidden { display: none; }
    #contract-tracker .contract-title { font-family: var(--font-display); font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 80px; }
    #contract-tracker .contract-meta { color: var(--ink-light); font-size: 0.6rem; }

    /* Season/World indicator */
    #world-indicator { position: fixed; top: 220px; left: var(--space-sm); background: var(--card-bg); padding: 4px 8px; border-radius: 8px; font-size: 0.6rem; box-shadow: var(--shadow-light); z-index: 10; display: flex; align-items: center; gap: 4px; }
    #world-indicator.storm-season { border-left: 3px solid var(--sea-medium); }
    #world-indicator.crackdown { border-left: 3px solid var(--blood-red); }

    #compass { position: fixed; top: 50px; right: var(--space-sm); display: flex; flex-direction: column; align-items: center; gap: var(--space-xs); z-index: 10; }
    .compass-ring { width: 60px; height: 60px; border-radius: 50%; background: var(--card-bg); border: 3px solid var(--wood); position: relative; box-shadow: var(--shadow-light); }
    .compass-needle { position: absolute; top: 50%; left: 50%; width: 3px; height: 24px; background: linear-gradient(180deg, var(--blood-red) 50%, var(--ink) 50%); transform-origin: center bottom; transform: translate(-50%, -100%); border-radius: 2px; transition: transform 0.3s var(--ease-out); }
    .compass-dest-marker { position: absolute; width: 8px; height: 8px; background: var(--gold); border-radius: 50%; top: 5px; left: 50%; transform: translateX(-50%); box-shadow: 0 0 6px var(--gold); }
    .compass-n, .compass-e, .compass-s, .compass-w { position: absolute; font-family: var(--font-display); font-size: 0.6rem; font-weight: 700; color: var(--ink-light); }
    .compass-n { top: 3px; left: 50%; transform: translateX(-50%); color: var(--blood-red); }
    .compass-s { bottom: 3px; left: 50%; transform: translateX(-50%); }
    .compass-e { right: 5px; top: 50%; transform: translateY(-50%); }
    .compass-w { left: 5px; top: 50%; transform: translateY(-50%); }
    #destination-info { background: var(--card-bg); padding: 3px 8px; border-radius: 4px; text-align: center; font-size: 0.65rem; box-shadow: var(--shadow-light); }
    #dest-name { display: block; font-family: var(--font-display); font-weight: 600; }
    #dest-distance { color: var(--ink-light); }

    #mobile-controls { position: fixed; bottom: 0; left: 0; right: 0; height: 180px; pointer-events: none; z-index: 20; }
    #joystick-zone { position: absolute; bottom: 20px; left: 20px; width: 120px; height: 120px; pointer-events: auto; }
    #joystick-base { position: absolute; width: 120px; height: 120px; border-radius: 50%; background: radial-gradient(circle, rgba(244,228,193,0.3) 0%, rgba(244,228,193,0.1) 70%, transparent 100%); border: 3px solid rgba(244,228,193,0.5); }
    #joystick-stick { position: absolute; width: 50px; height: 50px; border-radius: 50%; background: radial-gradient(circle at 30% 30%, var(--parchment) 0%, var(--gold-dark) 100%); border: 3px solid var(--wood); box-shadow: 0 4px 8px rgba(0,0,0,0.4); left: 50%; top: 50%; transform: translate(-50%, -50%); }
    #joystick-stick.active { box-shadow: 0 2px 4px rgba(0,0,0,0.4), 0 0 15px rgba(201,162,39,0.5); }

    #action-buttons { position: absolute; bottom: var(--action-stack-bottom); right: 20px; display: flex; flex-direction: column; gap: 10px; pointer-events: auto; }
    .action-btn { width: 60px; height: 60px; border-radius: 50%; border: 3px solid var(--wood); font-size: 1.5rem; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.15s ease; box-shadow: 0 4px 8px rgba(0,0,0,0.4); }
    .action-btn:active { transform: scale(0.95); }
    #btn-dock { background: linear-gradient(180deg, var(--sea-light) 0%, var(--sea-medium) 100%); color: white; }
    #btn-dock.available { animation: pulse-dock 1.5s ease-in-out infinite; }
    @keyframes pulse-dock { 0%, 100% { box-shadow: 0 4px 8px rgba(0,0,0,0.4); } 50% { box-shadow: 0 4px 8px rgba(0,0,0,0.4), 0 0 0 10px rgba(74,138,154,0.3); } }
    #btn-map { background: linear-gradient(180deg, var(--parchment) 0%, var(--parchment-dark) 100%); color: var(--ink); }
    #btn-menu { background: linear-gradient(180deg, var(--gold) 0%, var(--gold-dark) 100%); color: var(--ink); }

    #speed-indicator { position: absolute; bottom: 150px; left: 30px; background: var(--card-bg); padding: 4px 10px; border-radius: 12px; font-family: var(--font-display); font-size: 0.7rem; box-shadow: var(--shadow-light); display: flex; align-items: center; gap: 5px; pointer-events: none; }
    #speed-indicator .bar { width: 40px; height: 6px; background: var(--parchment-dark); border-radius: 3px; overflow: hidden; }
    #speed-indicator .bar-fill { height: 100%; background: var(--gold); width: 0%; transition: width 0.2s; }
    .wind-boost { color: #1e7d34; font-size: 0.6rem; }
    .wind-penalty { color: var(--blood-red); font-size: 0.6rem; }

    /* Fixed: island indicator positioned above action buttons */
    #island-indicator { position: absolute; bottom: calc(var(--action-stack-bottom) + var(--action-stack-h) + 15px); right: 20px; background: var(--card-bg); padding: 6px 12px; border-radius: 8px; font-family: var(--font-display); font-size: 0.75rem; box-shadow: var(--shadow-light); text-align: right; pointer-events: none; opacity: 0; transition: opacity 0.3s; }
    #island-indicator.visible { opacity: 1; }

    #event-toast { position: fixed; top: 120px; left: 50%; transform: translateX(-50%); background: var(--card-bg); padding: var(--space-sm) var(--space-md); border-radius: 8px; display: flex; align-items: center; gap: var(--space-sm); box-shadow: var(--shadow); z-index: 20; animation: slideDown 0.3s var(--ease-out); max-width: calc(100% - 40px); }
    @keyframes slideDown { from { transform: translateX(-50%) translateY(-20px); opacity: 0; } to { transform: translateX(-50%) translateY(0); opacity: 1; } }
    .event-icon { font-size: 1.3rem; }
    .event-text { display: flex; flex-direction: column; }
    #event-title { font-family: var(--font-display); font-size: 0.85rem; }
    #event-desc { font-size: 0.75rem; color: var(--ink-light); }

    .modal { position: fixed; inset: 0; background: var(--modal-bg); display: flex; align-items: center; justify-content: center; padding: var(--space-sm); z-index: 100; animation: fadeIn 0.2s var(--ease-out); }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    .modal-content { background: var(--parchment); border-radius: 12px; width: 100%; max-width: 400px; max-height: 85vh; overflow-y: auto; position: relative; box-shadow: var(--shadow); }

    .modal-header { padding: var(--space-md); border-bottom: 2px solid var(--parchment-dark); position: relative; }
    .modal-header h2 { font-family: var(--font-display); font-size: 1.1rem; margin-bottom: var(--space-xs); padding-right: 30px; }
    .island-info { display: flex; gap: var(--space-xs); flex-wrap: wrap; }
    .faction-tag { font-size: 0.65rem; padding: 2px 6px; border-radius: 4px; background: var(--ink-light); color: var(--parchment); }
    .faction-tag.english { background: var(--english); }
    .faction-tag.eitc { background: var(--eitc); }
    .faction-tag.pirates { background: var(--pirates); }
    .faction-tag.neutral { background: var(--neutral); }
    .tariff-tag { font-size: 0.65rem; padding: 2px 6px; border-radius: 4px; background: var(--gold-dark); color: var(--parchment); }
    .modal-close { position: absolute; top: var(--space-sm); right: var(--space-sm); width: 32px; height: 32px; border: none; background: transparent; font-size: 1.3rem; cursor: pointer; color: var(--ink-light); }

    .trade-tabs { display: flex; border-bottom: 2px solid var(--parchment-dark); }
    .trade-tab { flex: 1; padding: var(--space-sm); background: transparent; border: none; font-family: var(--font-display); font-size: 0.75rem; cursor: pointer; color: var(--ink-light); position: relative; }
    .trade-tab.active { color: var(--ink); }
    .trade-tab.active::after { content: ''; position: absolute; bottom: -2px; left: 0; right: 0; height: 3px; background: var(--gold); }
    .trade-tab .tab-badge { display: inline-block; background: var(--blood-red); color: white; font-size: 0.55rem; padding: 1px 4px; border-radius: 8px; margin-left: 2px; vertical-align: top; }

    .trade-panel { padding: var(--space-sm); max-height: 40vh; overflow-y: auto; }
    .goods-list { display: flex; flex-direction: column; gap: var(--space-xs); }
    .good-item { display: grid; grid-template-columns: 1fr auto; grid-template-rows: auto auto; gap: 2px var(--space-sm); padding: var(--space-sm); background: rgba(255, 255, 255, 0.5); border-radius: 6px; border: 1px solid var(--parchment-dark); }
    .good-item.blocked { opacity: 0.6; }
    .good-info { display: flex; align-items: center; gap: var(--space-xs); }
    .good-icon { font-size: 1.2rem; }
    .good-name { font-family: var(--font-display); font-size: 0.85rem; }
    .good-price { font-weight: 600; color: var(--gold-dark); font-size: 0.85rem; }
    .price-trend { font-size: 0.75rem; margin-left: 2px; }
    .price-trend.up { color: #c41e3a; }
    .price-trend.down { color: #1e7d34; }
    .good-details { grid-column: 1; font-size: 0.7rem; color: var(--ink-light); }
    .good-actions { grid-column: 2; grid-row: 1 / 3; display: flex; align-items: center; gap: 4px; }
    .qty-btn { width: 36px; height: 36px; border: 2px solid var(--ink-light); border-radius: 6px; background: var(--parchment); font-size: 1.2rem; cursor: pointer; }
    .qty-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .qty-btn.sell { background: linear-gradient(180deg, #ffcccc 0%, #ffaaaa 100%); }
    .qty-btn.buy { background: linear-gradient(180deg, #ccffcc 0%, #aaffaa 100%); }
    .block-reason { color: var(--blood-red); font-size: 0.65rem; }

    .panel-actions { display: flex; gap: var(--space-xs); margin-bottom: var(--space-sm); }
    .panel-actions button { flex: 1; }

    .trade-footer { padding: var(--space-sm) var(--space-md); border-top: 2px solid var(--parchment-dark); display: flex; justify-content: space-between; align-items: center; }
    .player-stats { display: flex; gap: var(--space-md); font-size: 0.8rem; }

    /* Contract cards */
    .contract-card { background: rgba(255,255,255,0.6); border: 2px solid var(--parchment-dark); border-radius: 8px; padding: var(--space-sm); margin-bottom: var(--space-sm); }
    .contract-card.active { border-color: var(--gold); background: rgba(201,162,39,0.1); }
    .contract-card.tracked { border-color: var(--sea-medium); box-shadow: 0 0 8px rgba(74,138,154,0.4); }
    .contract-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: var(--space-xs); }
    .contract-type { font-size: 0.7rem; padding: 2px 6px; border-radius: 4px; background: var(--ink-light); color: var(--parchment); }
    .contract-type.delivery { background: var(--sea-medium); }
    .contract-type.smuggling { background: var(--blood-red); }
    .contract-type.courier { background: var(--gold-dark); }
    .contract-type.supply { background: #1e7d34; }
    .contract-type.faction { background: var(--pirates); }
    .contract-title { font-family: var(--font-display); font-size: 0.85rem; flex: 1; margin-right: var(--space-xs); }
    .contract-deadline { font-size: 0.7rem; color: var(--ink-light); }
    .contract-deadline.urgent { color: var(--blood-red); font-weight: 600; }
    .contract-details { font-size: 0.75rem; color: var(--ink-light); margin-bottom: var(--space-xs); }
    .contract-rewards { display: flex; gap: var(--space-sm); font-size: 0.75rem; margin-bottom: var(--space-xs); }
    .contract-reward { display: flex; align-items: center; gap: 2px; }
    .contract-reward.gold { color: var(--gold-dark); }
    .contract-reward.rep { color: var(--sea-medium); }
    .contract-actions { display: flex; gap: var(--space-xs); }
    .contract-actions button { flex: 1; }
    .contract-empty { text-align: center; color: var(--ink-light); padding: var(--space-lg); font-style: italic; }

    .logbook-section { margin-bottom: var(--space-md); }
    .logbook-section h4 { font-family: var(--font-display); font-size: 0.85rem; margin-bottom: var(--space-xs); color: var(--ink-light); }
    .island-select { width: 100%; padding: var(--space-sm); border: 2px solid var(--parchment-dark); border-radius: 6px; font-family: var(--font-body); background: white; margin-bottom: var(--space-sm); }
    .logbook-item { display: flex; justify-content: space-between; align-items: center; padding: var(--space-xs) var(--space-sm); background: rgba(255,255,255,0.5); border-radius: 4px; margin-bottom: 2px; font-size: 0.8rem; }
    .confidence-tag { font-size: 0.6rem; padding: 1px 4px; border-radius: 3px; margin-left: 4px; }
    .confidence-high { background: #1e7d34; color: white; }
    .confidence-med { background: var(--gold-dark); color: white; }
    .confidence-low { background: var(--ink-light); color: white; }

    .spotlight-card { background: linear-gradient(135deg, rgba(201,162,39,0.2) 0%, rgba(201,162,39,0.1) 100%); border: 2px solid var(--gold); border-radius: 8px; padding: var(--space-sm); margin-bottom: var(--space-sm); cursor: pointer; }
    .spotlight-card:hover { transform: translateY(-2px); box-shadow: var(--shadow-light); }
    .spotlight-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-xs); }
    .spotlight-good { font-family: var(--font-display); font-size: 0.9rem; }
    .spotlight-profit { color: #1e7d34; font-weight: 600; }
    .spotlight-route { font-size: 0.75rem; color: var(--ink-light); }
    .spotlight-empty { text-align: center; color: var(--ink-light); padding: var(--space-md); font-style: italic; }

    .upgrade-card { background: rgba(255,255,255,0.5); border: 2px solid var(--parchment-dark); border-radius: 8px; padding: var(--space-sm); margin-bottom: var(--space-sm); }
    .upgrade-card.owned { border-color: var(--gold); background: rgba(201,162,39,0.1); }
    .upgrade-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-xs); }
    .upgrade-name { font-family: var(--font-display); font-size: 0.9rem; }
    .upgrade-cost { color: var(--gold-dark); font-weight: 600; }
    .upgrade-desc { font-size: 0.75rem; color: var(--ink-light); margin-bottom: var(--space-xs); }
    .upgrade-stats { font-size: 0.65rem; display: flex; flex-wrap: wrap; gap: var(--space-xs); margin-bottom: var(--space-xs); }
    .upgrade-stat { padding: 2px 6px; border-radius: 4px; }
    .upgrade-stat.positive { background: rgba(30,125,52,0.2); color: #1e7d34; }
    .upgrade-stat.negative { background: rgba(139,37,0,0.2); color: var(--blood-red); }

    .menu-content { padding: var(--space-md); }
    .menu-content h2 { font-family: var(--font-display); text-align: center; margin-bottom: var(--space-md); }
    .menu-section { margin-bottom: var(--space-md); }
    .menu-section h3 { font-family: var(--font-display); font-size: 0.9rem; margin-bottom: var(--space-sm); color: var(--ink-light); }
    .reputation-bars { display: flex; flex-direction: column; gap: var(--space-sm); }
    .rep-item { display: grid; grid-template-columns: 1fr 1fr auto; align-items: center; gap: var(--space-xs); font-size: 0.75rem; }
    .rep-bar { height: 6px; background: var(--parchment-dark); border-radius: 3px; overflow: hidden; }
    .rep-fill { height: 100%; background: var(--gold); width: 50%; }
    .rep-fill.hostile { background: var(--blood-red); }
    .rep-fill.friendly { background: #1e7d34; }
    .ship-stats { background: rgba(255, 255, 255, 0.5); border-radius: 6px; padding: var(--space-sm); }
    .stat-row { display: flex; justify-content: space-between; padding: 3px 0; border-bottom: 1px solid var(--parchment-dark); font-size: 0.8rem; }
    .stat-row:last-child { border-bottom: none; }
    .risk-low { color: #1e7d34; }
    .risk-med { color: var(--gold-dark); }
    .risk-high { color: var(--blood-red); }
    .menu-buttons { display: flex; flex-direction: column; gap: var(--space-xs); margin-bottom: var(--space-md); }

    /* Titles section */
    .title-item { display: flex; justify-content: space-between; align-items: center; padding: var(--space-xs) var(--space-sm); background: rgba(255,255,255,0.5); border-radius: 4px; margin-bottom: 2px; font-size: 0.8rem; }
    .title-name { font-family: var(--font-display); }
    .title-tier { font-size: 0.65rem; padding: 2px 6px; border-radius: 4px; background: var(--gold); color: var(--ink); }
    .title-tier.tier-0 { background: var(--ink-light); color: var(--parchment); }
    .title-tier.tier-1 { background: #cd7f32; color: white; }
    .title-tier.tier-2 { background: #c0c0c0; color: var(--ink); }
    .title-tier.tier-3 { background: var(--gold); color: var(--ink); }
    .title-tier.tier-4 { background: #b9f2ff; color: var(--ink); }
    .title-tier.tier-5 { background: var(--blood-red); color: white; }
    .title-progress { font-size: 0.65rem; color: var(--ink-light); }

    .pirate-content, .encounter-content, .warning-content { padding: var(--space-lg); text-align: center; }
    .pirate-icon, .encounter-icon, .warning-icon { font-size: 3rem; margin-bottom: var(--space-sm); }
    .pirate-icon { animation: shake 0.5s ease-in-out infinite; }
    @keyframes shake { 0%, 100% { transform: rotate(-5deg); } 50% { transform: rotate(5deg); } }
    .pirate-content h2, .encounter-content h2, .warning-content h2 { font-family: var(--font-display); margin-bottom: var(--space-sm); }
    .pirate-content > p, .encounter-content > p, .warning-content > p { margin-bottom: var(--space-lg); color: var(--ink-light); }
    .pirate-options, .encounter-options { display: flex; flex-direction: column; gap: var(--space-sm); }
    .encounter-reward { background: rgba(30,125,52,0.1); border: 1px solid #1e7d34; border-radius: 6px; padding: var(--space-sm); margin-bottom: var(--space-md); }
    .encounter-penalty { background: rgba(139,37,0,0.1); border: 1px solid var(--blood-red); border-radius: 6px; padding: var(--space-sm); margin-bottom: var(--space-md); }

    .map-content { padding: var(--space-md); }
    .map-content h2 { font-family: var(--font-display); text-align: center; margin-bottom: var(--space-md); }
    #map-container { width: 100%; height: 250px; background: var(--sea-dark); border-radius: 8px; position: relative; overflow: hidden; }
    .map-island { position: absolute; width: 24px; height: 24px; border-radius: 50%; border: 2px solid var(--parchment); transform: translate(-50%, -50%); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 0.6rem; color: white; font-weight: bold; }
    .map-island:hover { transform: translate(-50%, -50%) scale(1.2); }
    .map-island.selected { box-shadow: 0 0 0 3px var(--gold), 0 0 10px var(--gold); }
    .map-island.english { background: var(--english); }
    .map-island.eitc { background: var(--eitc); }
    .map-island.pirates { background: var(--pirates); }
    .map-island.neutral { background: var(--neutral); }
    .map-player { position: absolute; width: 12px; height: 12px; background: var(--gold); border-radius: 50%; border: 2px solid white; transform: translate(-50%, -50%); box-shadow: 0 0 10px var(--gold); z-index: 5; }
    .map-course-line { position: absolute; height: 2px; background: var(--gold); transform-origin: left center; opacity: 0.6; z-index: 4; }
    .map-legend { display: flex; justify-content: center; gap: var(--space-md); margin-top: var(--space-sm); font-size: 0.7rem; flex-wrap: wrap; }
    .map-legend span { display: flex; align-items: center; gap: 4px; }
    .legend-dot { width: 10px; height: 10px; border-radius: 50%; }
    .map-buttons { display: flex; gap: var(--space-sm); margin-top: var(--space-md); }
    .map-buttons button { flex: 1; }
    .map-info { text-align: center; margin-top: var(--space-sm); font-size: 0.75rem; color: var(--ink-light); }

    @media (max-height: 500px) and (orientation: landscape) {
        :root { --action-stack-h: 160px; --action-stack-bottom: 10px; }
        #mobile-controls { height: 140px; }
        #joystick-zone { width: 100px; height: 100px; bottom: 10px; left: 10px; }
        #joystick-base { width: 100px; height: 100px; }
        #joystick-stick { width: 40px; height: 40px; }
        .action-btn { width: 50px; height: 50px; font-size: 1.2rem; }
        #action-buttons { bottom: var(--action-stack-bottom); right: 10px; gap: 8px; }
    }
</style>

</head>
<body>
    <div id="loading-screen"><div class="loading-content"><h1>Merchant Seas</h1><div class="loading-ship">â›µ</div><p>Charting the waters...</p><div class="loading-bar"><div class="loading-progress"></div></div></div></div>
<div id="faction-screen" class="screen hidden">
    <div class="screen-content">
        <h1>Choose Your Allegiance</h1>
        <p class="subtitle">Your faction determines advantages and difficulty</p>
        <div class="faction-cards">
            <button class="faction-card" data-faction="english"><div class="faction-icon">ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿</div><h2>Royal Navy</h2><span class="difficulty-tag difficulty-easy">Easy</span><p class="faction-desc">Servants of the Crown</p><ul class="faction-perks"><li>âœ¦ +25 Starting Reputation</li><li>âœ¦ 50% Less Pirate Encounters</li><li>âœ¦ Cheaper Tribute</li></ul></button>
            <button class="faction-card" data-faction="eitc"><div class="faction-icon">âš“</div><h2>Trading Company</h2><span class="difficulty-tag difficulty-medium">Medium</span><p class="faction-desc">Profit Above All</p><ul class="faction-perks"><li>âœ¦ +20% Cargo Capacity</li><li>âœ¦ Better Trade Prices</li><li>âœ¦ Enhanced Logbook Intel</li></ul></button>
            <button class="faction-card" data-faction="pirates"><div class="faction-icon">ğŸ´â€â˜ ï¸</div><h2>Brethren Court</h2><span class="difficulty-tag difficulty-hard">Hard</span><p class="faction-desc">Freedom of the Seas</p><ul class="faction-perks"><li>âœ¦ Contraband +50%</li><li>âœ¦ Faster Speed</li><li>âœ¦ More Encounters</li></ul></button>
        </div>
        <button id="continue-btn" class="btn-primary hidden">Set Sail</button>
    </div>
</div>

<div id="game-container" class="hidden">
    <canvas id="game-canvas"></canvas>
    <div id="hud-top">
        <div class="hud-item"><span class="hud-icon">ğŸª™</span><span class="hud-value" id="gold-value">1000</span></div>
        <div class="hud-item"><span class="hud-icon">ğŸ“…</span><span class="hud-value">Day <span id="day-value">1</span></span></div>
        <div class="hud-item"><span class="hud-icon">ğŸ–</span><span class="hud-value" id="supplies-value">30</span></div>
    </div>
    <div id="faction-badge"><span id="faction-icon">ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿</span><span id="faction-name">Royal Navy</span></div>
    <div id="cargo-summary"><div class="cargo-header"><span>ğŸ“¦ Cargo</span><span id="cargo-count">0/50</span></div><div id="cargo-preview"></div></div>
    <div id="wind-indicator"><span id="wind-arrow">ğŸ’¨</span><span id="wind-strength">Calm</span></div>
    <div id="heat-indicator" class="low"><span>ğŸ”¥</span><div class="heat-bar"><div class="heat-fill" id="heat-fill"></div></div><span id="heat-label">0</span></div>
    <div id="contract-tracker" class="hidden"><span>ğŸ“œ</span><span class="contract-title" id="tracker-title">--</span><span class="contract-meta" id="tracker-meta">--</span></div>
    <div id="world-indicator"><span id="world-icon">ğŸŒ¤ï¸</span><span id="world-status">Fair Winds</span></div>
    <div id="compass">
        <div class="compass-ring">
            <div class="compass-needle" id="compass-needle"></div>
            <div class="compass-dest-marker hidden" id="compass-dest-marker"></div>
            <span class="compass-n">N</span><span class="compass-e">E</span><span class="compass-s">S</span><span class="compass-w">W</span>
        </div>
        <div id="destination-info" class="hidden"><span id="dest-name">--</span><span id="dest-distance">--</span></div>
    </div>
    <div id="event-toast" class="hidden"><div class="event-icon">âš¡</div><div class="event-text"><strong id="event-title">Event</strong><span id="event-desc">Description</span></div></div>
    <div id="mobile-controls">
        <div id="joystick-zone"><div id="joystick-base"></div><div id="joystick-stick"></div></div>
        <div id="speed-indicator"><span>â›µ</span><div class="bar"><div class="bar-fill" id="speed-fill"></div></div><span id="wind-effect"></span></div>
        <div id="island-indicator"><div class="name" id="nearby-island-name">Port Royal</div><div class="faction" id="nearby-island-faction">English</div><div class="distance" id="nearby-island-dist">Nearby</div></div>
        <div id="action-buttons">
            <button class="action-btn" id="btn-dock">âš“</button>
            <button class="action-btn" id="btn-map">ğŸ—ºï¸</button>
            <button class="action-btn" id="btn-menu">â˜°</button>
        </div>
    </div>
</div>

<div id="trade-modal" class="modal hidden">
    <div class="modal-content">
        <div class="modal-header"><h2 id="trade-island-name">Port Royal</h2><div class="island-info"><span id="trade-island-faction" class="faction-tag">English</span><span id="trade-tariff" class="tariff-tag">No Tariff</span></div><button class="modal-close" id="close-trade">âœ•</button></div>
        <div class="trade-tabs">
            <button class="trade-tab active" data-tab="buy">Buy</button>
            <button class="trade-tab" data-tab="sell">Sell</button>
            <button class="trade-tab" data-tab="contracts">ğŸ“œ Jobs<span class="tab-badge hidden" id="contracts-badge">0</span></button>
            <button class="trade-tab" data-tab="logbook">ğŸ“– Log</button>
            <button class="trade-tab" data-tab="shipyard">ğŸ”§ Ship</button>
        </div>
        <div class="trade-panel" id="buy-panel"><div class="panel-actions"><button class="btn-secondary btn-small" id="buy-best-btn">ğŸ’° Buy Best</button></div><div class="goods-list" id="buy-goods-list"></div></div>
        <div class="trade-panel hidden" id="sell-panel"><div class="panel-actions"><button class="btn-secondary btn-small" id="sell-best-btn">ğŸ’° Sell Best</button></div><div class="goods-list" id="sell-goods-list"></div></div>
        <div class="trade-panel hidden" id="contracts-panel"><div class="logbook-section"><h4>ğŸ“‹ Available Contracts</h4><div id="available-contracts"></div></div><div class="logbook-section"><h4>ğŸ“Œ Active Contracts (<span id="active-count">0</span>/3)</h4><div id="active-contracts"></div></div></div>
        <div class="trade-panel hidden" id="logbook-panel"><div class="logbook-section"><h4>ğŸ’¡ Deal Spotlight</h4><div id="spotlight-list"></div></div><div class="logbook-section"><h4>ğŸ“œ Price History</h4><select class="island-select" id="logbook-island-select"></select><div id="logbook-prices"></div></div></div>
        <div class="trade-panel hidden" id="shipyard-panel"><div id="upgrades-list"></div></div>
        <div class="trade-footer"><div class="player-stats"><span>ğŸª™ <span id="trade-gold">1000</span></span><span>ğŸ“¦ <span id="trade-cargo">0/50</span></span></div><button class="btn-primary" id="leave-port-btn">Set Sail</button></div>
    </div>
</div>

<div id="map-modal" class="modal hidden">
    <div class="modal-content map-content">
        <h2>Navigation Chart</h2>
        <div id="map-container"></div>
        <div class="map-info" id="map-info">Click island to set course</div>
        <div class="map-legend"><span><div class="legend-dot" style="background:var(--english)"></div>English</span><span><div class="legend-dot" style="background:var(--eitc)"></div>EITC</span><span><div class="legend-dot" style="background:var(--pirates)"></div>Pirates</span><span><div class="legend-dot" style="background:var(--neutral)"></div>Neutral</span></div>
        <div class="map-buttons"><button class="btn-secondary" id="clear-course-btn">Clear Course</button><button class="btn-primary" id="close-map">Close</button></div>
    </div>
</div>

<div id="menu-modal" class="modal hidden">
    <div class="modal-content menu-content">
        <h2>Captain's Log</h2>
        <div class="menu-section"><h3>Reputation</h3><div class="reputation-bars"><div class="rep-item"><span>ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿ Navy</span><div class="rep-bar"><div class="rep-fill" id="rep-english"></div></div><span class="rep-value" id="rep-english-val">0</span></div><div class="rep-item"><span>âš“ EITC</span><div class="rep-bar"><div class="rep-fill" id="rep-eitc"></div></div><span class="rep-value" id="rep-eitc-val">0</span></div><div class="rep-item"><span>ğŸ´â€â˜ ï¸ Pirates</span><div class="rep-bar"><div class="rep-fill" id="rep-pirates"></div></div><span class="rep-value" id="rep-pirates-val">0</span></div></div></div>
        <div class="menu-section"><h3>Titles</h3><div id="titles-list"></div></div>
        <div class="menu-section"><h3>World Status</h3><div class="ship-stats"><div class="stat-row"><span>Season</span><span id="menu-season">Fair</span></div><div class="stat-row"><span>Crackdown</span><span id="menu-crackdown">None</span></div><div class="stat-row"><span>Regional Event</span><span id="menu-regional">None</span></div></div></div>
        <div class="menu-section"><h3>Ship</h3><div class="ship-stats"><div class="stat-row"><span>Speed</span><span id="ship-speed">1.0x</span></div><div class="stat-row"><span>Cargo</span><span id="ship-cargo-cap">50</span></div><div class="stat-row"><span>Supply/Day</span><span id="ship-supply-rate">1</span></div><div class="stat-row"><span>Upgrades</span><span id="ship-upgrades">None</span></div></div></div>
        <div class="menu-section"><h3>Wind & Risk</h3><div class="ship-stats"><div class="stat-row"><span>Wind</span><span id="menu-wind-dir">N Calm</span></div><div class="stat-row"><span>Wind Change</span><span id="menu-wind-change">5d</span></div><div class="stat-row"><span>Route Risk</span><span id="menu-route-risk">Low</span></div><div class="stat-row"><span>Heat</span><span id="menu-heat">0</span></div></div></div>
        <div class="menu-buttons"><button class="btn-secondary" id="save-btn">ğŸ’¾ Save</button><button class="btn-secondary" id="new-game-btn">ğŸ”„ New Game</button></div>
        <button class="btn-primary" id="close-menu">Continue</button>
    </div>
</div>

<div id="pirate-modal" class="modal hidden"><div class="modal-content pirate-content"><div class="pirate-icon">ğŸ´â€â˜ ï¸</div><h2>Pirates!</h2><p>They demand tribute!</p><div class="pirate-options"><button class="btn-danger" id="pay-tribute">ğŸ’° Pay <small id="tribute-cost">100g</small></button><button class="btn-secondary" id="fight-pirates">âš”ï¸ Fight</button><button class="btn-primary hidden" id="pirate-pass">ğŸ´â€â˜ ï¸ Parley</button></div></div></div>

<div id="encounter-modal" class="modal hidden"><div class="modal-content encounter-content"><div class="encounter-icon" id="encounter-icon">ğŸŒŠ</div><h2 id="encounter-title">Event</h2><p id="encounter-desc">Description</p><div id="encounter-result"></div><div class="encounter-options" id="encounter-options"></div></div></div>

<div id="warning-modal" class="modal hidden"><div class="modal-content warning-content"><div class="warning-icon" id="warning-icon">âš ï¸</div><h2 id="warning-title">Warning</h2><p id="warning-text">Message</p><button class="btn-primary" id="warning-dismiss">Continue</button></div></div>

<div id="title-modal" class="modal hidden"><div class="modal-content warning-content"><div class="warning-icon" id="title-icon">ğŸ†</div><h2 id="title-earned-name">Title Earned!</h2><p id="title-earned-desc">You have proven yourself worthy.</p><button class="btn-primary" id="title-dismiss">Continue</button></div></div>

<script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"}}</script>
<script type="module">

import * as THREE from 'three';

// ==================== CONFIG ====================
const CONFIG = {
goods: {
rum: { name: 'Rum', basePrice: 25, category: 'commodity', weight: 1, icon: 'ğŸº' },
sugar: { name: 'Sugar', basePrice: 15, category: 'commodity', weight: 2, icon: 'ğŸ§‚' },
tobacco: { name: 'Tobacco', basePrice: 30, category: 'commodity', weight: 1, icon: 'ğŸŒ¿' },
spices: { name: 'Spices', basePrice: 60, category: 'luxury', weight: 1, icon: 'ğŸŒ¶ï¸' },
tea: { name: 'Tea', basePrice: 45, category: 'luxury', weight: 1, icon: 'ğŸµ' },
silk: { name: 'Silk', basePrice: 80, category: 'luxury', weight: 1, icon: 'ğŸ§µ' },
gunpowder: { name: 'Gunpowder', basePrice: 50, category: 'contraband', weight: 2, icon: 'ğŸ’¥' },
timber: { name: 'Timber', basePrice: 20, category: 'commodity', weight: 3, icon: 'ğŸªµ' },
iron: { name: 'Iron', basePrice: 35, category: 'commodity', weight: 3, icon: 'âš™ï¸' },
gold: { name: 'Gold', basePrice: 150, category: 'luxury', weight: 1, icon: 'ğŸª™' }
},
islands: {
portRoyal: { name: 'Port Royal', position: { x: 0, z: 0 }, faction: 'english', color: 0x2d5016, markets: { rum: { preference: 'exports', targetSupply: 80, targetDemand: 30 }, sugar: { preference: 'exports', targetSupply: 100, targetDemand: 20 }, tobacco: { preference: 'neutral', targetSupply: 50, targetDemand: 50 }, spices: { preference: 'imports', targetSupply: 20, targetDemand: 60 }, tea: { preference: 'imports', targetSupply: 30, targetDemand: 70 }, silk: { preference: 'imports', targetSupply: 15, targetDemand: 50 }, gunpowder: { preference: 'neutral', targetSupply: 40, targetDemand: 40 }, timber: { preference: 'exports', targetSupply: 70, targetDemand: 30 }, iron: { preference: 'imports', targetSupply: 25, targetDemand: 55 }, gold: { preference: 'imports', targetSupply: 10, targetDemand: 40 } } },
tortuga: { name: 'Tortuga', position: { x: 150, z: -80 }, faction: 'pirates', color: 0x4a3728, markets: { rum: { preference: 'imports', targetSupply: 30, targetDemand: 90 }, sugar: { preference: 'neutral', targetSupply: 40, targetDemand: 40 }, tobacco: { preference: 'imports', targetSupply: 20, targetDemand: 70 }, spices: { preference: 'neutral', targetSupply: 30, targetDemand: 30 }, tea: { preference: 'neutral', targetSupply: 20, targetDemand: 20 }, silk: { preference: 'imports', targetSupply: 10, targetDemand: 50 }, gunpowder: { preference: 'exports', targetSupply: 90, targetDemand: 20 }, timber: { preference: 'imports', targetSupply: 25, targetDemand: 60 }, iron: { preference: 'imports', targetSupply: 20, targetDemand: 55 }, gold: { preference: 'exports', targetSupply: 60, targetDemand: 30 } } },
nassau: { name: 'Nassau', position: { x: -120, z: -150 }, faction: 'pirates', color: 0x5c4a32, markets: { rum: { preference: 'exports', targetSupply: 70, targetDemand: 30 }, sugar: { preference: 'exports', targetSupply: 60, targetDemand: 25 }, tobacco: { preference: 'exports', targetSupply: 80, targetDemand: 20 }, spices: { preference: 'imports', targetSupply: 15, targetDemand: 55 }, tea: { preference: 'imports', targetSupply: 10, targetDemand: 45 }, silk: { preference: 'imports', targetSupply: 10, targetDemand: 40 }, gunpowder: { preference: 'exports', targetSupply: 75, targetDemand: 30 }, timber: { preference: 'exports', targetSupply: 90, targetDemand: 20 }, iron: { preference: 'imports', targetSupply: 20, targetDemand: 60 }, gold: { preference: 'neutral', targetSupply: 25, targetDemand: 25 } } },
havana: { name: 'Havana', position: { x: -80, z: 100 }, faction: 'neutral', color: 0x3d6b2e, markets: { rum: { preference: 'exports', targetSupply: 85, targetDemand: 25 }, sugar: { preference: 'exports', targetSupply: 95, targetDemand: 15 }, tobacco: { preference: 'exports', targetSupply: 90, targetDemand: 20 }, spices: { preference: 'neutral', targetSupply: 40, targetDemand: 40 }, tea: { preference: 'imports', targetSupply: 15, targetDemand: 60 }, silk: { preference: 'imports', targetSupply: 10, targetDemand: 55 }, gunpowder: { preference: 'imports', targetSupply: 20, targetDemand: 70 }, timber: { preference: 'neutral', targetSupply: 50, targetDemand: 50 }, iron: { preference: 'imports', targetSupply: 25, targetDemand: 65 }, gold: { preference: 'exports', targetSupply: 45, targetDemand: 35 } } },
kingston: { name: 'Kingston', position: { x: 100, z: 120 }, faction: 'english', color: 0x4a7a3a, markets: { rum: { preference: 'neutral', targetSupply: 50, targetDemand: 50 }, sugar: { preference: 'exports', targetSupply: 75, targetDemand: 30 }, tobacco: { preference: 'exports', targetSupply: 65, targetDemand: 35 }, spices: { preference: 'exports', targetSupply: 70, targetDemand: 25 }, tea: { preference: 'imports', targetSupply: 20, targetDemand: 65 }, silk: { preference: 'imports', targetSupply: 15, targetDemand: 50 }, gunpowder: { preference: 'neutral', targetSupply: 35, targetDemand: 35 }, timber: { preference: 'imports', targetSupply: 30, targetDemand: 60 }, iron: { preference: 'imports', targetSupply: 25, targetDemand: 55 }, gold: { preference: 'imports', targetSupply: 15, targetDemand: 45 } } },
barbados: { name: 'Barbados', position: { x: 200, z: 50 }, faction: 'eitc', color: 0x5a8a4a, markets: { rum: { preference: 'exports', targetSupply: 90, targetDemand: 20 }, sugar: { preference: 'exports', targetSupply: 95, targetDemand: 15 }, tobacco: { preference: 'neutral', targetSupply: 45, targetDemand: 45 }, spices: { preference: 'neutral', targetSupply: 40, targetDemand: 40 }, tea: { preference: 'imports', targetSupply: 20, targetDemand: 70 }, silk: { preference: 'imports', targetSupply: 15, targetDemand: 60 }, gunpowder: { preference: 'imports', targetSupply: 25, targetDemand: 55 }, timber: { preference: 'imports', targetSupply: 30, targetDemand: 55 }, iron: { preference: 'imports', targetSupply: 20, targetDemand: 60 }, gold: { preference: 'imports', targetSupply: 10, targetDemand: 50 } } },
cartagena: { name: 'Cartagena', position: { x: -180, z: -50 }, faction: 'neutral', color: 0x6a5a3a, markets: { rum: { preference: 'imports', targetSupply: 30, targetDemand: 60 }, sugar: { preference: 'neutral', targetSupply: 45, targetDemand: 45 }, tobacco: { preference: 'imports', targetSupply: 25, targetDemand: 55 }, spices: { preference: 'exports', targetSupply: 65, targetDemand: 30 }, tea: { preference: 'neutral', targetSupply: 35, targetDemand: 35 }, silk: { preference: 'exports', targetSupply: 55, targetDemand: 30 }, gunpowder: { preference: 'imports', targetSupply: 20, targetDemand: 70 }, timber: { preference: 'neutral', targetSupply: 50, targetDemand: 50 }, iron: { preference: 'exports', targetSupply: 60, targetDemand: 35 }, gold: { preference: 'exports', targetSupply: 70, targetDemand: 20 } } }
},
factions: {
english: { name: 'Royal Navy', icon: 'ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿', taxRate: 0.05, startingRep: { english: 25, eitc: 0, pirates: -25 }, pirateChanceMult: 0.5, tributeMult: 0.7 },
eitc: { name: 'Trading Co.', icon: 'âš“', taxRate: 0, startingRep: { english: 0, eitc: 25, pirates: -15 }, cargoBonus: 0.2, priceBonus: 0.05, logbookBonus: true },
pirates: { name: 'Brethren', icon: 'ğŸ´â€â˜ ï¸', taxRate: 0, startingRep: { english: -30, eitc: -20, pirates: 50 }, contrabandBonus: 0.5, speedBonus: 0.2, pirateChanceMult: 1.3 }
},
// UPGRADES with real tradeoffs - pros array for positive effects, cons array for negative
upgrades: {
swiftSails: {
name: 'Swift Sails', cost: 600, icon: 'ğŸ',
desc: 'Better wind usage but fragile rigging needs more upkeep',
pros: ['+30% wind bonus'],
cons: ['+0.5 supplies/day'],
effects: { windBonus: 0.3, supplyCostExtra: 0.5 }
},
reinforcedHold: {
name: 'Reinforced Hold', cost: 750, icon: 'ğŸ›¡ï¸',
desc: 'Protects cargo in fights but weighs down the ship',
pros: ['50% cargo protection'],
cons: ['-10% speed', '-5 cargo capacity'],
effects: { cargoProtection: 0.5, speedPenalty: 0.1, capacityPenalty: 5 }
},
luxuryLocker: {
name: 'Luxury Locker', cost: 500, icon: 'ğŸ’',
desc: 'Specialized storage for delicate luxury goods',
pros: ['+8 luxury capacity'],
cons: ['-3 commodity capacity'],
effects: { luxuryCapBonus: 8, commodityCapPenalty: 3 }
},
smugglerCompartments: {
name: 'Smuggler Compartments', cost: 650, icon: 'ğŸ•³ï¸',
desc: 'Hidden spaces reduce inspection risk but take room',
pros: ['-50% inspection chance', '+10% contraband profit'],
cons: ['-4 total capacity', '+0.25 supplies/day'],
effects: { inspectionReduction: 0.5, contrabandProfitBonus: 0.1, capacityPenalty: 4, supplyCostExtra: 0.25 }
},
vault: {
name: 'Iron Vault', cost: 900, icon: 'ğŸ”’',
desc: 'Protects wealth from pirates but heavy and expensive',
pros: ['-40% tribute cost', '-30% gold loss in fights'],
cons: ['-8% speed', '-3 capacity'],
effects: { tributeReduction: 0.4, goldProtection: 0.3, speedPenalty: 0.08, capacityPenalty: 3 }
}
},
// TITLES - endless progression tiers
titles: {
merchant: {
    name: 'Merchant',
    icon: 'ğŸ’°',
    thresholds: [500, 2000, 5000, 15000, 50000], // net worth
    tierNames: ['Peddler', 'Trader', 'Merchant', 'Magnate', 'Tycoon', 'Legend'],
    effects: { repGainMult: 0.02 } // +2% per tier
},
smuggler: {
    name: 'Smuggler',
    icon: 'ğŸ´â€â˜ ï¸',
    thresholds: [5, 20, 50, 100, 200], // lifetime contraband traded
    tierNames: ['Runner', 'Smuggler', 'Kingpin', 'Shadow Lord', 'Ghost', 'Phantom'],
    effects: { repLossReduction: 0.04, tributeReduction: 0.03 } // per tier
},
voyager: {
    name: 'Voyager',
    icon: 'ğŸ§­',
    thresholds: [10, 30, 75, 150, 300], // days sailed
    tierNames: ['Deckhand', 'Sailor', 'Voyager', 'Navigator', 'Admiral', 'Legend'],
    effects: { inspectionReduction: 0.02 } // per tier
}
},
// CONTRACT TYPES
contractTypes: {
delivery: { name: 'Delivery', icon: 'ğŸ“¦', baseReward: 100, repReward: 5, riskMult: 1.0 },
smuggling: { name: 'Smuggling', icon: 'ğŸ´â€â˜ ï¸', baseReward: 200, repReward: -5, riskMult: 1.8, heatGain: 15 },
courier: { name: 'Courier', icon: 'âœ‰ï¸', baseReward: 80, repReward: 8, riskMult: 0.8 },
supply: { name: 'Supply Run', icon: 'ğŸ–', baseReward: 60, repReward: 3, riskMult: 0.6 },
faction: { name: 'Faction Work', icon: 'âš”ï¸', baseReward: 50, repReward: 15, riskMult: 1.2 }
},
events: [
{ id: 'festival', name: 'Festival', desc: 'Luxury demand up!', duration: 3, affects: ['luxury'], multiplier: 1.5 },
{ id: 'shortage', name: 'Shortage', desc: 'Prices up!', duration: 4, affects: ['commodity'], multiplier: 1.4 },
{ id: 'surplus', name: 'Surplus', desc: 'Prices down!', duration: 3, affects: ['commodity'], multiplier: 0.7 }
],
// REGIONAL EVENTS for living world
regionalEvents: [
{ id: 'trade_boom', name: 'Trade Boom', desc: 'All prices up 20%', duration: 5, categoryMult: { commodity: 1.2, luxury: 1.2, contraband: 1.1 } },
{ id: 'pirate_activity', name: 'Pirate Activity', desc: 'Contraband prices soar', duration: 4, categoryMult: { commodity: 1.0, luxury: 1.0, contraband: 1.5 } },
{ id: 'naval_blockade', name: 'Naval Blockade', desc: 'Commodity shortage', duration: 4, categoryMult: { commodity: 1.4, luxury: 1.1, contraband: 0.8 } },
{ id: 'merchant_fair', name: 'Merchant Fair', desc: 'Luxury demand high', duration: 3, categoryMult: { commodity: 0.9, luxury: 1.4, contraband: 1.0 } }
],
encounters: {
storm: { name: 'Storm!', icon: 'ğŸŒŠ', desc: 'A violent storm approaches!', baseChance: 0.04 },
adriftMerchant: { name: 'Adrift Merchant', icon: 'ğŸš¢', desc: 'A merchant offers a trade.', baseChance: 0.03 },
wreckSalvage: { name: 'Wreckage', icon: 'âš“', desc: 'Floating debris. Investigate?', baseChance: 0.03 },
inspection: { name: 'Inspection!', icon: 'ğŸ”', desc: 'Naval patrol demands to search your vessel!', baseChance: 0.05 }
},
settings: {
startingGold: 1000, startingSupplies: 30, baseCargoCapacity: 50, baseShipSpeed: 1.0,
baseSupplyRate: 1, dockDistance: 35, islandCollisionRadius: 25,
pirateEncounterChance: 0.08, windChangeDays: 5,
heatDecayPerDay: 2, heatGainContraband: 8, heatGainDockEnglishEITC: 5,
highMarginThreshold: 15, // minimum profit/weight to glow
maxActiveContracts: 3, contractBoardSize: 5, contractRefreshDays: 3,
seasonCycleDays: 20, stormSeasonStart: 13, stormSeasonEnd: 18,
crackdownDecayPerDay: 2, crackdownMaxLevel: 100
}
};

const WIND_DIRS = [
{ name: 'N', angle: 0, v: { x: 0, z: -1 } }, { name: 'NE', angle: 45, v: { x: 0.7, z: -0.7 } },
{ name: 'E', angle: 90, v: { x: 1, z: 0 } }, { name: 'SE', angle: 135, v: { x: 0.7, z: 0.7 } },
{ name: 'S', angle: 180, v: { x: 0, z: 1 } }, { name: 'SW', angle: 225, v: { x: -0.7, z: 0.7 } },
{ name: 'W', angle: 270, v: { x: -1, z: 0 } }, { name: 'NW', angle: 315, v: { x: -0.7, z: -0.7 } }
];
const WIND_STR = [{ name: 'Calm', m: 0 }, { name: 'Light', m: 0.15 }, { name: 'Moderate', m: 0.25 }, { name: 'Strong', m: 0.4 }];

// ==================== TITLE SYSTEM ====================
function getTitleTier(trackId, gs) {
    const track = CONFIG.titles[trackId];
    if (!track) return 0;
    const value = getTitleTrackValue(trackId, gs);
    let tier = 0;
    for (let i = 0; i < track.thresholds.length; i++) {
        if (value >= track.thresholds[i]) tier = i + 1;
        else break;
    }
    // Beyond last threshold: scale infinitely
    if (tier >= track.thresholds.length) {
        const lastThreshold = track.thresholds[track.thresholds.length - 1];
        const extraTiers = Math.floor((value - lastThreshold) / (lastThreshold * 0.5));
        tier = track.thresholds.length + extraTiers;
    }
    return tier;
}

function getTitleTrackValue(trackId, gs) {
    switch (trackId) {
        case 'merchant': return getNetWorth(gs);
        case 'smuggler': return gs.player.stats?.contrabandTraded || 0;
        case 'voyager': return gs.player.days || 0;
        default: return 0;
    }
}

function getTitleName(trackId, tier) {
    const track = CONFIG.titles[trackId];
    if (!track) return 'Unknown';
    if (tier < track.tierNames.length) return track.tierNames[tier];
    return track.tierNames[track.tierNames.length - 1] + ' ' + (tier - track.tierNames.length + 2);
}

function getNextThreshold(trackId, gs) {
    const track = CONFIG.titles[trackId];
    if (!track) return null;
    const value = getTitleTrackValue(trackId, gs);
    for (const t of track.thresholds) {
        if (value < t) return t;
    }
    // Beyond last: calculate next scaling threshold
    const lastThreshold = track.thresholds[track.thresholds.length - 1];
    const extraTiers = Math.floor((value - lastThreshold) / (lastThreshold * 0.5)) + 1;
    return lastThreshold + extraTiers * (lastThreshold * 0.5);
}

function getTitleModifiers(gs) {
    const mods = {
        repGainMult: 1.0,      // Multiplier for rep gains
        repLossReduction: 0,   // % reduction in rep losses
        inspectionReduction: 0, // % reduction in inspection chance
        tributeReduction: 0,   // % reduction in tribute costs
        tariffReduction: 0     // % reduction in tariffs
    };

    for (const [trackId, track] of Object.entries(CONFIG.titles)) {
        const tier = getTitleTier(trackId, gs);
        if (tier > 0 && track.effects) {
            if (track.effects.repGainMult) mods.repGainMult += track.effects.repGainMult * tier;
            if (track.effects.repLossReduction) mods.repLossReduction += track.effects.repLossReduction * tier;
            if (track.effects.inspectionReduction) mods.inspectionReduction += track.effects.inspectionReduction * tier;
            if (track.effects.tributeReduction) mods.tributeReduction += track.effects.tributeReduction * tier;
            if (track.effects.tariffReduction) mods.tariffReduction += track.effects.tariffReduction * tier;
        }
    }

    // Faction standing bonuses
    for (const faction of ['english', 'eitc', 'pirates']) {
        const rep = gs.player.reputation[faction] || 0;
        if (rep > 50) mods.tariffReduction += 0.05; // High standing = better tariffs
    }

    // Cap modifiers
    mods.repLossReduction = Math.min(0.5, mods.repLossReduction); // Max 50% reduction
    mods.inspectionReduction = Math.min(0.5, mods.inspectionReduction);
    mods.tributeReduction = Math.min(0.4, mods.tributeReduction);
    mods.tariffReduction = Math.min(0.2, mods.tariffReduction);

    return mods;
}

function updateTitles(gs, showToast = null) {
    if (!gs.player.titles) gs.player.titles = {};

    for (const trackId of Object.keys(CONFIG.titles)) {
        const oldTier = gs.player.titles[trackId] || 0;
        const newTier = getTitleTier(trackId, gs);

        if (newTier > oldTier) {
            gs.player.titles[trackId] = newTier;
            if (showToast) {
                const track = CONFIG.titles[trackId];
                showToast(track.icon, getTitleName(trackId, newTier), `${track.name} title earned!`);
            }
        }
    }
}

// ==================== REPUTATION SYSTEM ====================
function applyRepChange(gs, faction, delta, source = null) {
    const mods = getTitleModifiers(gs);

    // Apply modifiers
    if (delta > 0) {
        delta = Math.round(delta * mods.repGainMult);
    } else if (delta < 0) {
        delta = Math.round(delta * (1 - mods.repLossReduction));
    }

    // Apply change with clamping
    const oldRep = gs.player.reputation[faction] || 0;
    gs.player.reputation[faction] = Math.max(-100, Math.min(100, oldRep + delta));

    // Track stats
    if (!gs.player.stats) gs.player.stats = {};
    if (!gs.player.stats.repChanges) gs.player.stats.repChanges = {};
    if (!gs.player.stats.repChanges[faction]) gs.player.stats.repChanges[faction] = { gained: 0, lost: 0 };

    if (delta > 0) gs.player.stats.repChanges[faction].gained += delta;
    else if (delta < 0) gs.player.stats.repChanges[faction].lost += Math.abs(delta);

    return gs.player.reputation[faction] - oldRep;
}

// ==================== CONTRACT SYSTEM ====================
let contractIdCounter = 1;

function generateContractId() {
    return 'c_' + (contractIdCounter++) + '_' + Date.now().toString(36);
}

function generateContractsForIsland(gs, iid) {
    const contracts = [];
    const island = CONFIG.islands[iid];
    if (!island) return contracts;

    const numContracts = 3 + Math.floor(Math.random() * (CONFIG.settings.contractBoardSize - 2));
    const otherIslands = Object.keys(CONFIG.islands).filter(id => id !== iid);

    for (let i = 0; i < numContracts; i++) {
        const destId = otherIslands[Math.floor(Math.random() * otherIslands.length)];
        const dest = CONFIG.islands[destId];
        const dist = getIslandDistance(island.position, dest.position);
        const baseDays = Math.ceil(dist / 30);

        // Pick contract type based on island faction
        const types = ['delivery', 'courier', 'supply'];
        if (island.faction === 'pirates' || dest.faction === 'pirates') types.push('smuggling', 'smuggling');
        if (island.faction !== 'neutral') types.push('faction');

        const typeId = types[Math.floor(Math.random() * types.length)];
        const type = CONFIG.contractTypes[typeId];

        // Calculate rewards based on distance, urgency, risk
        const urgency = 0.8 + Math.random() * 0.4; // 0.8-1.2
        const deadline = Math.max(2, Math.floor(baseDays * (1.5 + (1 - urgency) * 2)));
        const riskFactor = type.riskMult * (1 + getRouteRiskBetween(gs, iid, destId) * 0.5);

        let goldReward = Math.floor(type.baseReward * (1 + dist / 100) * riskFactor * urgency);
        let repReward = type.repReward;
        let repFaction = island.faction !== 'neutral' ? island.faction : (Math.random() > 0.5 ? 'english' : 'eitc');

        // Contract-specific requirements
        let requirement = null;
        let goodId = null;
        let qty = 0;

        if (typeId === 'delivery') {
            const goods = Object.keys(CONFIG.goods).filter(g => CONFIG.goods[g].category !== 'contraband');
            goodId = goods[Math.floor(Math.random() * goods.length)];
            qty = 3 + Math.floor(Math.random() * 8);
            requirement = { type: 'deliver', goodId, qty };
        } else if (typeId === 'smuggling') {
            goodId = 'gunpowder';
            qty = 2 + Math.floor(Math.random() * 5);
            requirement = { type: 'deliver', goodId, qty };
            repFaction = 'pirates';
            goldReward = Math.floor(goldReward * 1.5);
        } else if (typeId === 'courier') {
            requirement = { type: 'reach', noInspection: Math.random() > 0.5 };
        } else if (typeId === 'supply') {
            requirement = { type: 'supplies', minSupplies: 10 + Math.floor(Math.random() * 10) };
        } else if (typeId === 'faction') {
            requirement = { type: 'reach' };
            goldReward = Math.floor(goldReward * 0.6);
            repReward = Math.floor(repReward * 1.5);
        }

        contracts.push({
            id: generateContractId(),
            typeId,
            title: generateContractTitle(typeId, goodId, dest.name),
            fromIsland: iid,
            toIsland: destId,
            deadline,
            requirement,
            rewards: { gold: goldReward, rep: repReward, repFaction },
            dayAccepted: null,
            status: 'available'
        });
    }

    return contracts;
}

function generateContractTitle(typeId, goodId, destName) {
    const good = goodId ? CONFIG.goods[goodId] : null;
    switch (typeId) {
        case 'delivery': return `Deliver ${good?.name || 'goods'} to ${destName}`;
        case 'smuggling': return `Smuggle cargo to ${destName}`;
        case 'courier': return `Urgent dispatch to ${destName}`;
        case 'supply': return `Supply run to ${destName}`;
        case 'faction': return `Official business at ${destName}`;
        default: return `Contract to ${destName}`;
    }
}

function getIslandDistance(pos1, pos2) {
    return Math.sqrt((pos1.x - pos2.x) ** 2 + (pos1.z - pos2.z) ** 2);
}

function getRouteRiskBetween(gs, fromId, toId) {
    const from = CONFIG.islands[fromId];
    const to = CONFIG.islands[toId];
    let risk = 0;
    if (to.faction === 'pirates') risk += 0.3;
    if (from.faction === 'pirates') risk += 0.2;
    return Math.min(1, risk);
}

function acceptContract(gs, contractId) {
    const active = gs.player.contracts.active || [];
    if (active.length >= CONFIG.settings.maxActiveContracts) return false;

    // Find contract in any board
    for (const iid of Object.keys(gs.world.boards)) {
        const board = gs.world.boards[iid];
        const idx = board.contracts.findIndex(c => c.id === contractId);
        if (idx !== -1) {
            const contract = board.contracts.splice(idx, 1)[0];
            contract.dayAccepted = gs.player.days;
            contract.status = 'active';
            active.push(contract);
            gs.player.contracts.active = active;
            return true;
        }
    }
    return false;
}

function abandonContract(gs, contractId) {
    const idx = gs.player.contracts.active.findIndex(c => c.id === contractId);
    if (idx === -1) return false;

    const contract = gs.player.contracts.active.splice(idx, 1)[0];
    contract.status = 'abandoned';
    gs.player.contracts.failed.push(contract);

    // Small rep penalty
    applyRepChange(gs, contract.rewards.repFaction, -3, 'abandon_contract');

    if (gs.player.trackedContractId === contractId) {
        gs.player.trackedContractId = null;
    }

    return true;
}

function evaluateContractsOnDock(gs, iid) {
    const completed = [];
    const toRemove = [];

    for (const contract of gs.player.contracts.active) {
        if (contract.toIsland !== iid) continue;

        let success = false;
        const req = contract.requirement;

        if (req.type === 'deliver') {
            const have = gs.player.cargo[req.goodId] || 0;
            if (have >= req.qty) {
                gs.player.cargo[req.goodId] = have - req.qty;
                if (gs.player.cargo[req.goodId] <= 0) delete gs.player.cargo[req.goodId];
                success = true;

                // Track contraband for smuggler title
                if (CONFIG.goods[req.goodId]?.category === 'contraband') {
                    if (!gs.player.stats) gs.player.stats = {};
                    gs.player.stats.contrabandTraded = (gs.player.stats.contrabandTraded || 0) + req.qty;
                }
            }
        } else if (req.type === 'reach') {
            if (req.noInspection && gs.player.inspectionTriggeredThisContract) {
                success = false;
            } else {
                success = true;
            }
        } else if (req.type === 'supplies') {
            if (gs.player.supplies >= req.minSupplies) {
                success = true;
            }
        } else {
            success = true;
        }

        if (success) {
            completed.push(contract);
            toRemove.push(contract.id);
        }
    }

    // Remove completed from active
    gs.player.contracts.active = gs.player.contracts.active.filter(c => !toRemove.includes(c.id));

    // Award rewards
    for (const contract of completed) {
        gs.player.gold += contract.rewards.gold;
        applyRepChange(gs, contract.rewards.repFaction, contract.rewards.rep, 'contract_complete');
        contract.status = 'completed';
        gs.player.contracts.completed.push(contract);

        // Track stats
        if (!gs.player.stats) gs.player.stats = {};
        gs.player.stats.contractsCompleted = (gs.player.stats.contractsCompleted || 0) + 1;

        // Smuggling increases crackdown
        if (contract.typeId === 'smuggling') {
            gs.world.crackdown.level = Math.min(
                CONFIG.settings.crackdownMaxLevel,
                (gs.world.crackdown.level || 0) + 15
            );
        }

        if (gs.player.trackedContractId === contract.id) {
            gs.player.trackedContractId = null;
        }
    }

    return completed;
}

function expireContracts(gs) {
    const expired = [];
    const toRemove = [];

    for (const contract of gs.player.contracts.active) {
        const daysElapsed = gs.player.days - contract.dayAccepted;
        if (daysElapsed > contract.deadline) {
            expired.push(contract);
            toRemove.push(contract.id);
        }
    }

    gs.player.contracts.active = gs.player.contracts.active.filter(c => !toRemove.includes(c.id));

    for (const contract of expired) {
        contract.status = 'failed';
        gs.player.contracts.failed.push(contract);
        applyRepChange(gs, contract.rewards.repFaction, -Math.abs(contract.rewards.rep), 'contract_failed');

        if (gs.player.trackedContractId === contract.id) {
            gs.player.trackedContractId = null;
        }
    }

    return expired;
}

function getTrackedContract(gs) {
    if (!gs.player.trackedContractId) return null;
    return gs.player.contracts.active.find(c => c.id === gs.player.trackedContractId);
}

function refreshContractBoard(gs, iid) {
    if (!gs.world.boards) gs.world.boards = {};

    const board = gs.world.boards[iid];
    const shouldRefresh = !board ||
        (gs.player.days - board.dayGenerated) >= CONFIG.settings.contractRefreshDays ||
        board.contracts.length === 0;

    if (shouldRefresh) {
        gs.world.boards[iid] = {
            dayGenerated: gs.player.days,
            contracts: generateContractsForIsland(gs, iid)
        };
    }

    return gs.world.boards[iid];
}

// ==================== LIVING WORLD SYSTEM ====================
function tickWorldStatePerDay(gs) {
    if (!gs.world) gs.world = {};

    // Season cycle
    gs.world.seasonDay = ((gs.world.seasonDay || 1) % CONFIG.settings.seasonCycleDays) + 1;

    // Crackdown decay
    if (gs.world.crackdown) {
        gs.world.crackdown.level = Math.max(0, (gs.world.crackdown.level || 0) - CONFIG.settings.crackdownDecayPerDay);
    }

    // Regional event management
    if (gs.world.regionalEvent) {
        gs.world.regionalEvent.daysRemaining--;
        if (gs.world.regionalEvent.daysRemaining <= 0) {
            gs.world.regionalEvent = null;
        }
    }

    // Chance to spawn new regional event
    if (!gs.world.regionalEvent && Math.random() < 0.05) {
        const event = CONFIG.regionalEvents[Math.floor(Math.random() * CONFIG.regionalEvents.length)];
        gs.world.regionalEvent = {
            id: event.id,
            name: event.name,
            desc: event.desc,
            categoryMult: { ...event.categoryMult },
            daysRemaining: event.duration,
            affectedIslands: getRandomIslandSubset(3 + Math.floor(Math.random() * 3))
        };
    }
}

function getRandomIslandSubset(count) {
    const islands = Object.keys(CONFIG.islands);
    const shuffled = islands.sort(() => Math.random() - 0.5);
    return shuffled.slice(0, Math.min(count, islands.length));
}

function isStormSeason(gs) {
    const day = gs.world?.seasonDay || 1;
    return day >= CONFIG.settings.stormSeasonStart && day <= CONFIG.settings.stormSeasonEnd;
}

function getCrackdownLevel(gs) {
    return gs.world?.crackdown?.level || 0;
}

function getSeasonLabel(gs) {
    if (isStormSeason(gs)) return { label: 'Storm Season', icon: 'ğŸŒ§ï¸', class: 'storm-season' };
    const day = gs.world?.seasonDay || 1;
    if (day < CONFIG.settings.stormSeasonStart) return { label: 'Fair Winds', icon: 'ğŸŒ¤ï¸', class: '' };
    return { label: 'Calm Seas', icon: 'â˜€ï¸', class: '' };
}

// ==================== SHIP STAT HELPERS ====================
// Returns effective ship speed factoring in upgrades
function getShipSpeed(gs) {
let s = CONFIG.settings.baseShipSpeed;
if (gs.player.faction === 'pirates') s *= 1.2;
// Apply upgrade penalties
if (gs.player.upgrades?.reinforcedHold) s *= (1 - CONFIG.upgrades.reinforcedHold.effects.speedPenalty);
if (gs.player.upgrades?.vault) s *= (1 - CONFIG.upgrades.vault.effects.speedPenalty);
return s;
}

// Returns effective cargo capacity factoring in upgrades and faction
function getCargoCapacity(gs) {
let c = CONFIG.settings.baseCargoCapacity;
if (gs.player.faction === 'eitc') c *= 1.2;
// Apply upgrade effects
if (gs.player.upgrades?.reinforcedHold) c -= CONFIG.upgrades.reinforcedHold.effects.capacityPenalty;
if (gs.player.upgrades?.smugglerCompartments) c -= CONFIG.upgrades.smugglerCompartments.effects.capacityPenalty;
if (gs.player.upgrades?.vault) c -= CONFIG.upgrades.vault.effects.capacityPenalty;
return Math.floor(Math.max(20, c)); // minimum 20
}

// Returns supplies consumed per day
function getSupplyRate(gs) {
let rate = CONFIG.settings.baseSupplyRate;
if (gs.player.upgrades?.swiftSails) rate += CONFIG.upgrades.swiftSails.effects.supplyCostExtra;
if (gs.player.upgrades?.smugglerCompartments) rate += CONFIG.upgrades.smugglerCompartments.effects.supplyCostExtra;
return rate;
}

// Category-aware capacity check: luxury locker gives bonus for luxury, penalty for commodity
function getCategoryCapacity(gs, category) {
let cap = getCargoCapacity(gs);
// luxuryLocker: +8 for luxury, -3 for commodity
if (gs.player.upgrades?.luxuryLocker) {
if (category === 'luxury') cap += CONFIG.upgrades.luxuryLocker.effects.luxuryCapBonus;
else if (category === 'commodity') cap -= CONFIG.upgrades.luxuryLocker.effects.commodityCapPenalty;
}
return Math.max(0, cap);
}

// Check if player can carry more of a specific good (category-aware)
function canCarryMore(gid, qty, gs) {
const good = CONFIG.goods[gid];
const currentUsed = getCargoUsed(gs);
const catCap = getCategoryCapacity(gs, good.category);
const catUsed = getCargoUsedByCategory(gs, good.category);
const newWeight = good.weight * qty;
// Check total capacity and category-specific capacity
const totalOk = currentUsed + newWeight <= getCargoCapacity(gs);
const catOk = catUsed + newWeight <= catCap;

return { canCarry: totalOk && catOk, reason: !totalOk ? 'Hold full' : !catOk ? 'Category limit' : null };

}

function getCargoUsed(gs) {
let t = 0;
Object.entries(gs.player.cargo).forEach(([g, q]) => t += (CONFIG.goods[g]?.weight || 1) * q);
return t;
}

function getCargoUsedByCategory(gs, category) {
let t = 0;
Object.entries(gs.player.cargo).forEach(([gid, q]) => {
const g = CONFIG.goods[gid];
if (g && g.category === category) t += g.weight * q;
});
return t;
}

// Wind effect on speed
function getWindEffect(gs, moveDir) {
if (!gs.wind) return { mult: 1, label: '' };
const wd = WIND_DIRS[gs.wind.direction], ws = WIND_STR[gs.wind.strength];
if (ws.m === 0) return { mult: 1, label: '' };
const dot = moveDir.x * wd.v.x + moveDir.z * wd.v.z;
const bonus = gs.player.upgrades?.swiftSails ? CONFIG.upgrades.swiftSails.effects.windBonus : 0;
if (dot > 0.5) return { mult: 1 + ws.m * (1 + bonus), label: `+${Math.round(ws.m * (1 + bonus) * 100)}%` };
if (dot < -0.5) return { mult: 1 - ws.m * 0.7, label: `-${Math.round(ws.m * 70)}%` };
return { mult: 1, label: '' };
}

// Cargo protection (fights, storms)
function calcCargoLoss(gs, base) {
if (gs.player.upgrades?.reinforcedHold) base *= (1 - CONFIG.upgrades.reinforcedHold.effects.cargoProtection);
return base;
}

// Gold loss protection
function calcGoldLoss(gs, base) {
if (gs.player.upgrades?.vault) base *= (1 - CONFIG.upgrades.vault.effects.goldProtection);
return Math.floor(base);
}

// Tribute cost reduction
function calcTributeCost(gs, base) {
if (gs.player.upgrades?.vault) base *= (1 - CONFIG.upgrades.vault.effects.tributeReduction);
const fc = CONFIG.factions[gs.player.faction];
if (fc.tributeMult) base *= fc.tributeMult;
// Title modifiers
const mods = getTitleModifiers(gs);
base *= (1 - mods.tributeReduction);
return Math.floor(base);
}

// ==================== RISK & VALUE HELPERS ====================
// Estimate cargo value using current island prices or base prices
function estimateCargoValue(gs) {
let value = 0;
const iid = gs.currentIsland;
Object.entries(gs.player.cargo).forEach(([gid, qty]) => {
let price = CONFIG.goods[gid].basePrice;
// Use current island pricing if docked, else use last known or base
if (iid && gs.islands[iid]) {
price = calcPrice(gid, iid, gs);
} else if (gs.player.visitedIslands) {
// Use any known price
for (const vid of Object.keys(gs.player.visitedIslands)) {
const lp = gs.player.visitedIslands[vid]?.lastPrices?.[gid];
if (lp) { price = lp; break; }
}
}
value += price * qty;
});
return value;
}

function getNetWorth(gs) {
    return gs.player.gold + estimateCargoValue(gs);
}

// Route risk score (0-1): influenced by cargo value, faction, destination, heat
function getRouteRisk(gs) {
let risk = 0;
// Cargo value contribution (0-0.4)
const cargoVal = estimateCargoValue(gs);
risk += Math.min(0.4, cargoVal / 2000);

// Faction contribution (0-0.15)
if (gs.player.faction === 'pirates') risk += 0.1;
else if (gs.player.faction === 'eitc') risk += 0.05;

// Destination faction waters (0-0.15)
if (gs.player.destinationIslandId) {
    const destFaction = CONFIG.islands[gs.player.destinationIslandId]?.faction;
    if (destFaction === 'pirates') risk += 0.15;
    else if (destFaction === 'english' || destFaction === 'eitc') risk += 0.05;
}

// Heat contribution (0-0.2)
risk += (gs.player.heat || 0) / 500;

// Days since dock contribution (0-0.1)
risk += Math.min(0.1, (gs.player.daysSinceDock || 0) / 20);

return Math.min(1, Math.max(0, risk));

}

function getRiskLabel(risk) {
if (risk < 0.3) return { label: 'Low', class: 'risk-low' };
if (risk < 0.6) return { label: 'Med', class: 'risk-med' };
return { label: 'High', class: 'risk-high' };
}

// Check if near English/EITC controlled waters (for inspections)
function isNearHostileWaters(gs) {
const pp = gs.player.position;
for (const [id, isl] of Object.entries(CONFIG.islands)) {
if (isl.faction === 'english' || isl.faction === 'eitc') {
const dist = Math.sqrt((isl.position.x - pp.x)**2 + (isl.position.z - pp.z)**2);
if (dist < 100) return true;
}
}
return false;
}

// Count contraband in cargo
function getContrabandCount(gs) {
let count = 0;
Object.entries(gs.player.cargo).forEach(([gid, qty]) => {
if (CONFIG.goods[gid]?.category === 'contraband') count += qty;
});
return count;
}

// ==================== HEAT SYSTEM ====================
function addHeat(gs, amount) {
gs.player.heat = Math.min(100, Math.max(0, (gs.player.heat || 0) + amount));
}

function decayHeat(gs) {
gs.player.heat = Math.max(0, (gs.player.heat || 0) - CONFIG.settings.heatDecayPerDay);
}

// ==================== ECONOMY ====================
function calcPrice(gid, iid, gs) {
const g = CONFIG.goods[gid], isl = gs.islands[iid], m = isl.markets[gid];
if (!g || !m) return 0;
const scarcity = Math.max(0.5, Math.min(2, 1 + (m.targetSupply - m.supply) / m.targetSupply));
const demand = Math.max(0.5, Math.min(2, 1 + (m.demand - m.targetDemand) / m.targetDemand));
let bias = m.preference === 'exports' ? 0.8 : m.preference === 'imports' ? 1.2 : 1;
const tariff = calcTariff(gs.player.faction, isl.faction, gs);
let evMult = 1;
if (isl.activeEvent) { const ev = CONFIG.events.find(e => e.id === isl.activeEvent.id); if (ev?.affects.includes(g.category)) evMult = ev.multiplier; }

// Regional event multiplier
if (gs.world?.regionalEvent?.affectedIslands?.includes(iid)) {
    const catMult = gs.world.regionalEvent.categoryMult[g.category];
    if (catMult) evMult *= catMult;
}

let fBonus = 1;
if (gs.player.faction === 'eitc') fBonus = 0.95;
if (gs.player.faction === 'pirates' && g.category === 'contraband') fBonus *= 0.5;
// Smuggler compartments contraband bonus
if (gs.player.upgrades?.smugglerCompartments && g.category === 'contraband') {
fBonus *= (1 - CONFIG.upgrades.smugglerCompartments.effects.contrabandProfitBonus);
}
return Math.max(1, Math.round(g.basePrice * scarcity * demand * bias * tariff * evMult * fBonus));
}

function calcTariff(pf, if_, gs) {
if (if_ === 'neutral' || pf === if_) return 1;
const rep = gs.player.reputation[if_] || 0;
let t = 1 + (CONFIG.factions[if_]?.taxRate || 0);
if (rep < -50) t += 0.3; else if (rep < -20) t += 0.15; else if (rep > 50) t -= 0.1;
// Title modifier
const mods = getTitleModifiers(gs);
t *= (1 - mods.tariffReduction);
return Math.max(0.9, Math.min(2, t));
}

function buyGood(gid, qty, iid, gs) {
const m = gs.islands[iid].markets[gid], g = CONFIG.goods[gid], price = calcPrice(gid, iid, gs);
const check = canCarryMore(gid, qty, gs);
if (qty > m.supply || price * qty > gs.player.gold || !check.canCarry) return { success: false, reason: check.reason };
gs.player.gold -= price * qty;
gs.player.cargo[gid] = (gs.player.cargo[gid] || 0) + qty;
gs.player.purchaseHistory[gid] = price;
m.supply -= qty;
recordPrice(gid, iid, price, gs);
// Heat for buying contraband
if (g.category === 'contraband') addHeat(gs, CONFIG.settings.heatGainContraband);
return { success: true, cost: price * qty };
}

function sellGood(gid, qty, iid, gs) {
const price = calcPrice(gid, iid, gs), stock = gs.player.cargo[gid] || 0, g = CONFIG.goods[gid];
if (qty > stock) return { success: false };
gs.player.gold += price * qty;
gs.player.cargo[gid] = stock - qty;
if (gs.player.cargo[gid] <= 0) delete gs.player.cargo[gid];
gs.islands[iid].markets[gid].supply += qty;
recordPrice(gid, iid, price, gs);
// Heat for selling contraband
if (g.category === 'contraband') {
    addHeat(gs, CONFIG.settings.heatGainContraband);
    // Track for smuggler title
    if (!gs.player.stats) gs.player.stats = {};
    gs.player.stats.contrabandTraded = (gs.player.stats.contrabandTraded || 0) + qty;
}
return { success: true, revenue: price * qty };
}

function recordPrice(gid, iid, price, gs) {
if (!gs.player.visitedIslands[iid]) gs.player.visitedIslands[iid] = { lastPrices: {}, lastVisitDay: 0 };
gs.player.visitedIslands[iid].lastPrices[gid] = price;
gs.player.visitedIslands[iid].lastVisitDay = gs.player.days;
}

function recordAllPrices(iid, gs) { Object.keys(CONFIG.goods).forEach(gid => recordPrice(gid, iid, calcPrice(gid, iid, gs), gs)); }

function getPriceTrend(gid, iid, cp, gs) {
const v = gs.player.visitedIslands[iid];
if (!v?.lastPrices[gid]) return 'none';
const last = v.lastPrices[gid];
return cp > last * 1.05 ? 'up' : cp < last * 0.95 ? 'down' : 'stable';
}

function getConfidence(iid, gs) {
const v = gs.player.visitedIslands[iid];
if (!v) return { level: 'none', label: 'None', days: 999 };
const age = gs.player.days - v.lastVisitDay;
const bonus = gs.player.faction === 'eitc' ? 2 : 0;
if (age <= 3 + bonus) return { level: 'high', label: 'High', days: age };
if (age <= 7 + bonus) return { level: 'med', label: 'Med', days: age };
return { level: 'low', label: 'Low', days: age };
}

function simMarketDay(gs) {
Object.keys(gs.islands).forEach(id => {
const isl = gs.islands[id];
Object.keys(isl.markets).forEach(gid => {
const m = isl.markets[gid];
m.supply = Math.max(0, Math.min(m.targetSupply * 2, Math.round(m.supply + (m.targetSupply - m.supply) * 0.05 + (Math.random() - 0.5) * 4)));
m.demand = Math.max(0, Math.min(m.targetDemand * 2, Math.round(m.demand + (m.targetDemand - m.demand) * 0.03 + (Math.random() - 0.5) * 2)));
});
if (isl.activeEvent) { isl.activeEvent.daysRemaining--; if (isl.activeEvent.daysRemaining <= 0) isl.activeEvent = null; }
if (!isl.activeEvent && Math.random() < 0.08) {
const ev = CONFIG.events[Math.floor(Math.random() * CONFIG.events.length)];
isl.activeEvent = { id: ev.id, daysRemaining: ev.duration };
}
});
}

// Calculate deals and mark top 3 as high-margin candidates
function calcDeals(gs, iid) {
const deals = [], curPrices = {};
Object.keys(CONFIG.goods).forEach(gid => { curPrices[gid] = calcPrice(gid, iid, gs); });
Object.keys(gs.player.visitedIslands).forEach(did => {
if (did === iid) return;
const dData = gs.player.visitedIslands[did], conf = getConfidence(did, gs);
if (conf.level === 'none') return;
Object.keys(CONFIG.goods).forEach(gid => {
const g = CONFIG.goods[gid], bp = curPrices[gid], sp = dData.lastPrices[gid];
if (!sp) return;
const profit = sp - bp;
if (profit > 5) deals.push({ gid, good: g, buyIsland: iid, sellIsland: did, buyPrice: bp, sellPrice: sp, profit, profitPerWeight: profit / g.weight, confidence: conf });
});
});
return deals.sort((a, b) => b.profitPerWeight - a.profitPerWeight).slice(0, 5);
}

// Smarter high-margin detection: top 3 deals or profit/weight > threshold
function getHighMarginGoods(gs) {
if (!gs.currentIsland) return new Set();
const deals = calcDeals(gs, gs.currentIsland);
const highMargin = new Set();
// Top 3 by profit/weight
deals.slice(0, 3).forEach(d => highMargin.add(d.gid));
// Also anything above threshold
deals.forEach(d => {
if (d.profitPerWeight >= CONFIG.settings.highMarginThreshold) highMargin.add(d.gid);
});
return highMargin;
}

function getSafeSpawn(iid = 'portRoyal') {
const isl = CONFIG.islands[iid];
return { x: isl.position.x, z: isl.position.z + CONFIG.settings.islandCollisionRadius + 15 };
}

function createState(faction) {
const fc = CONFIG.factions[faction], islands = {};
Object.entries(CONFIG.islands).forEach(([id, cfg]) => {
const markets = {};
Object.entries(cfg.markets).forEach(([gid, mc]) => {
markets[gid] = { supply: mc.targetSupply + Math.floor((Math.random() - 0.5) * 20), demand: mc.targetDemand + Math.floor((Math.random() - 0.5) * 10), targetSupply: mc.targetSupply, targetDemand: mc.targetDemand, preference: mc.preference };
});
islands[id] = { id, name: cfg.name, faction: cfg.faction, markets, activeEvent: null };
});
return {
player: {
faction, gold: CONFIG.settings.startingGold, days: 1, supplies: CONFIG.settings.startingSupplies,
cargo: {}, position: getSafeSpawn(), reputation: { ...fc.startingRep },
visitedIslands: {}, purchaseHistory: {}, upgrades: {}, destinationIslandId: null,
heat: 0, daysSinceDock: 0,
// New fields
titles: {},
stats: { contrabandTraded: 0, contractsCompleted: 0, repChanges: {} },
contracts: { active: [], completed: [], failed: [] },
trackedContractId: null,
tokens: 0,
inspectionTriggeredThisContract: false
},
islands,
wind: { direction: Math.floor(Math.random() * 8), strength: Math.floor(Math.random() * 4), daysUntilChange: CONFIG.settings.windChangeDays },
world: {
    seasonDay: 1,
    crackdown: { level: 0 },
    regionalEvent: null,
    boards: {}
},
currentIsland: null, isDocked: false
};
}

// Migrate old saves - add defaults for new fields
function migrateState(gs) {
if (!gs.player.purchaseHistory) gs.player.purchaseHistory = {};
if (!gs.player.upgrades) gs.player.upgrades = {};
if (gs.player.destinationIslandId === undefined) gs.player.destinationIslandId = null;
if (gs.player.heat === undefined) gs.player.heat = 0;
if (gs.player.daysSinceDock === undefined) gs.player.daysSinceDock = 0;
if (!gs.wind) gs.wind = { direction: Math.floor(Math.random() * 8), strength: Math.floor(Math.random() * 4), daysUntilChange: 5 };
if (gs.isDocked && !gs.currentIsland) gs.isDocked = false;

// New migrations for contracts/titles/world
if (!gs.player.titles) gs.player.titles = {};
if (!gs.player.stats) gs.player.stats = { contrabandTraded: 0, contractsCompleted: 0, repChanges: {} };
if (!gs.player.stats.contrabandTraded) gs.player.stats.contrabandTraded = 0;
if (!gs.player.stats.contractsCompleted) gs.player.stats.contractsCompleted = 0;
if (!gs.player.stats.repChanges) gs.player.stats.repChanges = {};
if (!gs.player.contracts) gs.player.contracts = { active: [], completed: [], failed: [] };
if (!gs.player.contracts.active) gs.player.contracts.active = [];
if (!gs.player.contracts.completed) gs.player.contracts.completed = [];
if (!gs.player.contracts.failed) gs.player.contracts.failed = [];
if (gs.player.trackedContractId === undefined) gs.player.trackedContractId = null;
if (gs.player.tokens === undefined) gs.player.tokens = 0;
if (gs.player.inspectionTriggeredThisContract === undefined) gs.player.inspectionTriggeredThisContract = false;

// World state
if (!gs.world) gs.world = {};
if (gs.world.seasonDay === undefined) gs.world.seasonDay = 1;
if (!gs.world.crackdown) gs.world.crackdown = { level: 0 };
if (gs.world.regionalEvent === undefined) gs.world.regionalEvent = null;
if (!gs.world.boards) gs.world.boards = {};

return gs;
}

// ==================== THREE.JS ====================
class SceneManager {
constructor(canvas) {
this.canvas = canvas; this.scene = new THREE.Scene(); this.clock = new THREE.Clock();
this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true }); this.renderer.setPixelRatio(Math.min(devicePixelRatio, 2)); this.renderer.setClearColor(0x1a3a4a);
this.camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 1, 1000); this.camera.position.set(0, 80, 100);
this.scene.add(new THREE.AmbientLight(0xffeedd, 0.6));
const sun = new THREE.DirectionalLight(0xffffff, 0.8); sun.position.set(50, 100, 50); this.scene.add(sun);
this.createOcean(); this.createIslands();
this.ship = this.createShip(); this.scene.add(this.ship); this.shipHeading = 0;
addEventListener('resize', () => this.onResize()); this.onResize();
}
createOcean() {
const geo = new THREE.PlaneGeometry(2000, 2000, 50, 50); this.oceanPos = geo.getAttribute('position').array.slice();
this.ocean = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: 0x2d5a6a, shininess: 100, side: THREE.DoubleSide }));
this.ocean.rotation.x = -Math.PI / 2; this.ocean.position.y = -2; this.scene.add(this.ocean);
}
createIslands() {
const colors = { english: 0xc41e3a, eitc: 0x1e4d2b, pirates: 0x2c2c2c, neutral: 0x808080 };
Object.entries(CONFIG.islands).forEach(([id, cfg]) => {
const g = new THREE.Group(); g.position.set(cfg.position.x, 0, cfg.position.z);
const r = 15 + Math.random() * 5;
g.add(new THREE.Mesh(new THREE.CylinderGeometry(r, r * 1.2, 8, 8), new THREE.MeshLambertMaterial({ color: cfg.color }))); g.children[0].position.y = 2;
const beach = new THREE.Mesh(new THREE.TorusGeometry(r * 1.1, 2, 8, 16), new THREE.MeshLambertMaterial({ color: 0xf4e4c1 })); beach.rotation.x = Math.PI / 2; beach.position.y = -0.5; g.add(beach);
for (let i = 0; i < 4; i++) { const tree = new THREE.Group(), a = i * 1.5 + Math.random(), d = 6 + Math.random() * 4; tree.position.set(Math.cos(a) * d, 6, Math.sin(a) * d); tree.add(new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.7, 3, 6), new THREE.MeshLambertMaterial({ color: 0x8b4513 }))); const lv = new THREE.Mesh(new THREE.ConeGeometry(3, 6, 6), new THREE.MeshLambertMaterial({ color: 0x228b22 })); lv.position.y = 5; tree.add(lv); g.add(tree); }
const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 12, 6), new THREE.MeshLambertMaterial({ color: 0x8b4513 })); pole.position.y = 12; g.add(pole);
const flag = new THREE.Mesh(new THREE.PlaneGeometry(4, 2.5), new THREE.MeshLambertMaterial({ color: colors[cfg.faction], side: THREE.DoubleSide })); flag.position.set(2.5, 16, 0); g.add(flag);
this.scene.add(g);
});
}
createShip() {
const s = new THREE.Group();
s.add(new THREE.Mesh(new THREE.BoxGeometry(4, 2, 10), new THREE.MeshLambertMaterial({ color: 0x8b4513 }))); s.children[0].position.y = 1;
s.add(new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.5, 9), new THREE.MeshLambertMaterial({ color: 0xdeb887 }))); s.children[1].position.y = 2.5;
s.add(new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 12, 8), new THREE.MeshLambertMaterial({ color: 0x4a3728 }))); s.children[2].position.y = 8;
const sail = new THREE.Mesh(new THREE.PlaneGeometry(6, 8), new THREE.MeshLambertMaterial({ color: 0xf5f0e1, side: THREE.DoubleSide })); sail.position.set(0, 9, 1); sail.rotation.y = Math.PI / 2; s.add(sail);
const bow = new THREE.Mesh(new THREE.ConeGeometry(1, 3, 6), new THREE.MeshLambertMaterial({ color: 0xc9a227 })); bow.position.set(0, 1, 6); bow.rotation.x = Math.PI / 2; s.add(bow);
return s;
}
updateShip(pos, heading) {
this.ship.position.set(pos.x, Math.sin(this.clock.getElapsedTime() * 2) * 0.5, pos.z);
this.ship.rotation.z = Math.sin(this.clock.getElapsedTime() * 1.5) * 0.05;
if (heading !== null) this.shipHeading += (heading - this.shipHeading) * 0.1;
this.ship.rotation.y = this.shipHeading;
}
updateCamera(sp) { this.camera.position.x += (sp.x - this.camera.position.x) * 0.05; this.camera.position.z += (sp.z + 80 - this.camera.position.z) * 0.05; this.camera.lookAt(sp.x, 0, sp.z); }
onResize() { this.camera.aspect = innerWidth / innerHeight; this.camera.updateProjectionMatrix(); this.renderer.setSize(innerWidth, innerHeight); }
render() {
const t = this.clock.getElapsedTime(), pos = this.ocean.geometry.getAttribute('position').array;
for (let i = 0; i < pos.length; i += 3) pos[i + 2] = Math.sin(this.oceanPos[i] * 0.02 + t) * 1.5 + Math.sin(this.oceanPos[i + 1] * 0.03 + t * 0.8);
this.ocean.geometry.getAttribute('position').needsUpdate = true;
this.renderer.render(this.scene, this.camera);
}
}

// ==================== JOYSTICK ====================
class Joystick {
constructor() {
this.base = document.getElementById('joystick-base'); this.stick = document.getElementById('joystick-stick'); this.zone = document.getElementById('joystick-zone');
this.active = false; this.value = { x: 0, y: 0 }; this.magnitude = 0; this.angle = 0; this.maxDist = 35;
this.zone.addEventListener('touchstart', e => this.start(e.touches[0]), { passive: false });
document.addEventListener('touchmove', e => { if (this.active) { e.preventDefault(); this.move(e.touches[0]); } }, { passive: false });
document.addEventListener('touchend', () => this.end()); document.addEventListener('touchcancel', () => this.end());
this.zone.addEventListener('mousedown', e => this.start(e)); document.addEventListener('mousemove', e => { if (this.active) this.move(e); }); document.addEventListener('mouseup', () => this.end());
}
start(e) { this.active = true; this.stick.classList.add('active'); this.rect = this.base.getBoundingClientRect(); this.move(e); }
move(e) {
if (!this.active || !this.rect) return;
let dx = e.clientX - (this.rect.left + this.rect.width / 2), dy = e.clientY - (this.rect.top + this.rect.height / 2);
const dist = Math.sqrt(dx * dx + dy * dy), cd = Math.min(dist, this.maxDist);
if (dist > 0) { dx = dx / dist * cd; dy = dy / dist * cd; }
this.stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
this.value = { x: dx / this.maxDist, y: dy / this.maxDist }; this.magnitude = cd / this.maxDist; this.angle = Math.atan2(-dx, -dy);
}
end() { this.active = false; this.stick.classList.remove('active'); this.stick.style.transform = 'translate(-50%, -50%)'; this.value = { x: 0, y: 0 }; this.magnitude = 0; }
}

// ==================== UI ====================
class UI {
constructor(game) { this.game = game; this.el = {}; this.cache(); this.bind(); }
cache() {
['loading-screen','faction-screen','game-container','gold-value','day-value','supplies-value','faction-badge','faction-icon','faction-name','cargo-count','cargo-preview','compass-needle','compass-dest-marker','destination-info','dest-name','dest-distance','event-toast','event-title','event-desc','trade-modal','trade-island-name','trade-island-faction','trade-tariff','buy-panel','sell-panel','logbook-panel','shipyard-panel','contracts-panel','buy-goods-list','sell-goods-list','trade-gold','trade-cargo','close-trade','leave-port-btn','menu-modal','close-menu','save-btn','new-game-btn','rep-english','rep-eitc','rep-pirates','rep-english-val','rep-eitc-val','rep-pirates-val','ship-speed','ship-cargo-cap','ship-supply-rate','ship-upgrades','pirate-modal','pay-tribute','fight-pirates','pirate-pass','tribute-cost','warning-modal','warning-icon','warning-title','warning-text','warning-dismiss','continue-btn','btn-dock','btn-map','btn-menu','speed-fill','wind-effect','island-indicator','nearby-island-name','nearby-island-faction','nearby-island-dist','map-modal','map-container','map-info','close-map','clear-course-btn','wind-indicator','wind-arrow','wind-strength','menu-wind-dir','menu-wind-change','menu-route-risk','menu-heat','buy-best-btn','sell-best-btn','logbook-island-select','logbook-prices','spotlight-list','upgrades-list','encounter-modal','encounter-icon','encounter-title','encounter-desc','encounter-result','encounter-options','heat-indicator','heat-fill','heat-label','contract-tracker','tracker-title','tracker-meta','world-indicator','world-icon','world-status','available-contracts','active-contracts','active-count','contracts-badge','titles-list','menu-season','menu-crackdown','menu-regional','title-modal','title-icon','title-earned-name','title-earned-desc','title-dismiss'].forEach(id => this.el[id] = document.getElementById(id));
this.el.tradeTabs = document.querySelectorAll('.trade-tab'); this.el.factionCards = document.querySelectorAll('.faction-card');
}
bind() {
this.el.factionCards.forEach(c => c.addEventListener('click', () => { this.el.factionCards.forEach(x => x.classList.remove('selected')); c.classList.add('selected'); this.el['continue-btn'].classList.remove('hidden'); this.game.selectedFaction = c.dataset.faction; }));
this.el['continue-btn']?.addEventListener('click', () => { if (this.game.selectedFaction) this.game.startGame(this.game.selectedFaction); });
this.el.tradeTabs.forEach(tab => tab.addEventListener('click', () => { this.el.tradeTabs.forEach(t => t.classList.remove('active')); tab.classList.add('active'); ['buy','sell','contracts','logbook','shipyard'].forEach(p => this.el[p+'-panel'].classList.toggle('hidden', p !== tab.dataset.tab)); if (tab.dataset.tab === 'logbook') this.renderLogbook(); if (tab.dataset.tab === 'shipyard') this.renderShipyard(); if (tab.dataset.tab === 'contracts') this.renderContracts(); }));
this.el['close-trade']?.addEventListener('click', () => this.closeTrade());
this.el['leave-port-btn']?.addEventListener('click', () => { this.closeTrade(); this.game.undock(); });
this.el['btn-dock']?.addEventListener('click', () => this.game.dock());
this.el['btn-menu']?.addEventListener('click', () => this.showMenu());
this.el['btn-map']?.addEventListener('click', () => this.showMap());
this.el['close-menu']?.addEventListener('click', () => this.el['menu-modal'].classList.add('hidden'));
this.el['close-map']?.addEventListener('click', () => this.el['map-modal'].classList.add('hidden'));
this.el['clear-course-btn']?.addEventListener('click', () => { this.game.gameState.player.destinationIslandId = null; this.toast('Cleared', 'No course'); this.el['map-modal'].classList.add('hidden'); });
this.el['save-btn']?.addEventListener('click', () => { this.game.save(); this.toast('Saved', 'Progress saved'); });
this.el['new-game-btn']?.addEventListener('click', () => { if (confirm('New game?')) { localStorage.removeItem('merchantSeasSave'); location.reload(); } });
this.el['pay-tribute']?.addEventListener('click', () => this.game.payTribute());
this.el['fight-pirates']?.addEventListener('click', () => this.game.fight());
this.el['pirate-pass']?.addEventListener('click', () => { this.el['pirate-modal'].classList.add('hidden'); this.toast('Parley', 'Safe passage'); });
this.el['warning-dismiss']?.addEventListener('click', () => this.el['warning-modal'].classList.add('hidden'));
this.el['title-dismiss']?.addEventListener('click', () => this.el['title-modal'].classList.add('hidden'));
this.el['buy-best-btn']?.addEventListener('click', () => this.game.buyBest());
this.el['sell-best-btn']?.addEventListener('click', () => this.game.sellBest());
this.el['logbook-island-select']?.addEventListener('change', e => this.renderLogPrices(e.target.value));
this.el['contract-tracker']?.addEventListener('click', () => { if (this.game.gameState?.isDocked) { this.el.tradeTabs.forEach(t => t.classList.toggle('active', t.dataset.tab === 'contracts')); ['buy','sell','contracts','logbook','shipyard'].forEach(p => this.el[p+'-panel'].classList.toggle('hidden', p !== 'contracts')); this.renderContracts(); } });
}
showLoading(p) { document.querySelector('.loading-progress').style.width = p + '%'; }
hideLoading() { this.el['loading-screen'].classList.add('hidden'); }
showFaction() { this.el['faction-screen'].classList.remove('hidden'); }
hideFaction() { this.el['faction-screen'].classList.add('hidden'); }
showGame() { this.el['game-container'].classList.remove('hidden'); }
updateHUD(gs) {
    this.el['gold-value'].textContent = gs.player.gold.toLocaleString();
    this.el['day-value'].textContent = gs.player.days;
    this.el['supplies-value'].textContent = gs.player.supplies;
    const f = CONFIG.factions[gs.player.faction];
    this.el['faction-icon'].textContent = f.icon;
    this.el['faction-name'].textContent = f.name;
    this.el['faction-badge'].className = gs.player.faction;
    this.el['cargo-count'].textContent = `${getCargoUsed(gs)}/${getCargoCapacity(gs)}`;

    // Cargo preview with smart high-margin glow
    const prev = this.el['cargo-preview']; prev.innerHTML = '';
    const highMargin = getHighMarginGoods(gs);
    Object.entries(gs.player.cargo).forEach(([gid, qty]) => {
        const g = CONFIG.goods[gid];
        const isContraband = g.category === 'contraband';
        const isHM = highMargin.has(gid);
        for (let i = 0; i < Math.min(qty, 8); i++) {
            const d = document.createElement('span');
            d.className = 'cargo-dot' + (isContraband ? ' contraband' : isHM ? ' high-margin' : '');
            prev.appendChild(d);
        }
    });

    // Wind
    if (gs.wind) {
        const wd = WIND_DIRS[gs.wind.direction], ws = WIND_STR[gs.wind.strength];
        this.el['wind-arrow'].style.transform = `rotate(${wd.angle}deg)`;
        this.el['wind-strength'].textContent = `${ws.name} ${wd.name}`;
    }

    // Heat indicator
    const heat = gs.player.heat || 0;
    this.el['heat-fill'].style.width = heat + '%';
    this.el['heat-label'].textContent = heat;
    this.el['heat-indicator'].className = heat < 30 ? 'low' : heat < 60 ? 'med' : 'high';

    // Contract tracker
    this.updateContractTracker(gs);

    // World indicator
    this.updateWorldIndicator(gs);
}

updateContractTracker(gs) {
    const tracked = getTrackedContract(gs);
    if (tracked) {
        this.el['contract-tracker'].classList.remove('hidden');
        this.el['tracker-title'].textContent = tracked.title.substring(0, 15) + (tracked.title.length > 15 ? '...' : '');
        const daysLeft = tracked.deadline - (gs.player.days - tracked.dayAccepted);
        const dest = CONFIG.islands[tracked.toIsland];
        const dist = getIslandDistance(gs.player.position, dest.position);
        this.el['tracker-meta'].textContent = `${daysLeft}d left Â· ~${Math.ceil(dist/30)}d`;
    } else {
        this.el['contract-tracker'].classList.add('hidden');
    }
}

updateWorldIndicator(gs) {
    const season = getSeasonLabel(gs);
    const crackdown = getCrackdownLevel(gs);

    this.el['world-icon'].textContent = season.icon;

    if (crackdown > 50) {
        this.el['world-status'].textContent = 'Crackdown!';
        this.el['world-indicator'].className = 'crackdown';
    } else if (season.class === 'storm-season') {
        this.el['world-status'].textContent = season.label;
        this.el['world-indicator'].className = season.class;
    } else {
        this.el['world-status'].textContent = season.label;
        this.el['world-indicator'].className = '';
    }
}

updateCompass(h, gs) {
    // Check for tracked contract destination first
    const tracked = getTrackedContract(gs);
    const destId = tracked?.toIsland || gs?.player?.destinationIslandId;

    if (destId) {
        const d = CONFIG.islands[destId], dx = d.position.x - gs.player.position.x, dz = d.position.z - gs.player.position.z, a = Math.atan2(dx, -dz);
        this.el['compass-needle'].style.transform = `translate(-50%, -100%) rotate(${a * 180 / Math.PI}deg)`;
        this.el['compass-dest-marker'].classList.remove('hidden');
        this.el['destination-info'].classList.remove('hidden');
        this.el['dest-name'].textContent = d.name;
        this.el['dest-distance'].textContent = `~${Math.ceil(Math.sqrt(dx*dx+dz*dz)/30)}d`;
    } else {
        this.el['compass-needle'].style.transform = `translate(-50%, -100%) rotate(${h * 180 / Math.PI}deg)`;
        this.el['compass-dest-marker'].classList.add('hidden');
        this.el['destination-info'].classList.add('hidden');
    }
}

updateSpeed(s, we) {
    this.el['speed-fill'].style.width = s * 100 + '%';
    this.el['wind-effect'].textContent = we?.label || '';
    this.el['wind-effect'].className = we?.mult > 1 ? 'wind-boost' : we?.mult < 1 ? 'wind-penalty' : '';
}

updateNearby(isl, dist) {
    if (isl) {
        this.el['island-indicator'].classList.add('visible');
        this.el['nearby-island-name'].textContent = isl.name;
        this.el['nearby-island-faction'].textContent = CONFIG.factions[isl.faction]?.name || 'Neutral';
        this.el['nearby-island-dist'].textContent = dist < CONFIG.settings.dockDistance ? 'âš“ Dock' : Math.round(dist) + 'm';
        this.el['btn-dock'].classList.toggle('available', dist < CONFIG.settings.dockDistance);
    }
    else { this.el['island-indicator'].classList.remove('visible'); this.el['btn-dock'].classList.remove('available'); }
}

showTrade(iid, gs) {
    const isl = gs.islands[iid];
    this.el['trade-island-name'].textContent = isl.name;
    this.el['trade-island-faction'].textContent = CONFIG.factions[isl.faction]?.name || 'Neutral';
    this.el['trade-island-faction'].className = 'faction-tag ' + isl.faction;
    const t = calcTariff(gs.player.faction, isl.faction, gs), tp = Math.round((t - 1) * 100);
    this.el['trade-tariff'].textContent = tp > 0 ? '+' + tp + '%' : 'No Tariff';
    recordAllPrices(iid, gs);
    this.renderBuy(iid, gs);
    this.renderSell(iid, gs);
    this.updateFooter(gs);

    // Update contracts badge
    const board = gs.world.boards[iid];
    const availableCount = board?.contracts?.length || 0;
    if (availableCount > 0) {
        this.el['contracts-badge'].textContent = availableCount;
        this.el['contracts-badge'].classList.remove('hidden');
    } else {
        this.el['contracts-badge'].classList.add('hidden');
    }

    this.el.tradeTabs.forEach(t => t.classList.toggle('active', t.dataset.tab === 'buy'));
    ['buy','sell','contracts','logbook','shipyard'].forEach(p => this.el[p+'-panel'].classList.toggle('hidden', p !== 'buy'));
    this.el['trade-modal'].classList.remove('hidden');
}

renderBuy(iid, gs) {
    const list = this.el['buy-goods-list']; list.innerHTML = '';
    Object.entries(CONFIG.goods).forEach(([gid, g]) => {
        const m = gs.islands[iid].markets[gid], price = calcPrice(gid, iid, gs), trend = getPriceTrend(gid, iid, price, gs);
        const check = canCarryMore(gid, 1, gs);
        const canBuy = m.supply > 0 && price <= gs.player.gold && check.canCarry;

        const item = document.createElement('div');
        item.className = 'good-item' + (!canBuy && check.reason ? ' blocked' : '');
        item.innerHTML = `
            <div class="good-info">
                <span class="good-icon">${g.icon}</span>
                <span class="good-name">${g.name}</span>
                <span class="good-price">${price}g<span class="price-trend ${trend}">${trend === 'up' ? 'â†‘' : trend === 'down' ? 'â†“' : ''}</span></span>
            </div>
            <div class="good-details">Stock:${m.supply} Wt:${g.weight} ${check.reason && !canBuy ? `<span class="block-reason">${check.reason}</span>` : ''}</div>
            <div class="good-actions"><button class="qty-btn buy" ${!canBuy ? 'disabled' : ''}>+</button></div>
        `;
        item.querySelector('.qty-btn').addEventListener('click', () => {
            if (buyGood(gid, 1, iid, gs).success) {
                this.renderBuy(iid, gs); this.renderSell(iid, gs); this.updateFooter(gs); this.game.save();
            }
        });
        list.appendChild(item);
    });
}

renderSell(iid, gs) {
    const list = this.el['sell-goods-list']; list.innerHTML = '';
    if (!Object.keys(gs.player.cargo).length) { list.innerHTML = '<p style="text-align:center;color:var(--ink-light);padding:20px">Empty</p>'; return; }
    Object.entries(gs.player.cargo).forEach(([gid, qty]) => {
        const g = CONFIG.goods[gid], price = calcPrice(gid, iid, gs), trend = getPriceTrend(gid, iid, price, gs), pp = gs.player.purchaseHistory[gid];
        const item = document.createElement('div'); item.className = 'good-item';
        item.innerHTML = `<div class="good-info"><span class="good-icon">${g.icon}</span><span class="good-name">${g.name}</span><span class="good-price">${price}g${pp ? (price > pp ? 'ğŸ“ˆ' : 'ğŸ“‰') : ''}<span class="price-trend ${trend}">${trend === 'up' ? 'â†‘' : trend === 'down' ? 'â†“' : ''}</span></span></div><div class="good-details">Have:${qty}${pp ? ' @' + pp + 'g' : ''}</div><div class="good-actions"><button class="qty-btn sell">âˆ’</button></div>`;
        item.querySelector('.qty-btn').addEventListener('click', () => { if (sellGood(gid, 1, iid, gs).success) { this.renderBuy(iid, gs); this.renderSell(iid, gs); this.updateFooter(gs); this.game.save(); } });
        list.appendChild(item);
    });
}

renderContracts() {
    const gs = this.game.gameState;
    const iid = gs.currentIsland;
    if (!iid) return;

    // Refresh board if needed
    refreshContractBoard(gs, iid);
    const board = gs.world.boards[iid];

    // Render available contracts
    const availEl = this.el['available-contracts'];
    if (board.contracts.length === 0) {
        availEl.innerHTML = '<div class="contract-empty">No contracts available. Check back later!</div>';
    } else {
        availEl.innerHTML = board.contracts.map(c => this.renderContractCard(c, gs, 'available')).join('');
        availEl.querySelectorAll('.accept-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (acceptContract(gs, btn.dataset.id)) {
                    this.renderContracts();
                    this.updateContractTracker(gs);
                    this.toast('Contract Accepted', 'Check your active contracts');
                    this.game.save();
                } else {
                    this.toast('Cannot Accept', 'Max 3 active contracts');
                }
            });
        });
    }

    // Render active contracts
    const activeEl = this.el['active-contracts'];
    this.el['active-count'].textContent = gs.player.contracts.active.length;

    if (gs.player.contracts.active.length === 0) {
        activeEl.innerHTML = '<div class="contract-empty">No active contracts</div>';
    } else {
        activeEl.innerHTML = gs.player.contracts.active.map(c => this.renderContractCard(c, gs, 'active')).join('');
        activeEl.querySelectorAll('.track-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                gs.player.trackedContractId = gs.player.trackedContractId === btn.dataset.id ? null : btn.dataset.id;
                this.renderContracts();
                this.updateContractTracker(gs);
                this.game.save();
            });
        });
        activeEl.querySelectorAll('.abandon-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (confirm('Abandon this contract? You will lose reputation.')) {
                    abandonContract(gs, btn.dataset.id);
                    this.renderContracts();
                    this.updateContractTracker(gs);
                    this.toast('Contract Abandoned', '-3 reputation');
                    this.game.save();
                }
            });
        });
    }
}

renderContractCard(contract, gs, mode) {
    const type = CONFIG.contractTypes[contract.typeId];
    const dest = CONFIG.islands[contract.toIsland];
    const isTracked = gs.player.trackedContractId === contract.id;

    let daysLeft = contract.deadline;
    let progress = '';

    if (mode === 'active') {
        daysLeft = contract.deadline - (gs.player.days - contract.dayAccepted);
        if (contract.requirement.type === 'deliver') {
            const have = gs.player.cargo[contract.requirement.goodId] || 0;
            const need = contract.requirement.qty;
            progress = `<div class="contract-details">ğŸ“¦ ${CONFIG.goods[contract.requirement.goodId].icon} ${have}/${need}</div>`;
        }
    }

    const deadlineClass = daysLeft <= 2 ? 'urgent' : '';
    const cardClass = mode === 'active' ? 'active' : '';
    const trackedClass = isTracked ? 'tracked' : '';

    let actions = '';
    if (mode === 'available') {
        const canAccept = gs.player.contracts.active.length < CONFIG.settings.maxActiveContracts;
        actions = `<button class="btn-small ${canAccept ? 'btn-primary' : 'btn-secondary'} accept-btn" data-id="${contract.id}" ${canAccept ? '' : 'disabled'}>Accept</button>`;
    } else {
        actions = `
            <button class="btn-small ${isTracked ? 'btn-primary' : 'btn-secondary'} track-btn" data-id="${contract.id}">${isTracked ? 'âœ“ Tracked' : 'Track'}</button>
            <button class="btn-small btn-secondary abandon-btn" data-id="${contract.id}">âœ•</button>
        `;
    }

    let requirementText = '';
    if (contract.requirement.type === 'deliver') {
        const good = CONFIG.goods[contract.requirement.goodId];
        requirementText = `Deliver ${contract.requirement.qty}x ${good.icon} ${good.name}`;
    } else if (contract.requirement.type === 'reach') {
        requirementText = contract.requirement.noInspection ? 'Reach without inspection' : 'Reach destination';
    } else if (contract.requirement.type === 'supplies') {
        requirementText = `Arrive with ${contract.requirement.minSupplies}+ supplies`;
    }

    return `
        <div class="contract-card ${cardClass} ${trackedClass}">
            <div class="contract-header">
                <span class="contract-title">${contract.title}</span>
                <span class="contract-type ${contract.typeId}">${type.icon} ${type.name}</span>
            </div>
            <div class="contract-details">ğŸ“ ${dest.name} Â· ${requirementText}</div>
            ${progress}
            <div class="contract-deadline ${deadlineClass}">â±ï¸ ${daysLeft} days left</div>
            <div class="contract-rewards">
                <span class="contract-reward gold">ğŸª™ ${contract.rewards.gold}g</span>
                <span class="contract-reward rep">${contract.rewards.rep > 0 ? '+' : ''}${contract.rewards.rep} ${contract.rewards.repFaction} rep</span>
            </div>
            <div class="contract-actions">${actions}</div>
        </div>
    `;
}

renderLogbook() {
    const gs = this.game.gameState, iid = gs.currentIsland, deals = calcDeals(gs, iid);
    this.el['spotlight-list'].innerHTML = deals.length ? deals.map(d => `<div class="spotlight-card" data-dest="${d.sellIsland}"><div class="spotlight-header"><span class="spotlight-good">${d.good.icon} ${d.good.name}</span><span class="spotlight-profit">+${d.profit}g</span></div><div class="spotlight-route">Buy @${d.buyPrice}g â†’ ${CONFIG.islands[d.sellIsland].name} @${d.sellPrice}g <span class="confidence-tag confidence-${d.confidence.level}">${d.confidence.label}</span></div></div>`).join('') : '<div class="spotlight-empty">Visit more ports!</div>';
    this.el['spotlight-list'].querySelectorAll('.spotlight-card').forEach(c => c.addEventListener('click', () => { this.game.gameState.player.destinationIslandId = c.dataset.dest; this.toast('Course Set', CONFIG.islands[c.dataset.dest].name); }));
    const sel = this.el['logbook-island-select']; sel.innerHTML = '';
    Object.entries(CONFIG.islands).forEach(([id, isl]) => { const v = gs.player.visitedIslands[id]; const o = document.createElement('option'); o.value = id; o.textContent = isl.name + (v ? ` (D${v.lastVisitDay})` : ''); if (id === iid) o.selected = true; sel.appendChild(o); });
    this.renderLogPrices(iid);
}

renderLogPrices(iid) {
    const gs = this.game.gameState, v = gs.player.visitedIslands[iid];
    if (!v?.lastPrices) { this.el['logbook-prices'].innerHTML = '<p style="text-align:center;color:var(--ink-light)">No data</p>'; return; }
    this.el['logbook-prices'].innerHTML = Object.entries(CONFIG.goods).map(([gid, g]) => {
        const lp = v.lastPrices[gid]; if (!lp) return '';
        let cmp = ''; if (iid !== gs.currentIsland) { const cp = calcPrice(gid, gs.currentIsland, gs), diff = lp - cp; if (Math.abs(diff) > 2) cmp = diff > 0 ? `<span style="color:#1e7d34">+${diff}</span>` : `<span style="color:var(--blood-red)">${diff}</span>`; }
        return `<div class="logbook-item"><div class="good-info"><span>${g.icon}</span><span>${g.name}</span></div><div>${lp}g ${cmp}</div></div>`;
    }).join('');
}

renderShipyard() {
    const gs = this.game.gameState;
    this.el['upgrades-list'].innerHTML = Object.entries(CONFIG.upgrades).map(([id, u]) => {
        const owned = gs.player.upgrades[id], afford = gs.player.gold >= u.cost;
        const prosHtml = u.pros.map(p => `<span class="upgrade-stat positive">${p}</span>`).join('');
        const consHtml = u.cons.map(c => `<span class="upgrade-stat negative">${c}</span>`).join('');
        return `<div class="upgrade-card ${owned ? 'owned' : ''}">
            <div class="upgrade-header"><span class="upgrade-name">${u.icon} ${u.name}</span><span class="upgrade-cost">${owned ? 'âœ“' : u.cost + 'g'}</span></div>
            <div class="upgrade-desc">${u.desc}</div>
            <div class="upgrade-stats">${prosHtml}${consHtml}</div>
            ${!owned ? `<button class="btn-secondary btn-small upg-btn" data-id="${id}" ${afford ? '' : 'disabled'}>${afford ? 'Buy' : 'Need gold'}</button>` : ''}
        </div>`;
    }).join('');
    this.el['upgrades-list'].querySelectorAll('.upg-btn').forEach(b => b.addEventListener('click', () => { if (this.game.buyUpgrade(b.dataset.id)) { this.renderShipyard(); this.updateFooter(gs); } }));
}

updateFooter(gs) { this.el['trade-gold'].textContent = gs.player.gold.toLocaleString(); this.el['trade-cargo'].textContent = getCargoUsed(gs) + '/' + getCargoCapacity(gs); }
closeTrade() { this.el['trade-modal'].classList.add('hidden'); }

showMenu() {
    const gs = this.game.gameState;
    ['english','eitc','pirates'].forEach(f => { const r = gs.player.reputation[f] || 0; this.el['rep-' + f].style.width = (r + 100) / 2 + '%'; this.el['rep-' + f].className = 'rep-fill' + (r < -30 ? ' hostile' : r > 30 ? ' friendly' : ''); this.el['rep-' + f + '-val'].textContent = r; });
    this.el['ship-speed'].textContent = getShipSpeed(gs).toFixed(2) + 'x';
    this.el['ship-cargo-cap'].textContent = getCargoCapacity(gs);
    this.el['ship-supply-rate'].textContent = getSupplyRate(gs).toFixed(1);
    const upgs = Object.keys(gs.player.upgrades).filter(k => gs.player.upgrades[k]).map(k => CONFIG.upgrades[k]?.name);
    this.el['ship-upgrades'].textContent = upgs.length ? upgs.join(', ') : 'None';
    if (gs.wind) {
        this.el['menu-wind-dir'].textContent = WIND_DIRS[gs.wind.direction].name + ' ' + WIND_STR[gs.wind.strength].name;
        this.el['menu-wind-change'].textContent = gs.wind.daysUntilChange + 'd';
    }
    // Risk
    const risk = getRouteRisk(gs), rl = getRiskLabel(risk);
    this.el['menu-route-risk'].textContent = rl.label;
    this.el['menu-route-risk'].className = rl.class;
    this.el['menu-heat'].textContent = (gs.player.heat || 0) + '/100';

    // Titles
    this.renderTitles(gs);

    // World status
    const season = getSeasonLabel(gs);
    this.el['menu-season'].textContent = `${season.icon} ${season.label} (Day ${gs.world?.seasonDay || 1}/${CONFIG.settings.seasonCycleDays})`;

    const crackdown = getCrackdownLevel(gs);
    this.el['menu-crackdown'].textContent = crackdown > 0 ? `Level ${crackdown}` : 'None';
    this.el['menu-crackdown'].className = crackdown > 50 ? 'risk-high' : crackdown > 25 ? 'risk-med' : '';

    const regional = gs.world?.regionalEvent;
    this.el['menu-regional'].textContent = regional ? `${regional.name} (${regional.daysRemaining}d)` : 'None';

    this.el['menu-modal'].classList.remove('hidden');
}

renderTitles(gs) {
    const titlesEl = this.el['titles-list'];
    titlesEl.innerHTML = Object.entries(CONFIG.titles).map(([trackId, track]) => {
        const tier = getTitleTier(trackId, gs);
        const name = getTitleName(trackId, tier);
        const value = getTitleTrackValue(trackId, gs);
        const nextThreshold = getNextThreshold(trackId, gs);
        const tierClass = `tier-${Math.min(tier, 5)}`;

        return `
            <div class="title-item">
                <div>
                    <span class="title-name">${track.icon} ${track.name}</span>
                    <span class="title-tier ${tierClass}">${name}</span>
                </div>
                <span class="title-progress">${Math.floor(value)}/${nextThreshold}</span>
            </div>
        `;
    }).join('');
}

showMap() {
    const c = this.el['map-container'], gs = this.game.gameState; c.innerHTML = '';
    const minX = -220, maxX = 240, minZ = -180, maxZ = 160, toP = (v, mn, mx) => (v - mn) / (mx - mn) * 100;

    // Show course to tracked contract or manual destination
    const tracked = getTrackedContract(gs);
    const destId = tracked?.toIsland || gs.player.destinationIslandId;

    if (destId) {
        const d = CONFIG.islands[destId], px = toP(gs.player.position.x, minX, maxX), py = toP(gs.player.position.z, minZ, maxZ), dx = toP(d.position.x, minX, maxX), dy = toP(d.position.z, minZ, maxZ);
        const len = Math.sqrt((dx-px)**2 + (dy-py)**2), ang = Math.atan2(dy-py, dx-px) * 180 / Math.PI;
        const line = document.createElement('div'); line.className = 'map-course-line'; line.style.cssText = `left:${px}%;top:${py}%;width:${len}%;transform:rotate(${ang}deg)`; c.appendChild(line);
    }
    Object.entries(CONFIG.islands).forEach(([id, isl]) => {
        const dot = document.createElement('div'); dot.className = 'map-island ' + isl.faction + (id === destId ? ' selected' : '');
        dot.style.cssText = `left:${toP(isl.position.x, minX, maxX)}%;top:${toP(isl.position.z, minZ, maxZ)}%`; dot.textContent = isl.name[0]; dot.title = isl.name;
        dot.addEventListener('click', () => { gs.player.destinationIslandId = id; this.showMap(); this.toast('Course', isl.name); });
        c.appendChild(dot);
    });
    const p = document.createElement('div'); p.className = 'map-player'; p.style.cssText = `left:${toP(gs.player.position.x, minX, maxX)}%;top:${toP(gs.player.position.z, minZ, maxZ)}%`; c.appendChild(p);
    this.el['map-info'].textContent = destId ? 'Course: ' + CONFIG.islands[destId].name : 'Click island';
    this.el['map-modal'].classList.remove('hidden');
}

showPirate(cost, parley) { this.el['tribute-cost'].textContent = cost + 'g'; this.el['pirate-pass'].classList.toggle('hidden', !parley); this.el['pirate-modal'].classList.remove('hidden'); }
closePirate() { this.el['pirate-modal'].classList.add('hidden'); }

showTitleEarned(icon, name, desc) {
    this.el['title-icon'].textContent = icon;
    this.el['title-earned-name'].textContent = name;
    this.el['title-earned-desc'].textContent = desc;
    this.el['title-modal'].classList.remove('hidden');
}

showEncounter(enc, opts, result) {
    this.el['encounter-icon'].textContent = enc.icon; this.el['encounter-title'].textContent = enc.name; this.el['encounter-desc'].textContent = enc.desc;
    if (result) {
        this.el['encounter-result'].innerHTML = `<div class="encounter-${result.positive ? 'reward' : 'penalty'}">${result.text}</div>`;
        this.el['encounter-options'].innerHTML = '<button class="btn-primary" id="enc-close">OK</button>';
        document.getElementById('enc-close').addEventListener('click', () => this.el['encounter-modal'].classList.add('hidden'));
    }
    else {
        this.el['encounter-result'].innerHTML = '';
        this.el['encounter-options'].innerHTML = opts.map((o, i) => `<button class="btn-${o.style || 'secondary'}" data-i="${i}">${o.label}</button>`).join('');
        this.el['encounter-options'].querySelectorAll('button').forEach(b => b.addEventListener('click', () => opts[b.dataset.i].action()));
    }
    this.el['encounter-modal'].classList.remove('hidden');
}
closeEncounter() { this.el['encounter-modal'].classList.add('hidden'); }
showWarning(icon, title, text) { this.el['warning-icon'].textContent = icon; this.el['warning-title'].textContent = title; this.el['warning-text'].textContent = text; this.el['warning-modal'].classList.remove('hidden'); }
toast(title, desc) { this.el['event-title'].textContent = title; this.el['event-desc'].textContent = desc; this.el['event-toast'].classList.remove('hidden'); setTimeout(() => this.el['event-toast'].classList.add('hidden'), 3000); }

}

// ==================== GAME ====================
class Game {
constructor() { this.gameState = null; this.scene = null; this.ui = null; this.joystick = null; this.selectedFaction = null; this.nearbyIsland = null; this.lastDayTick = 0; this.init(); }
async init() {
    this.ui = new UI(this);
    for (let i = 0; i <= 100; i += 20) { this.ui.showLoading(i); await new Promise(r => setTimeout(r, 80)); }
    const save = localStorage.getItem('merchantSeasSave');
    setTimeout(() => { this.ui.hideLoading(); if (save && confirm('Continue?')) { this.load(); this.start(); } else this.ui.showFaction(); }, 300);
}

startGame(faction) {
    this.gameState = createState(faction); this.ui.hideFaction(); this.ui.showGame();
    this.scene = new SceneManager(document.getElementById('game-canvas')); this.joystick = new Joystick();
    this.ui.updateHUD(this.gameState); this.save(); this.start(); this.ui.toast('Welcome!', 'Sail to Port Royal!');
}

update(dt) {
    if (!this.gameState) return; this.checkNearby();
    if (this.gameState.isDocked) { this.ui.updateSpeed(0, null); return; }
    const gs = this.gameState;
    if (this.joystick?.magnitude > 0.1) {
        const md = { x: -this.joystick.value.x, z: -this.joystick.value.y }, len = Math.sqrt(md.x**2 + md.z**2); if (len) { md.x /= len; md.z /= len; }
        const we = getWindEffect(gs, md), spd = getShipSpeed(gs) * this.joystick.magnitude * 0.8 * we.mult;
        gs.player.position.x = Math.max(-250, Math.min(250, gs.player.position.x + md.x * spd));
        gs.player.position.z = Math.max(-200, Math.min(200, gs.player.position.z + md.z * spd));
        this.ui.updateSpeed(this.joystick.magnitude * we.mult, we); this.ui.updateCompass(this.joystick.angle, gs);
        this.lastDayTick += dt * 1000;
        if (this.lastDayTick > 5000) { this.advanceDay(); this.lastDayTick = 0; this.checkEncounters(); }
    } else { this.ui.updateSpeed(0, null); this.ui.updateCompass(0, gs); }
}

checkNearby() {
    const pp = this.gameState.player.position; let closest = null, cd = Infinity;
    Object.entries(CONFIG.islands).forEach(([id, isl]) => { const d = Math.sqrt((isl.position.x - pp.x)**2 + (isl.position.z - pp.z)**2); if (d < 80 && d < cd) { cd = d; closest = { id, ...isl, dist: d }; } });
    this.nearbyIsland = closest?.id || null; this.ui.updateNearby(closest, cd);
}

advanceDay() {
    const gs = this.gameState;
    gs.player.days++;
    gs.player.daysSinceDock = (gs.player.daysSinceDock || 0) + 1;

    // Consume supplies (with upgrade modifiers)
    const supplyRate = getSupplyRate(gs);
    gs.player.supplies -= Math.floor(supplyRate);
    // Handle fractional supply cost via RNG
    if (Math.random() < (supplyRate % 1)) gs.player.supplies--;

    // Decay heat while at sea
    decayHeat(gs);

    simMarketDay(gs);

    // Tick world state
    tickWorldStatePerDay(gs);

    // Check contract expirations
    const expired = expireContracts(gs);
    if (expired.length > 0) {
        this.ui.toast('Contract Failed', `${expired.length} contract(s) expired!`);
    }

    // Update titles
    const oldTitles = { ...gs.player.titles };
    updateTitles(gs, (icon, name, desc) => {
        this.ui.showTitleEarned(icon, name, desc);
    });

    // Wind changes
    if (gs.wind) {
        gs.wind.daysUntilChange--;
        if (gs.wind.daysUntilChange <= 0) {
            gs.wind.direction = Math.floor(Math.random() * 8);
            gs.wind.strength = Math.floor(Math.random() * 4);
            gs.wind.daysUntilChange = CONFIG.settings.windChangeDays;
            this.ui.toast('Wind', WIND_STR[gs.wind.strength].name + ' ' + WIND_DIRS[gs.wind.direction].name);
        }
    }

    this.ui.updateHUD(gs);
    if (gs.player.supplies <= 5 && gs.player.supplies > 0) this.ui.showWarning('ğŸ–', 'Low Supplies!', 'Dock soon!');
    else if (gs.player.supplies <= 0) { gs.player.supplies = 0; this.ui.showWarning('ğŸ’€', 'Stranded!', 'Find port fast!'); }
}

checkEncounters() {
    const gs = this.gameState, fc = CONFIG.factions[gs.player.faction];
    const risk = getRouteRisk(gs);
    const cargoVal = estimateCargoValue(gs);
    const mods = getTitleModifiers(gs);

    // Pirate encounters scale with cargo value and faction
    const pirateBase = CONFIG.settings.pirateEncounterChance * (fc.pirateChanceMult || 1);
    const pirateChance = pirateBase * (1 + risk * 0.5); // +50% at max risk
    if (Math.random() < pirateChance) { this.triggerPirate(); return; }

    // Inspection encounter - scales with heat, crackdown, and proximity to English/EITC waters
    if (isNearHostileWaters(gs) || gs.player.heat > 30) {
        let inspectChance = CONFIG.encounters.inspection.baseChance * (1 + gs.player.heat / 100);
        // Crackdown increases inspection chance
        inspectChance *= (1 + getCrackdownLevel(gs) / 100);
        // Smuggler compartments reduce chance
        if (gs.player.upgrades?.smugglerCompartments) inspectChance *= (1 - CONFIG.upgrades.smugglerCompartments.effects.inspectionReduction);
        // Title modifiers
        inspectChance *= (1 - mods.inspectionReduction);
        if (Math.random() < inspectChance) { this.triggerInspection(); return; }
    }

    // Storm - slight increase with days at sea and during storm season
    let stormChance = CONFIG.encounters.storm.baseChance * (1 + gs.player.daysSinceDock / 30);
    if (isStormSeason(gs)) stormChance *= 2;
    if (Math.random() < stormChance) { this.triggerStorm(); return; }

    // Merchant/wreck - slightly more common when risk is low (reward safe play)
    const safeBonus = 1 + (1 - risk) * 0.3;
    if (Math.random() < CONFIG.encounters.adriftMerchant.baseChance * safeBonus) { this.triggerMerchant(); return; }
    if (Math.random() < CONFIG.encounters.wreckSalvage.baseChance * safeBonus) { this.triggerWreck(); return; }
}

triggerPirate() {
    const gs = this.gameState;
    const baseCost = Math.floor(gs.player.gold * 0.1) + 50;
    const cost = calcTributeCost(gs, baseCost);
    this.ui.showPirate(cost, gs.player.faction === 'pirates');
}

payTribute() {
    const gs = this.gameState;
    const baseCost = Math.floor(gs.player.gold * 0.1) + 50;
    const cost = calcTributeCost(gs, baseCost);
    if (gs.player.gold >= cost) {
        gs.player.gold -= cost;
        this.ui.closePirate();
        this.ui.toast('Paid', '-' + cost + 'g');
    } else {
        this.loseCargo(calcCargoLoss(gs, 0.3));
        this.ui.closePirate();
        this.ui.toast('Plundered!', 'Lost cargo');
    }
    this.ui.updateHUD(gs);
}

fight() {
    const gs = this.gameState;
    this.ui.closePirate();
    if (Math.random() < 0.5) {
        const r = 50 + Math.floor(Math.random() * 100);
        gs.player.gold += r;
        // Pirate reputation boost
        applyRepChange(gs, 'pirates', 5, 'fight_win');
        this.ui.toast('Victory!', '+' + r + 'g');
    } else {
        this.loseCargo(calcCargoLoss(gs, 0.5));
        // Also lose some gold (protected by vault)
        const goldLoss = calcGoldLoss(gs, Math.floor(gs.player.gold * 0.1));
        gs.player.gold = Math.max(0, gs.player.gold - goldLoss);
        this.ui.toast('Defeated', 'Lost cargo & gold');
    }
    this.ui.updateHUD(gs);
}

loseCargo(frac) {
    const gs = this.gameState;
    Object.keys(gs.player.cargo).forEach(gid => {
        gs.player.cargo[gid] -= Math.ceil(gs.player.cargo[gid] * frac);
        if (gs.player.cargo[gid] <= 0) delete gs.player.cargo[gid];
    });
}

// INSPECTION ENCOUNTER
triggerInspection() {
    const gs = this.gameState, enc = CONFIG.encounters.inspection;
    const contrabandQty = getContrabandCount(gs);
    const hasContraband = contrabandQty > 0;

    // Mark inspection for courier contracts
    gs.player.inspectionTriggeredThisContract = true;

    // Crackdown increases
    gs.world.crackdown.level = Math.min(CONFIG.settings.crackdownMaxLevel, (gs.world.crackdown.level || 0) + 5);

    // If no contraband, just a warning
    if (!hasContraband) {
        this.ui.showEncounter(enc, [], { positive: true, text: 'Cargo is clean. You are free to go!' });
        return;
    }

    // Has contraband - calculate penalty
    let confiscateQty = Math.ceil(contrabandQty * 0.5);
    let fine = 50 + contrabandQty * 10;

    // Smuggler compartments can hide some
    if (gs.player.upgrades?.smugglerCompartments && Math.random() < 0.4) {
        // 40% chance to hide contraband completely
        this.ui.showEncounter(enc, [], { positive: true, text: 'Hidden compartments concealed your cargo. You pass inspection!' });
        return;
    }

    this.ui.showEncounter(enc, [
        {
            label: `ğŸ’° Pay Fine (${fine}g)`, style: 'danger',
            action: () => {
                if (gs.player.gold >= fine) {
                    gs.player.gold -= fine;
                    addHeat(gs, 10); // Heat increases when caught
                    this.ui.showEncounter(enc, [], { positive: false, text: `Paid ${fine}g fine. Contraband confiscated!` });
                } else {
                    // Can't pay - lose all contraband and reputation hit
                    this.confiscateContraband(gs);
                    applyRepChange(gs, 'english', -10, 'inspection_caught');
                    applyRepChange(gs, 'eitc', -10, 'inspection_caught');
                    addHeat(gs, 20);
                    this.ui.showEncounter(enc, [], { positive: false, text: 'No gold! All contraband seized. Reputation damaged.' });
                }
                // Confiscate contraband regardless
                this.confiscateContraband(gs);
                // Increase crackdown
                gs.world.crackdown.level = Math.min(CONFIG.settings.crackdownMaxLevel, (gs.world.crackdown.level || 0) + 10);
                this.ui.updateHUD(gs);
            }
        },
        {
            label: 'ğŸƒ Flee!',
            action: () => {
                if (Math.random() < 0.4) {
                    // Escaped
                    addHeat(gs, 15);
                    this.ui.showEncounter(enc, [], { positive: true, text: 'You escaped the patrol! Heat increased.' });
                } else {
                    // Caught - worse penalty
                    this.confiscateContraband(gs);
                    const penalty = Math.floor(gs.player.gold * 0.15);
                    gs.player.gold = Math.max(0, gs.player.gold - penalty);
                    applyRepChange(gs, 'english', -15, 'inspection_fled');
                    applyRepChange(gs, 'eitc', -15, 'inspection_fled');
                    addHeat(gs, 25);
                    gs.world.crackdown.level = Math.min(CONFIG.settings.crackdownMaxLevel, (gs.world.crackdown.level || 0) + 15);
                    this.ui.showEncounter(enc, [], { positive: false, text: `Caught fleeing! Lost ${penalty}g and all contraband. Major reputation hit.` });
                }
                this.ui.updateHUD(gs);
            }
        }
    ]);
}

confiscateContraband(gs) {
    Object.keys(gs.player.cargo).forEach(gid => {
        if (CONFIG.goods[gid]?.category === 'contraband') {
            delete gs.player.cargo[gid];
        }
    });
}

triggerStorm() {
    const gs = this.gameState, enc = CONFIG.encounters.storm;
    this.ui.showEncounter(enc, [
        { label: 'ğŸŒŠ Ride out', action: () => {
            const l = 2 + Math.floor(Math.random() * 3);
            gs.player.supplies = Math.max(0, gs.player.supplies - l);
            if (Math.random() < 0.3) {
                this.loseCargo(calcCargoLoss(gs, 0.15));
                this.ui.showEncounter(enc, [], { positive: false, text: `Lost ${l} supplies + cargo!` });
            } else
                this.ui.showEncounter(enc, [], { positive: false, text: `Lost ${l} supplies` });
            this.ui.updateHUD(gs);
        } },
        { label: 'âš“ Wait (safe)', style: 'primary', action: () => {
            gs.player.supplies--; gs.player.days++;
            this.ui.showEncounter(enc, [], { positive: true, text: 'Waited safely. Lost 1 day.' });
            this.ui.updateHUD(gs);
        } }
    ]);
}

triggerMerchant() {
    const gs = this.gameState, enc = CONFIG.encounters.adriftMerchant, gids = Object.keys(CONFIG.goods), gid = gids[Math.floor(Math.random() * gids.length)], g = CONFIG.goods[gid], qty = 3 + Math.floor(Math.random() * 5), price = Math.floor(g.basePrice * 0.6), total = price * qty;
    this.ui.showEncounter({ ...enc, desc: `Offers ${qty}x ${g.name} for ${price}g each (${total}g)` }, [
        { label: `ğŸ’° Buy (${total}g)`, style: 'primary', action: () => {
            const check = canCarryMore(gid, qty, gs);
            if (gs.player.gold >= total && check.canCarry) {
                gs.player.gold -= total;
                gs.player.cargo[gid] = (gs.player.cargo[gid] || 0) + qty;
                gs.player.purchaseHistory[gid] = price;
                if (g.category === 'contraband') addHeat(gs, CONFIG.settings.heatGainContraband);
                this.ui.showEncounter(enc, [], { positive: true, text: `Bought ${qty}x ${g.name}!` });
            } else
                this.ui.showEncounter(enc, [], { positive: false, text: check.reason || 'Not enough gold!' });
            this.ui.updateHUD(gs);
        } },
        { label: 'ğŸ‘‹ Pass', action: () => this.ui.closeEncounter() }
    ]);
}

triggerWreck() {
    const gs = this.gameState, enc = CONFIG.encounters.wreckSalvage;
    this.ui.showEncounter(enc, [
        { label: 'ğŸ” Investigate', style: 'primary', action: () => {
            const r = Math.random();
            if (r < 0.4) {
                const s = 3 + Math.floor(Math.random() * 5);
                gs.player.supplies = Math.min(30, gs.player.supplies + s);
                this.ui.showEncounter(enc, [], { positive: true, text: `Found ${s} supplies!` });
            } else if (r < 0.7) {
                const g = 20 + Math.floor(Math.random() * 50);
                gs.player.gold += g;
                this.ui.showEncounter(enc, [], { positive: true, text: `Found ${g} gold!` });
            } else if (r < 0.9) {
                const gids = Object.keys(CONFIG.goods), gid = gids[Math.floor(Math.random() * gids.length)], good = CONFIG.goods[gid], q = 1 + Math.floor(Math.random() * 3);
                const check = canCarryMore(gid, q, gs);
                if (check.canCarry) {
                    gs.player.cargo[gid] = (gs.player.cargo[gid] || 0) + q;
                    if (good.category === 'contraband') addHeat(gs, CONFIG.settings.heatGainContraband / 2);
                    this.ui.showEncounter(enc, [], { positive: true, text: `Salvaged ${q}x ${good.name}!` });
                } else
                    this.ui.showEncounter(enc, [], { positive: false, text: check.reason || 'No room!' });
            } else
                this.ui.showEncounter(enc, [], { positive: false, text: 'Nothing useful...' });
            this.ui.updateHUD(gs);
        } },
        { label: 'ğŸš¢ Sail on', action: () => this.ui.closeEncounter() }
    ]);
}

dock() {
    if (!this.nearbyIsland) { this.ui.toast('Too Far', 'Get closer!'); return; }
    const gs = this.gameState, pp = gs.player.position, isl = CONFIG.islands[this.nearbyIsland];
    if (Math.sqrt((isl.position.x - pp.x)**2 + (isl.position.z - pp.z)**2) > CONFIG.settings.dockDistance) { this.ui.toast('Too Far', 'Get closer!'); return; }

    gs.isDocked = true;
    gs.currentIsland = this.nearbyIsland;
    gs.player.daysSinceDock = 0; // Reset days since dock
    gs.player.inspectionTriggeredThisContract = false; // Reset for courier contracts

    // Heat changes on dock
    const islFaction = isl.faction;
    if (islFaction === 'english' || islFaction === 'eitc') {
        // Heat increases if carrying contraband at English/EITC ports
        if (getContrabandCount(gs) > 0) {
            addHeat(gs, CONFIG.settings.heatGainDockEnglishEITC);
        }
    } else {
        // Heat decays faster at pirate/neutral ports
        gs.player.heat = Math.max(0, (gs.player.heat || 0) - 10);
    }

    // Evaluate contracts
    const completedContracts = evaluateContractsOnDock(gs, this.nearbyIsland);
    if (completedContracts.length > 0) {
        const totalGold = completedContracts.reduce((sum, c) => sum + c.rewards.gold, 0);
        this.ui.toast('Contract Complete!', `+${totalGold}g earned`);
    }

    // Refresh contract board
    refreshContractBoard(gs, this.nearbyIsland);

    // Update titles
    updateTitles(gs, (icon, name, desc) => {
        this.ui.showTitleEarned(icon, name, desc);
    });

    // Resupply
    const cost = 2, maxBuy = Math.min(30 - gs.player.supplies, Math.floor(gs.player.gold / cost));
    if (maxBuy > 0 && gs.player.supplies < 15) { const b = Math.min(maxBuy, 15); gs.player.gold -= b * cost; gs.player.supplies += b; this.ui.toast('Resupplied', '+' + b); }
    this.ui.updateHUD(gs); this.ui.showTrade(this.nearbyIsland, gs); this.save();
}

undock() { this.gameState.isDocked = false; this.ui.closeTrade(); }

buyBest() {
    const gs = this.gameState, iid = gs.currentIsland; if (!iid) return;
    const deals = calcDeals(gs, iid);
    for (const d of deals) {
        const g = CONFIG.goods[d.gid], m = gs.islands[iid].markets[d.gid];
        const check = canCarryMore(d.gid, 1, gs);
        const max = Math.min(Math.floor(gs.player.gold / d.buyPrice), Math.floor((getCargoCapacity(gs) - getCargoUsed(gs)) / g.weight), m.supply);
        if (max > 0 && check.canCarry) {
            for (let i = 0; i < max; i++) if (!buyGood(d.gid, 1, iid, gs).success) break;
            this.ui.toast('Bought', g.name);
            this.ui.renderBuy(iid, gs); this.ui.renderSell(iid, gs); this.ui.updateFooter(gs); this.save();
            return;
        }
    }
    this.ui.toast('No Deals', 'Visit more ports');
}

sellBest() {
    const gs = this.gameState, iid = gs.currentIsland; if (!iid || !Object.keys(gs.player.cargo).length) { this.ui.toast('Empty', 'Nothing to sell'); return; }
    let best = null, bestScore = -Infinity;
    Object.entries(gs.player.cargo).forEach(([gid, qty]) => { const cp = calcPrice(gid, iid, gs), pp = gs.player.purchaseHistory[gid] || 0, score = (cp - pp) > 0 ? (cp - pp) * 1000 + cp : cp; if (score > bestScore) { bestScore = score; best = gid; } });
    if (best) { const g = CONFIG.goods[best], qty = gs.player.cargo[best]; for (let i = 0; i < qty; i++) if (!sellGood(best, 1, iid, gs).success) break; this.ui.toast('Sold', g.name); this.ui.renderBuy(iid, gs); this.ui.renderSell(iid, gs); this.ui.updateFooter(gs); this.save(); }
}

buyUpgrade(id) {
    const gs = this.gameState, u = CONFIG.upgrades[id];
    if (!u || gs.player.upgrades[id] || gs.player.gold < u.cost) return false;
    gs.player.gold -= u.cost;
    gs.player.upgrades[id] = true;
    this.ui.toast('Upgrade!', u.name);
    this.ui.updateHUD(gs);
    this.save();
    return true;
}

save() { localStorage.setItem('merchantSeasSave', JSON.stringify(this.gameState)); }
load() {
    try {
        this.gameState = migrateState(JSON.parse(localStorage.getItem('merchantSeasSave')));
        this.ui.hideFaction(); this.ui.showGame();
        this.scene = new SceneManager(document.getElementById('game-canvas'));
        this.joystick = new Joystick();
        this.ui.updateHUD(this.gameState);
        return true;
    } catch { return false; }
}
start() { this.lastTime = performance.now(); this.animate(); }
animate() {
    requestAnimationFrame(() => this.animate());
    if (!this.scene || !this.gameState) return;
    const now = performance.now(), dt = (now - this.lastTime) / 1000;
    this.lastTime = now;
    this.update(dt);
    this.scene.updateShip(this.gameState.player.position, this.joystick?.active ? this.joystick.angle : null);
    this.scene.updateCamera(this.gameState.player.position);
    this.scene.render();
}

}

window.addEventListener('DOMContentLoaded', () => { window.game = new Game(); });
</script>

</body>
</html>